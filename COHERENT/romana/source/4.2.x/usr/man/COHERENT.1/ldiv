llddiivv() -- General Function (libc)

Perform long integer division
#iinncclluuddee <ssttddlliibb.hh>
llddiivv_tt llddiivv(_n_u_m_e_r_a_t_o_r, _d_e_n_o_m_i_n_a_t_o_r)
lloonngg _n_u_m_e_r_a_t_o_r, _d_e_n_o_m_i_n_a_t_o_r;

llddiivv() divides _n_u_m_e_r_a_t_o_r by _d_e_n_o_m_i_n_a_t_o_r. It returns a structure of the type
llddiivv_tt, which is structured as follows:

    typedef struct {
        long quot;
        long rem;
    } ldiv_t;

llddiivv() writes the quotient into qquuoott and the remainder into rreemm.

The sign of the quotient is  positive if the signs of the arguments are the
same; it is negative if the signs of the arguments differ.  The sign of the
remainder is the same as the sign of the numerator.

If the remainder is non-zero, the  magnitude of the quotient is the largest
integer less  than the  magnitude of the  algebraic quotient.  This  is not
guaranteed  by the  operators /  and %,  which merely  do what  the machine
implements for divide.

_S_e_e _A_l_s_o
lliibbcc
ANSI Standard, section 7.10.6.4

_N_o_t_e_s
The ANSI  Standard includes this function to permit  a useful feature found
in most  versions of FORTRAN, where  the sign of the  remainder will be the
same  as the  sign  of the  numerator.   Also, on  most machines,  division
produces a remainder.  This allows  a quotient and remainder to be returned
from one machine-divide operation.

If the result of  division cannot be represented (e.g., because _d_e_n_o_m_i_n_a_t_o_r
is set to zero), the behavior of llddiivv() is undefined.  _C_a_v_e_a_t _u_t_i_l_i_t_o_r.
