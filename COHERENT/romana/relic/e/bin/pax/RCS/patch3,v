head     1.1;
branch   ;
access   ;
symbols  ;
locks    bin:1.1; strict;
comment  @# @;


1.1
date     92.08.28.08.02.40;  author bin;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@
Index: port.c
*** /tmp/,RCSt1a17133	Sun Feb 12 14:08:42 1989
--- port.c	Sun Feb 12 14:02:30 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/port.c,v $
   *
!  * $Revision: 1.1 $
   *
   * port.c - These are routines not available in all environments. 
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/port.c,v $
   *
!  * $Revision: 1.2 $
   *
   * port.c - These are routines not available in all environments. 
   *
***************
*** 30,36
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	port.c,v $
   * Revision 1.1  88/12/23  18:02:29  mark

--- 30,36 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	port.c,v $
   * Revision 1.2  89/02/12  10:05:35  mark
***************
*** 33,38
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	port.c,v $
   * Revision 1.1  88/12/23  18:02:29  mark
   * Initial revision
   * 

--- 33,41 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	port.c,v $
+  * Revision 1.2  89/02/12  10:05:35  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:29  mark
   * Initial revision
   * 
***************
*** 39,45
   */
  
  #ifndef lint
! static char *ident = "$Id: port.c,v 1.1 88/12/23 18:02:29 mark Rel $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 42,48 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: port.c,v 1.2 89/02/12 10:05:35 mark Exp $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 55,62
   * the list in the #if !defined()'s below and it'll all be skipped. 
   */
  
! #if !defined(mc300) && !defined(mc500) && !defined(mc700) && \
!     !defined(BSD)
  
  /* mkdir - make a directory
   *

--- 58,64 -----
   * the list in the #if !defined()'s below and it'll all be skipped. 
   */
  
! #if !defined(mc300) && !defined(mc500) && !defined(mc700) && !defined(BSD)
  
  /* mkdir - make a directory
   *
Index: port.h
*** /tmp/,RCSt1a17138	Sun Feb 12 14:08:49 1989
--- port.h	Sun Feb 12 14:02:31 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/port.h,v $
   *
!  * $Revision: 1.1 $
   *
   * port.h - defnitions for portability library
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/port.h,v $
   *
!  * $Revision: 1.2 $
   *
   * port.h - defnitions for portability library
   *
***************
*** 30,36
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   */
  
  #ifndef _PAX_PORT_H

--- 30,36 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   */
  
  #ifndef _PAX_PORT_H
Index: regexp.c
*** /tmp/,RCSt1a17143	Sun Feb 12 14:08:58 1989
--- regexp.c	Sun Feb 12 14:02:34 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/regexp.c,v $
   *
!  * $Revision: 1.1 $
   *
   * regexp.c - regular expression matching
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/regexp.c,v $
   *
!  * $Revision: 1.2 $
   *
   * regexp.c - regular expression matching
   *
***************
*** 43,48
   * Sponsored by The USENIX Association for public distribution. 
   *
   * $Log:	regexp.c,v $
   * Revision 1.1  88/12/23  18:02:32  mark
   * Initial revision
   * 

--- 43,51 -----
   * Sponsored by The USENIX Association for public distribution. 
   *
   * $Log:	regexp.c,v $
+  * Revision 1.2  89/02/12  10:05:39  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:32  mark
   * Initial revision
   * 
***************
*** 53,59
  #include "pax.h"
  
  #ifndef lint
! static char    *Ident = "$Id: regexp.c,v 1.1 88/12/23 18:02:32 mark Rel $";
  #endif
  
  

--- 56,62 -----
  #include "pax.h"
  
  #ifndef lint
! static char    *Ident = "$Id: regexp.c,v 1.2 89/02/12 10:05:39 mark Exp $";
  #endif
  
  
***************
*** 224,230
      int             flags;
      extern char    *malloc();
  
!     if (exp == NULL)
  	FAIL("NULL argument");
  
      /* First pass: determine size, legality. */

--- 227,233 -----
      int             flags;
      extern char    *malloc();
  
!     if (exp == (char *)NULL)
  	FAIL("NULL argument");
  
      /* First pass: determine size, legality. */
***************
*** 233,240
      regsize = 0L;
      regcode = &regdummy;
      regc(MAGIC);
!     if (reg(0, &flags) == NULL)
! 	return (NULL);
  
      /* Small enough for pointer-storage convention? */
      if (regsize >= 32767L)	/* Probably could be 65535L. */

--- 236,243 -----
      regsize = 0L;
      regcode = &regdummy;
      regc(MAGIC);
!     if (reg(0, &flags) == (char *)NULL)
! 	return ((regexp *)NULL);
  
      /* Small enough for pointer-storage convention? */
      if (regsize >= 32767L)	/* Probably could be 65535L. */
***************
*** 242,248
  
      /* Allocate space. */
      r = (regexp *) malloc(sizeof(regexp) + (unsigned) regsize);
!     if (r == NULL)
  	FAIL("out of space");
  
      /* Second pass: emit code. */

--- 245,251 -----
  
      /* Allocate space. */
      r = (regexp *) malloc(sizeof(regexp) + (unsigned) regsize);
!     if (r == (regexp *) NULL)
  	FAIL("out of space");
  
      /* Second pass: emit code. */
***************
*** 251,257
      regcode = r->program;
      regc(MAGIC);
      if (reg(0, &flags) == NULL)
! 	return (NULL);
  
      /* Dig out information for optimizations. */
      r->regstart = '\0';		/* Worst-case defaults. */

--- 254,260 -----
      regcode = r->program;
      regc(MAGIC);
      if (reg(0, &flags) == NULL)
! 	return ((regexp *) NULL);
  
      /* Dig out information for optimizations. */
      r->regstart = '\0';		/* Worst-case defaults. */
***************
*** 320,326
  	regnpar++;
  	ret = regnode(OPEN + parno);
      } else
! 	ret = NULL;
  
      /* Pick up the branches, linking them together. */
      br = regbranch(&flags);

--- 323,329 -----
  	regnpar++;
  	ret = regnode(OPEN + parno);
      } else
! 	ret = (char *)NULL;
  
      /* Pick up the branches, linking them together. */
      br = regbranch(&flags);
***************
*** 324,332
  
      /* Pick up the branches, linking them together. */
      br = regbranch(&flags);
!     if (br == NULL)
! 	return (NULL);
!     if (ret != NULL)
  	regtail(ret, br);	/* OPEN -> first. */
      else
  	ret = br;

--- 327,335 -----
  
      /* Pick up the branches, linking them together. */
      br = regbranch(&flags);
!     if (br == (char *)NULL)
! 	return ((char *)NULL);
!     if (ret != (char *)NULL)
  	regtail(ret, br);	/* OPEN -> first. */
      else
  	ret = br;
***************
*** 336,343
      while (*regparse == '|') {
  	regparse++;
  	br = regbranch(&flags);
! 	if (br == NULL)
! 	    return (NULL);
  	regtail(ret, br);	/* BRANCH -> BRANCH. */
  	if (!(flags & HASWIDTH))
  	    *flagp &= ~HASWIDTH;

--- 339,346 -----
      while (*regparse == '|') {
  	regparse++;
  	br = regbranch(&flags);
! 	if (br == (char *)NULL)
! 	    return ((char *)NULL);
  	regtail(ret, br);	/* BRANCH -> BRANCH. */
  	if (!(flags & HASWIDTH))
  	    *flagp &= ~HASWIDTH;
***************
*** 349,355
      regtail(ret, ender);
  
      /* Hook the tails of the branches to the closing node. */
!     for (br = ret; br != NULL; br = regnext(br))
  	regoptail(br, ender);
  
      /* Check for proper termination. */

--- 352,358 -----
      regtail(ret, ender);
  
      /* Hook the tails of the branches to the closing node. */
!     for (br = ret; br != (char *)NULL; br = regnext(br))
  	regoptail(br, ender);
  
      /* Check for proper termination. */
***************
*** 381,387
      *flagp = WORST;		/* Tentatively. */
  
      ret = regnode(BRANCH);
!     chain = NULL;
      while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
  	latest = regpiece(&flags);
  	if (latest == NULL)

--- 384,390 -----
      *flagp = WORST;		/* Tentatively. */
  
      ret = regnode(BRANCH);
!     chain = (char *)NULL;
      while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
  	latest = regpiece(&flags);
  	if (latest == (char *)NULL)
***************
*** 384,391
      chain = NULL;
      while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
  	latest = regpiece(&flags);
! 	if (latest == NULL)
! 	    return (NULL);
  	*flagp |= flags & HASWIDTH;
  	if (chain == NULL)	/* First piece. */
  	    *flagp |= flags & SPSTART;

--- 387,394 -----
      chain = (char *)NULL;
      while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
  	latest = regpiece(&flags);
! 	if (latest == (char *)NULL)
! 	    return ((char *)NULL);
  	*flagp |= flags & HASWIDTH;
  	if (chain == (char *)NULL)	/* First piece. */
  	    *flagp |= flags & SPSTART;
***************
*** 387,393
  	if (latest == NULL)
  	    return (NULL);
  	*flagp |= flags & HASWIDTH;
! 	if (chain == NULL)	/* First piece. */
  	    *flagp |= flags & SPSTART;
  	else
  	    regtail(chain, latest);

--- 390,396 -----
  	if (latest == (char *)NULL)
  	    return ((char *)NULL);
  	*flagp |= flags & HASWIDTH;
! 	if (chain == (char *)NULL)	/* First piece. */
  	    *flagp |= flags & SPSTART;
  	else
  	    regtail(chain, latest);
***************
*** 393,399
  	    regtail(chain, latest);
  	chain = latest;
      }
!     if (chain == NULL)		/* Loop ran zero times. */
  	regnode(NOTHING);
  
      return (ret);

--- 396,402 -----
  	    regtail(chain, latest);
  	chain = latest;
      }
!     if (chain == (char *)NULL)		/* Loop ran zero times. */
  	regnode(NOTHING);
  
      return (ret);
***************
*** 416,423
      int             flags;
  
      ret = regatom(&flags);
!     if (ret == NULL)
! 	return (NULL);
  
      op = *regparse;
      if (!ISMULT(op)) {

--- 419,426 -----
      int             flags;
  
      ret = regatom(&flags);
!     if (ret == (char *)NULL)
! 	return ((char *)NULL);
  
      op = *regparse;
      if (!ISMULT(op)) {
***************
*** 509,516
  	break;
      case '(':
  	ret = reg(1, &flags);
! 	if (ret == NULL)
! 	    return (NULL);
  	*flagp |= flags & (HASWIDTH | SPSTART);
  	break;
      case '\0':

--- 512,519 -----
  	break;
      case '(':
  	ret = reg(1, &flags);
! 	if (ret == (char *)NULL)
! 	    return ((char *)NULL);
  	*flagp |= flags & (HASWIDTH | SPSTART);
  	break;
      case '\0':
***************
*** 638,644
      scan = p;
      for (;;) {
  	temp = regnext(scan);
! 	if (temp == NULL)
  	    break;
  	scan = temp;
      }

--- 641,647 -----
      scan = p;
      for (;;) {
  	temp = regnext(scan);
! 	if (temp == (char *)NULL)
  	    break;
  	scan = temp;
      }
***************
*** 659,665
  char           *val;
  {
      /* "Operandless" and "op != BRANCH" are synonymous in practice. */
!     if (p == NULL || p == &regdummy || OP(p) != BRANCH)
  	return;
      regtail(OPERAND(p), val);
  }

--- 662,668 -----
  char           *val;
  {
      /* "Operandless" and "op != BRANCH" are synonymous in practice. */
!     if (p == (char *)NULL || p == &regdummy || OP(p) != BRANCH)
  	return;
      regtail(OPERAND(p), val);
  }
***************
*** 699,705
      register char  *s;
  
      /* Be paranoid... */
!     if (prog == NULL || string == NULL) {
  	regerror("NULL parameter");
  	return (0);
      }

--- 702,708 -----
      register char  *s;
  
      /* Be paranoid... */
!     if (prog == (regexp *)NULL || string == (char *)NULL) {
  	regerror("NULL parameter");
  	return (0);
      }
***************
*** 709,715
  	return (0);
      }
      /* If there is a "must appear" string, look for it. */
!     if (prog->regmust != NULL) {
  	s = string;
  	while ((s = strchr(s, prog->regmust[0])) != NULL) {
  	    if (strncmp(s, prog->regmust, prog->regmlen) == 0)

--- 712,718 -----
  	return (0);
      }
      /* If there is a "must appear" string, look for it. */
!     if (prog->regmust != (char *)NULL) {
  	s = string;
  	while ((s = strchr(s, prog->regmust[0])) != (char *)NULL) {
  	    if (strncmp(s, prog->regmust, prog->regmlen) == 0)
***************
*** 711,717
      /* If there is a "must appear" string, look for it. */
      if (prog->regmust != NULL) {
  	s = string;
! 	while ((s = strchr(s, prog->regmust[0])) != NULL) {
  	    if (strncmp(s, prog->regmust, prog->regmlen) == 0)
  		break;		/* Found it. */
  	    s++;

--- 714,720 -----
      /* If there is a "must appear" string, look for it. */
      if (prog->regmust != (char *)NULL) {
  	s = string;
! 	while ((s = strchr(s, prog->regmust[0])) != (char *)NULL) {
  	    if (strncmp(s, prog->regmust, prog->regmlen) == 0)
  		break;		/* Found it. */
  	    s++;
***************
*** 716,722
  		break;		/* Found it. */
  	    s++;
  	}
! 	if (s == NULL)		/* Not present. */
  	    return (0);
      }
      /* Mark beginning of line for ^ . */

--- 719,725 -----
  		break;		/* Found it. */
  	    s++;
  	}
! 	if (s == (char *)NULL)		/* Not present. */
  	    return (0);
      }
      /* Mark beginning of line for ^ . */
***************
*** 730,736
      s = string;
      if (prog->regstart != '\0')
  	/* We know what char it must start with. */
! 	while ((s = strchr(s, prog->regstart)) != NULL) {
  	    if (regtry(prog, s))
  		return (1);
  	    s++;

--- 733,739 -----
      s = string;
      if (prog->regstart != '\0')
  	/* We know what char it must start with. */
! 	while ((s = strchr(s, prog->regstart)) != (char *)NULL) {
  	    if (regtry(prog, s))
  		return (1);
  	    s++;
***************
*** 772,779
      sp = prog->startp;
      ep = prog->endp;
      for (i = NSUBEXP; i > 0; i--) {
! 	*sp++ = NULL;
! 	*ep++ = NULL;
      }
      if (regmatch(prog->program + 1)) {
  	prog->startp[0] = string;

--- 775,782 -----
      sp = prog->startp;
      ep = prog->endp;
      for (i = NSUBEXP; i > 0; i--) {
! 	*sp++ = (char *)NULL;
! 	*ep++ = (char *)NULL;
      }
      if (regmatch(prog->program + 1)) {
  	prog->startp[0] = string;
***************
*** 809,815
  
      scan = prog;
  #ifdef DEBUG
!     if (scan != NULL && regnarrate)
  	fprintf(stderr, "%s(\n", regprop(scan));
  #endif
      while (scan != NULL) {

--- 812,818 -----
  
      scan = prog;
  #ifdef DEBUG
!     if (scan != (char *)NULL && regnarrate)
  	fprintf(stderr, "%s(\n", regprop(scan));
  #endif
      while (scan != (char *)NULL) {
***************
*** 812,818
      if (scan != NULL && regnarrate)
  	fprintf(stderr, "%s(\n", regprop(scan));
  #endif
!     while (scan != NULL) {
  #ifdef DEBUG
  	if (regnarrate)
  	    fprintf(stderr, "%s...\n", regprop(scan));

--- 815,821 -----
      if (scan != (char *)NULL && regnarrate)
  	fprintf(stderr, "%s(\n", regprop(scan));
  #endif
!     while (scan != (char *)NULL) {
  #ifdef DEBUG
  	if (regnarrate)
  	    fprintf(stderr, "%s...\n", regprop(scan));
***************
*** 848,854
  	    }
  	    break;
  	case ANYOF:
! 	    if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
  		return (0);
  	    reginput++;
  	    break;

--- 851,858 -----
  	    }
  	    break;
  	case ANYOF:
! 	    if (*reginput == '\0' || 
! 		 strchr(OPERAND(scan), *reginput) == (char *)NULL)
  		return (0);
  	    reginput++;
  	    break;
***************
*** 853,859
  	    reginput++;
  	    break;
  	case ANYBUT:
! 	    if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
  		return (0);
  	    reginput++;
  	    break;

--- 857,864 -----
  	    reginput++;
  	    break;
  	case ANYBUT:
! 	    if (*reginput == '\0' || 
! 		 strchr(OPERAND(scan), *reginput) != (char *)NULL)
  		return (0);
  	    reginput++;
  	    break;
***************
*** 881,887
  		     * Don't set startp if some later invocation of the same
  		     * parentheses already has. 
  		     */
! 		    if (regstartp[no] == NULL)
  			regstartp[no] = save;
  		    return (1);
  		} else

--- 886,892 -----
  		     * Don't set startp if some later invocation of the same
  		     * parentheses already has. 
  		     */
! 		    if (regstartp[no] == (char *)NULL)
  			regstartp[no] = save;
  		    return (1);
  		} else
***************
*** 908,914
  		     * Don't set endp if some later invocation of the same
  		     * parentheses already has. 
  		     */
! 		    if (regendp[no] == NULL)
  			regendp[no] = save;
  		    return (1);
  		} else

--- 913,919 -----
  		     * Don't set endp if some later invocation of the same
  		     * parentheses already has. 
  		     */
! 		    if (regendp[no] == (char *)NULL)
  			regendp[no] = save;
  		    return (1);
  		} else
***************
*** 927,933
  			    return (1);
  			reginput = save;
  			scan = regnext(scan);
! 		    } while (scan != NULL && OP(scan) == BRANCH);
  		    return (0);
  		    /* NOTREACHED */
  		}

--- 932,938 -----
  			    return (1);
  			reginput = save;
  			scan = regnext(scan);
! 		    } while (scan != (char *)NULL && OP(scan) == BRANCH);
  		    return (0);
  		    /* NOTREACHED */
  		}
***************
*** 937,943
  		register char   nextch;
  		register int    no;
  		register char  *save;
! 		register int    min;
  
  		/*
  		 * Lookahead to avoid useless match attempts when we know

--- 942,948 -----
  		register char   nextch;
  		register int    no;
  		register char  *save;
! 		register int    minimum;
  
  		/*
  		 * Lookahead to avoid useless match attempts when we know
***************
*** 946,952
  		nextch = '\0';
  		if (OP(nxt) == EXACTLY)
  		    nextch = *OPERAND(nxt);
! 		min = (OP(scan) == STAR) ? 0 : 1;
  		save = reginput;
  		no = regrepeat(OPERAND(scan));
  		while (no >= min) {

--- 951,957 -----
  		nextch = '\0';
  		if (OP(nxt) == EXACTLY)
  		    nextch = *OPERAND(nxt);
! 		minimum = (OP(scan) == STAR) ? 0 : 1;
  		save = reginput;
  		no = regrepeat(OPERAND(scan));
  		while (no >= minimum) {
***************
*** 949,955
  		min = (OP(scan) == STAR) ? 0 : 1;
  		save = reginput;
  		no = regrepeat(OPERAND(scan));
! 		while (no >= min) {
  		    /* If it could work, try it. */
  		    if (nextch == '\0' || *reginput == nextch)
  			if (regmatch(nxt))

--- 954,960 -----
  		minimum = (OP(scan) == STAR) ? 0 : 1;
  		save = reginput;
  		no = regrepeat(OPERAND(scan));
! 		while (no >= minimum) {
  		    /* If it could work, try it. */
  		    if (nextch == '\0' || *reginput == nextch)
  			if (regmatch(nxt))
***************
*** 1013,1019
  	}
  	break;
      case ANYOF:
! 	while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
  	    count++;
  	    scan++;
  	}

--- 1018,1024 -----
  	}
  	break;
      case ANYOF:
! 	while (*scan != '\0' && strchr(opnd, *scan) != (char *)NULL) {
  	    count++;
  	    scan++;
  	}
***************
*** 1019,1025
  	}
  	break;
      case ANYBUT:
! 	while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
  	    count++;
  	    scan++;
  	}

--- 1024,1030 -----
  	}
  	break;
      case ANYBUT:
! 	while (*scan != '\0' && strchr(opnd, *scan) == (char *)NULL) {
  	    count++;
  	    scan++;
  	}
***************
*** 1052,1058
      register int    offset;
  
      if (p == &regdummy)
! 	return (NULL);
  
      offset = NEXT(p);
      if (offset == 0)

--- 1057,1063 -----
      register int    offset;
  
      if (p == &regdummy)
! 	return ((char *)NULL);
  
      offset = NEXT(p);
      if (offset == 0)
***************
*** 1056,1062
  
      offset = NEXT(p);
      if (offset == 0)
! 	return (NULL);
  
      if (OP(p) == BACK)
  	return (p - offset);

--- 1061,1067 -----
  
      offset = NEXT(p);
      if (offset == 0)
! 	return ((char *)NULL);
  
      if (OP(p) == BACK)
  	return (p - offset);
***************
*** 1093,1099
  	op = OP(s);
  	printf("%2d%s", s - r->program, regprop(s));	/* Where, what. */
  	nxt = regnext(s);
! 	if (nxt == NULL)	/* nxt ptr. */
  	    printf("(0)");
  	else
  	    printf("(%d)", (s - r->program) + (nxt - s));

--- 1098,1104 -----
  	op = OP(s);
  	printf("%2d%s", s - r->program, regprop(s));	/* Where, what. */
  	nxt = regnext(s);
! 	if (nxt == (char *)NULL)	/* nxt ptr. */
  	    printf("(0)");
  	else
  	    printf("(%d)", (s - r->program) + (nxt - s));
***************
*** 1114,1120
  	printf("start `%c' ", r->regstart);
      if (r->reganch)
  	printf("anchored ");
!     if (r->regmust != NULL)
  	printf("must have \"%s\"", r->regmust);
      printf("\n");
  }

--- 1119,1125 -----
  	printf("start `%c' ", r->regstart);
      if (r->reganch)
  	printf("anchored ");
!     if (r->regmust != (char *)NULL)
  	printf("must have \"%s\"", r->regmust);
      printf("\n");
  }
***************
*** 1179,1185
      case OPEN + 8:
      case OPEN + 9:
  	sprintf(buf + strlen(buf), "OPEN%d", OP(op) - OPEN);
! 	p = NULL;
  	break;
      case CLOSE + 1:
      case CLOSE + 2:

--- 1184,1190 -----
      case OPEN + 8:
      case OPEN + 9:
  	sprintf(buf + strlen(buf), "OPEN%d", OP(op) - OPEN);
! 	p = (char *)NULL;
  	break;
      case CLOSE + 1:
      case CLOSE + 2:
***************
*** 1191,1197
      case CLOSE + 8:
      case CLOSE + 9:
  	sprintf(buf + strlen(buf), "CLOSE%d", OP(op) - CLOSE);
! 	p = NULL;
  	break;
      case STAR:
  	p = "STAR";

--- 1196,1202 -----
      case CLOSE + 8:
      case CLOSE + 9:
  	sprintf(buf + strlen(buf), "CLOSE%d", OP(op) - CLOSE);
! 	p = (char *)NULL;
  	break;
      case STAR:
  	p = "STAR";
***************
*** 1200,1206
  	regerror("corrupted opcode");
  	break;
      }
!     if (p != NULL)
  	strcat(buf, p);
      return (buf);
  }

--- 1205,1211 -----
  	regerror("corrupted opcode");
  	break;
      }
!     if (p != (char *)NULL)
  	strcat(buf, p);
      return (buf);
  }
***************
*** 1269,1275
      register int    len;
      extern char    *strncpy();
  
!     if (prog == NULL || source == NULL || dest == NULL) {
  	regerror("NULL parm to regsub");
  	return;
      }

--- 1274,1281 -----
      register int    len;
      extern char    *strncpy();
  
!     if (prog == (regexp *)NULL || 
! 	source == (char *)NULL || dest == (char *)NULL) {
  	regerror("NULL parm to regsub");
  	return;
      }
***************
*** 1291,1297
  	    if (c == '\\' && (*src == '\\' || *src == '&'))
  		c = *src++;
  	    *dst++ = c;
! 	} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
  	    len = prog->endp[no] - prog->startp[no];
  	    strncpy(dst, prog->startp[no], len);
  	    dst += len;

--- 1297,1304 -----
  	    if (c == '\\' && (*src == '\\' || *src == '&'))
  		c = *src++;
  	    *dst++ = c;
! 	} else if (prog->startp[no] != (char *)NULL && 
! 		   prog->endp[no] != (char *)NULL) {
  	    len = prog->endp[no] - prog->startp[no];
  	    strncpy(dst, prog->startp[no], len);
  	    dst += len;
Index: replace.c
*** /tmp/,RCSt1a17153	Sun Feb 12 14:09:24 1989
--- replace.c	Sun Feb 12 14:02:36 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/replace.c,v $
   *
!  * $Revision: 1.1 $
   *
   * replace.c - regular expression pattern replacement functions
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/replace.c,v $
   *
!  * $Revision: 1.2 $
   *
   * replace.c - regular expression pattern replacement functions
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	replace.c,v $
   * Revision 1.1  88/12/23  18:02:36  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	replace.c,v $
   * Revision 1.2  89/02/12  10:05:59  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	replace.c,v $
   * Revision 1.1  88/12/23  18:02:36  mark
   * Initial revision
   * 

--- 30,38 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	replace.c,v $
+  * Revision 1.2  89/02/12  10:05:59  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:36  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: replace.c,v 1.1 88/12/23 18:02:36 mark Rel $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* not lint */
  

--- 39,45 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: replace.c,v 1.2 89/02/12 10:05:59 mark Exp $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* not lint */
  
***************
*** 78,84
  		 "Malformed substitution syntax");
  	return;
      }
!     if ((rptr = (Replstr *) malloc(sizeof(Replstr))) == NULL) {
  	warn("Replacement string not added", "No space");
  	return;
      }

--- 81,87 -----
  		 "Malformed substitution syntax");
  	return;
      }
!     if ((rptr = (Replstr *) malloc(sizeof(Replstr))) == (Replstr *)NULL) {
  	warn("Replacement string not added", "No space");
  	return;
      }
***************
*** 130,136
       * Now pattern points to 'old' and p points to 'new' and both are '\0'
       * terminated 
       */
!     if ((rptr->comp = regcomp(pattern)) == NULL) {
  	warn("Replacement string not added", "Invalid RE");
  	free(rptr);
  	return;

--- 133,139 -----
       * Now pattern points to 'old' and p points to 'new' and both are '\0'
       * terminated 
       */
!     if ((rptr->comp = regcomp(pattern)) == (regexp *)NULL) {
  	warn("Replacement string not added", "Invalid RE");
  	free(rptr);
  	return;
***************
*** 136,143
  	return;
      }
      rptr->replace = p;
!     rptr->next = NULL;
!     if (rplhead == NULL) {
  	rplhead = rptr;
  	rpltail = rptr;
      } else {

--- 139,146 -----
  	return;
      }
      rptr->replace = p;
!     rptr->next = (Replstr *)NULL;
!     if (rplhead == (Replstr *)NULL) {
  	rplhead = rptr;
  	rpltail = rptr;
      } else {
***************
*** 182,188
      char           *b;
  
      strcpy(buff, name);
!     for (rptr = rplhead; !found && rptr != NULL; rptr = rptr->next) {
  	do {
  	    if ((ret = regexec(rptr->comp, buff)) != 0) {
  		p = buff;

--- 185,191 -----
      char           *b;
  
      strcpy(buff, name);
!     for (rptr = rplhead; !found && rptr != (Replstr *)NULL; rptr = rptr->next) {
  	do {
  	    if ((ret = regexec(rptr->comp, buff)) != 0) {
  		p = buff;
Index: tar.1
*** /tmp/,RCSt1a17158	Sun Feb 12 14:09:31 1989
--- tar.1	Sun Feb 12 14:02:37 1989
***************
*** 1,4
! .\" $Id: tar.1,v 1.1 88/12/23 18:02:37 mark Rel $
  .TH TAR 1 "USENIX Association" ""
  .SH NAME
  tar \- process tape archives

--- 1,4 -----
! .\" $Id: tar.1,v 1.2 89/02/12 10:08:55 mark Exp $
  .TH TAR 1 "USENIX Association" ""
  .SH NAME
  tar \- process tape archives
***************
*** 178,184
  .PP
  THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
! WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  .SH AUTHOR
  Mark H. Colburn
  .br

--- 178,184 -----
  .PP
  THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  .SH AUTHOR
  Mark H. Colburn
  .br
Index: tar.c
*** /tmp/,RCSt1a17163	Sun Feb 12 14:09:37 1989
--- tar.c	Sun Feb 12 14:02:38 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/tar.c,v $
   *
!  * $Revision: 1.1 $
   *
   * tar.c - tar specific functions for archive handling
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/tar.c,v $
   *
!  * $Revision: 1.2 $
   *
   * tar.c - tar specific functions for archive handling
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	tar.c,v $
   * Revision 1.1  88/12/23  18:02:38  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	tar.c,v $
   * Revision 1.2  89/02/12  10:06:05  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	tar.c,v $
   * Revision 1.1  88/12/23  18:02:38  mark
   * Initial revision
   * 

--- 30,38 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	tar.c,v $
+  * Revision 1.2  89/02/12  10:06:05  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:38  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: tar.c,v 1.1 88/12/23 18:02:38 mark Rel $";
  static char *copyright ="Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.";
  #endif /* not lint */
  

--- 39,45 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: tar.c,v 1.2 89/02/12 10:06:05 mark Exp $";
  static char *copyright ="Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.";
  #endif /* not lint */
  
***************
*** 109,116
       * of the tar and/or cpio interfaces...
       */
      f_unconditional = 1;
!     f_modification_time = 1;
!     f_create_dirs = 1;
      blocking = 0;
      ar_interface = TAR;
      ar_format = TAR;

--- 112,119 -----
       * of the tar and/or cpio interfaces...
       */
      f_unconditional = 1;
!     f_mtime = 1;
!     f_dir_create = 1;
      blocking = 0;
      ar_interface = TAR;
      ar_format = TAR;
***************
*** 114,120
      blocking = 0;
      ar_interface = TAR;
      ar_format = TAR;
!     msgfile=stdout;
  
      /* Parse options */
      while ((c = taropt(argc, argv, "b:cf:hlmortuvwx")) != EOF) {

--- 117,123 -----
      blocking = 0;
      ar_interface = TAR;
      ar_format = TAR;
!     msgfile=stderr;
  
      /* Parse options */
      while ((c = taropt(argc, argv, "b:cf:hlmortuvwx")) != EOF) {
***************
*** 258,264
      char            c;
      char           *place;
  
!     optarg = NULL;
  
      if (key == NULL) {		/* First time */
  	if (argc < 2)

--- 261,267 -----
      char            c;
      char           *place;
  
!     optarg = (char *)NULL;
  
      if (key == (char *)NULL) {		/* First time */
  	if (argc < 2)
***************
*** 260,266
  
      optarg = NULL;
  
!     if (key == NULL) {		/* First time */
  	if (argc < 2)
  	    return EOF;
  	key = argv[1];

--- 263,269 -----
  
      optarg = (char *)NULL;
  
!     if (key == (char *)NULL) {		/* First time */
  	if (argc < 2)
  	    return EOF;
  	key = argv[1];
***************
*** 280,286
      }
      place = strchr(optstring, c);
  
!     if (place == NULL || c == ':') {
  	fprintf(stderr, "%s: unknown option %c\n", argv[0], c);
  	return ('?');
      }

--- 283,289 -----
      }
      place = strchr(optstring, c);
  
!     if (place == (char *)NULL || c == ':') {
  	fprintf(stderr, "%s: unknown option %c\n", argv[0], c);
  	return ('?');
      }
***************
*** 323,337
  
  #endif
  {
!     fprintf(stderr, "\
! Usage: %s -c[bfvw] device block filename..\n", myname);
!     fprintf(stderr, "\
!        %s -r[bvw] device block [filename...]\n", myname);
!     fprintf(stderr, "\
!        %s -t[vf] device\n", myname);
!     fprintf(stderr, "\
!        %s -u[bvw] device block [filename...]\n", myname);
!     fprintf(stderr, "\
!        %s -x[flmovw] device [filename...]\n", myname);
      exit(1);
  }

--- 326,335 -----
  
  #endif
  {
!     fprintf(stderr, "Usage: %s -c[bfvw] device block filename..\n", myname);
!     fprintf(stderr, "       %s -r[bvw] device block [filename...]\n", myname);
!     fprintf(stderr, "       %s -t[vf] device\n", myname);
!     fprintf(stderr, "       %s -u[bvw] device block [filename...]\n", myname);
!     fprintf(stderr, "       %s -x[flmovw] device [filename...]\n", myname);
      exit(1);
  }
Index: ttyio.c
*** /tmp/,RCSt1a17168	Sun Feb 12 14:09:46 1989
--- ttyio.c	Sun Feb 12 14:02:39 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/ttyio.c,v $
   *
!  * $Revision: 1.1 $
   *
   * ttyio.c - Terminal/Console I/O functions for all archive interfaces
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/ttyio.c,v $
   *
!  * $Revision: 1.2 $
   *
   * ttyio.c - Terminal/Console I/O functions for all archive interfaces
   *
***************
*** 28,34
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	ttyio.c,v $
   * Revision 1.1  88/12/23  18:02:39  mark

--- 28,34 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	ttyio.c,v $
   * Revision 1.2  89/02/12  10:06:11  mark
***************
*** 31,36
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	ttyio.c,v $
   * Revision 1.1  88/12/23  18:02:39  mark
   * Initial revision
   * 

--- 31,39 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	ttyio.c,v $
+  * Revision 1.2  89/02/12  10:06:11  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:39  mark
   * Initial revision
   * 
***************
*** 37,43
   */
  
  #ifndef lint
! static char *ident = "$Id: ttyio.c,v 1.1 88/12/23 18:02:39 mark Rel $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 40,46 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: ttyio.c,v 1.2 89/02/12 10:06:11 mark Exp $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 158,164
          return(-1);
      }
      if (got < 0) {
! 	fatal(syserr());
      }
      answer[idx] = '\0';
      return(0);

--- 161,167 -----
          return(-1);
      }
      if (got < 0) {
! 	fatal(strerror());
      }
      answer[idx] = '\0';
      return(0);
***************
*** 244,252
  
      close_archive();
  
!     sprintf(msg, "\
! %s: Ready for volume %u\n\
! %s: Type \"go\" when ready to proceed (or \"quit\" to abort): \07",
  		   myname, arvolume + 1, myname);
      for (;;) {
  	ret = nextask(msg, answer, sizeof(answer));

--- 247,253 -----
  
      close_archive();
  
!     sprintf(msg, "
%s: Ready for volume %u\n%s: Type \"go\" when ready to proceed 
(or \"quit\" to abort): \07",
  		   myname, arvolume + 1, myname);
      for (;;) {
  	ret = nextask(msg, answer, sizeof(answer));
Index: warn.c
*** /tmp/,RCSt1a17173	Sun Feb 12 14:09:53 1989
--- warn.c	Sun Feb 12 14:02:41 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/warn.c,v $
   *
!  * $Revision: 1.1 $
   *
   * warn.c - miscellaneous user warning routines 
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/warn.c,v $
   *
!  * $Revision: 1.2 $
   *
   * warn.c - miscellaneous user warning routines 
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	warn.c,v $
   * Revision 1.1  88/12/23  18:02:40  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	warn.c,v $
   * Revision 1.2  89/02/12  10:06:15  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	warn.c,v $
   * Revision 1.1  88/12/23  18:02:40  mark
   * Initial revision
   * 

--- 30,38 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	warn.c,v $
+  * Revision 1.2  89/02/12  10:06:15  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:40  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: warn.c,v 1.1 88/12/23 18:02:40 mark Rel $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 39,45 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: warn.c,v 1.2 89/02/12 10:06:15 mark Exp $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 93,99
  }
  
  
! /* syserr - return pointer to appropriate system error message
   *
   * DESCRIPTION
   *

--- 96,102 -----
  }
  
  
! /* strerror - return pointer to appropriate system error message
   *
   * DESCRIPTION
   *
***************
*** 112,118
  
  #ifdef __STDC__
  
! char *syserr(void)
  
  #else
  

--- 115,121 -----
  
  #ifdef __STDC__
  
! char *strerror(void)
  
  #else
  
***************
*** 116,122
  
  #else
  
! char *syserr()
  
  #endif
  {

--- 119,125 -----
  
  #else
  
! char *strerror()
  
  #endif
  {
***************
*** 162,168
  {
      OFFSET          n;
  
!     if (n = (size / (1024 * 1024))) {
  	fprintf(stream, "%ldm+", n);
  	size -= n * 1024 * 1024;
      }

--- 165,171 -----
  {
      OFFSET          n;
  
!     if (n = (size / (1024L * 1024L))) {
  	fprintf(stream, "%ldm+", n);
  	size -= n * 1024L * 1024L;
      }
***************
*** 164,170
  
      if (n = (size / (1024 * 1024))) {
  	fprintf(stream, "%ldm+", n);
! 	size -= n * 1024 * 1024;
      }
      if (n = (size / 1024)) {
  	fprintf(stream, "%ldk+", n);

--- 167,173 -----
  
      if (n = (size / (1024L * 1024L))) {
  	fprintf(stream, "%ldm+", n);
! 	size -= n * 1024L * 1024L;
      }
      if (n = (size / 1024L)) {
  	fprintf(stream, "%ldk+", n);
***************
*** 166,172
  	fprintf(stream, "%ldm+", n);
  	size -= n * 1024 * 1024;
      }
!     if (n = (size / 1024)) {
  	fprintf(stream, "%ldk+", n);
  	size -= n * 1024;
      }

--- 169,175 -----
  	fprintf(stream, "%ldm+", n);
  	size -= n * 1024L * 1024L;
      }
!     if (n = (size / 1024L)) {
  	fprintf(stream, "%ldk+", n);
  	size -= n * 1024L;
      }
***************
*** 168,174
      }
      if (n = (size / 1024)) {
  	fprintf(stream, "%ldk+", n);
! 	size -= n * 1024;
      }
      fprintf(stream, "%ld", size);
  }

--- 171,177 -----
      }
      if (n = (size / 1024L)) {
  	fprintf(stream, "%ldk+", n);
! 	size -= n * 1024L;
      }
      fprintf(stream, "%ld", size);
  }
Index: wildmat.c
*** /tmp/,RCSt1a17178	Sun Feb 12 14:09:59 1989
--- wildmat.c	Sun Feb 12 14:02:42 1989
***************
*** 1,6
  /* $Source: /u/mark/src/pax/RCS/wildmat.c,v $
   *
!  * $Revision: 1.1 $
   *
   * wildmat.c - simple regular expression pattern matching routines 
   *

--- 1,6 -----
  /* $Source: /u/mark/src/pax/RCS/wildmat.c,v $
   *
!  * $Revision: 1.2 $
   *
   * wildmat.c - simple regular expression pattern matching routines 
   *
***************
*** 33,39
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	wildmat.c,v $
   * Revision 1.1  88/12/23  18:02:41  mark

--- 33,39 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	wildmat.c,v $
   * Revision 1.2  89/02/12  10:06:20  mark
***************
*** 36,41
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	wildmat.c,v $
   * Revision 1.1  88/12/23  18:02:41  mark
   * Initial revision
   * 

--- 36,44 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	wildmat.c,v $
+  * Revision 1.2  89/02/12  10:06:20  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:41  mark
   * Initial revision
   * 
***************
*** 42,48
   */
  
  #ifndef lint
! static char *ident = "$Id: wildmat.c,v 1.1 88/12/23 18:02:41 mark Rel $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 45,51 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: wildmat.c,v 1.2 89/02/12 10:06:20 mark Exp $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 97,103
  
  #endif
  {
!     while (!wildmat(source, pattern)) {
  	if (*++source == '\0') {
  	    return (0);
  	}

--- 100,106 -----
  
  #endif
  {
!     while (!wildmat(pattern, source)) {
  	if (*++source == '\0') {
  	    return (0);
  	}
***************
*** 118,125
   *
   * PARAMETERS 
   *
-  * 	char *source 	- The source string which is to be compared to the 
-  *			  regular expression pattern. 
   * 	char *pattern 	- The regular expression which we are supposed to 
   *			  match to. 
   *

--- 121,126 -----
   *
   * PARAMETERS 
   *
   * 	char *pattern 	- The regular expression which we are supposed to 
   *			  match to. 
   * 	char *source 	- The source string which is to be compared to the 
***************
*** 122,127
   *			  regular expression pattern. 
   * 	char *pattern 	- The regular expression which we are supposed to 
   *			  match to. 
   *
   * RETURNS 
   *

--- 123,130 -----
   *
   * 	char *pattern 	- The regular expression which we are supposed to 
   *			  match to. 
+  * 	char *source 	- The source string which is to be compared to the 
+  *			  regular expression pattern. 
   *
   * RETURNS 
   *
Index: Makefile
*** /tmp/,RCSt1a17183	Sun Feb 12 14:10:07 1989
--- Makefile	Sun Feb 12 14:01:55 1989
***************
*** 3,9
  #
  # Written by Mark H. Colburn (mark@@jhereg.mn.org)
  #
! # $Id: Makefile,v 1.1 88/12/23 18:02:42 mark Rel $
  #
  
  #

--- 3,9 -----
  #
  # Written by Mark H. Colburn (mark@@jhereg.mn.org)
  #
! # $Id: Makefile,v 1.2 89/02/12 10:08:59 mark Exp $
  #
  
  #
***************
*** 30,35
  CC = cc
  
  #
  # Set LFLAGS to whatever makes your linker happy
  #
  #LDFLAGS = -s

--- 30,40 -----
  CC = cc
  
  #
+ # Set LIBS to any additional libraries that you need linked in with pax.
+ #
+ LIBS=
+ 
+ #
  # Set LFLAGS to whatever makes your linker happy
  #
  #LDFLAGS = -s
***************
*** 36,41
  LDFLAGS = 
  
  #
  # Set LINTFLAGS to whatever makes your implementation of lint happy.  If
  # you don't undef __STDC__ and you have an ANSI C compiler, lint will choke 
  # on the function prototypes present in func.h

--- 41,52 -----
  LDFLAGS = 
  
  #
+ # Set COPY to the name of the command to use to copy pax to cpio and
+ # tar.  Usually it is 'ln'.
+ #
+ COPY=ln
+ 
+ #
  # Set LINTFLAGS to whatever makes your implementation of lint happy.  If
  # you don't undef __STDC__ and you have an ANSI C compiler, lint will choke 
  # on the function prototypes present in func.h.
***************
*** 38,44
  #
  # Set LINTFLAGS to whatever makes your implementation of lint happy.  If
  # you don't undef __STDC__ and you have an ANSI C compiler, lint will choke 
! # on the function prototypes present in func.h
  #
  LINTFLAGS = -U__STDC__ $(POSIX)
  

--- 49,55 -----
  #
  # Set LINTFLAGS to whatever makes your implementation of lint happy.  If
  # you don't undef __STDC__ and you have an ANSI C compiler, lint will choke 
! # on the function prototypes present in func.h.
  #
  LINTFLAGS = -U__STDC__ $(POSIX)
  
***************
*** 53,58
  #
  MAN5 = /usr/man/man5
  MAN1 = /usr/man/man1
  
  #
  # There are three different ways to get POSIX or BSD conformant directory 

--- 64,71 -----
  #
  MAN5 = /usr/man/man5
  MAN1 = /usr/man/man1
+ MAN5EXT = 5
+ MAN1EXT = 1
  
  #
  # There are three different ways to get POSIX or BSD conformant directory 
***************
*** 80,86
  # Nothing beyond this point should need to be changed.
  #
  
! MISC   = Makefile pax.1 tar.5 cpio.5 README PATCHLEVEL
  HEADERS= config.h func.h limits.h port.h pax.h 
  SOURCE= pax.c append.c buffer.c cpio.c create.c extract.c fileio.c\
  	link.c list.c mem.c namelist.c names.c pass.c pathname.c\

--- 93,100 -----
  # Nothing beyond this point should need to be changed.
  #
  
! SHELL = /bin/sh
! MISC  = Makefile pax.1 tar.5 cpio.5 README PATCHLEVEL
  HEADERS= config.h func.h limits.h port.h pax.h 
  SOURCE= pax.c append.c buffer.c cpio.c create.c extract.c fileio.c\
  	link.c list.c mem.c namelist.c names.c pass.c pathname.c\
***************
*** 95,101
  all: $(PROGS)
  
  install: $(PROGS)
! 	mv $(PROGS) $(BINDIR)
  	cp $(PMAN1) $(MAN1)
  #	cp $(PMAN5) $(MAN5)
  

--- 109,119 -----
  all: $(PROGS)
  
  install: $(PROGS)
! 	strip pax
! 	cp pax $(BINDIR)
! 	chmod 755 $(BINDIR)/pax
! 	ln $(BINDIR)/pax $(BINDIR)/tar
! 	ln $(BINDIR)/pax $(BINDIR)/cpio
  	cp $(PMAN1) $(MAN1)
  #	cp $(PMAN5) $(MAN5)
  
***************
*** 107,113
  	lint $(LINTFLAGS) $(SOURCE)
  
  pax : $(OBJECT)
! 	$(CC) $(CFLAGS) -o pax $(OBJECT) $(DIRENT) 
  
  tar: pax
  	rm -f tar

--- 125,131 -----
  	lint $(LINTFLAGS) $(SOURCE)
  
  pax : $(OBJECT)
! 	$(CC) $(CFLAGS) $(LDFLAGS) -o pax $(OBJECT) $(DIRENT) $(LIBS)
  
  tar: pax
  	rm -f tar
***************
*** 111,117
  
  tar: pax
  	rm -f tar
! 	ln pax tar
  
  cpio: pax
  	rm -f cpio

--- 129,135 -----
  
  tar: pax
  	rm -f tar
! 	$(COPY) pax tar
  
  cpio: pax
  	rm -f cpio
***************
*** 115,120
  
  cpio: pax
  	rm -f cpio
! 	ln pax cpio
  
  $(OBJECT): $(HEADERS)

--- 133,138 -----
  
  cpio: pax
  	rm -f cpio
! 	$(COPY) pax cpio
  
  $(OBJECT): $(HEADERS)
Index: README
*** /tmp/,RCSt1a17188	Sun Feb 12 14:10:13 1989
--- README	Sun Feb 12 14:01:56 1989
***************
*** 6,12
  
  Introduction
  
!     This is version 1.1 of Pax, a public domain archiving utility.  
      
      Pax is an archiving utility that reads and writes tar and cpio formats, 
      both the traditional ones and the extended formats specified in IEEE 

--- 6,12 -----
  
  Introduction
  
!     This is version 1.2 of Pax, an archiving utility.  
      
      Pax is an archiving utility that reads and writes tar and cpio formats, 
      both the traditional ones and the extended formats specified in IEEE 
***************
*** 16,25
      1003.2 as a compromise in the chronic controversy over which of tar or 
      cpio is best.
  
!     The USENIX Association provided some support for this implementation 
!     project.  As a result, the Pax utility is being distributed free of 
!     charge and may be redistributed by others in either source or binary 
!     form.  (See the liscensing section for restrictions)
  
      The source for Pax is being posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,

--- 16,25 -----
      1003.2 as a compromise in the chronic controversy over which of tar or 
      cpio is best.
  
!     The USENIX Association provided some support for the initial 
!     implementation of this product.  As a result, the Pax utility is being 
!     distributed free of charge and may be redistributed by others in either 
!     source or binary form.  (See the liscensing section for restrictions)
  
      The source for Pax has been posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,
***************
*** 21,27
      charge and may be redistributed by others in either source or binary 
      form.  (See the liscensing section for restrictions)
  
!     The source for Pax is being posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,
      moon.honeywell.com and from one of the Berkeley machines.  The source
      to Pax will be available via anonymous UUCP from jhereg.mn.org, the 

--- 21,27 -----
      distributed free of charge and may be redistributed by others in either 
      source or binary form.  (See the liscensing section for restrictions)
  
!     The source for Pax has been posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,
      moon.src.honeywell.com and from ucb-arpa.berkeley.edu.  The source
      to Pax is also available via anonymous UUCP from jhereg.mn.org, the 
***************
*** 23,30
  
      The source for Pax is being posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,
!     moon.honeywell.com and from one of the Berkeley machines.  The source
!     to Pax will be available via anonymous UUCP from jhereg.mn.org, the 
      author's home machine and possibly other sites.
  
      The source for Pax will continue to change as long as the definition of 

--- 23,30 -----
  
      The source for Pax has been posted to comp.sources.unix on USENET and 
      will also be available by anonymous FTP on the Internet from uunet.uu.net,
!     moon.src.honeywell.com and from ucb-arpa.berkeley.edu.  The source
!     to Pax is also available via anonymous UUCP from jhereg.mn.org, the 
      author's home machine and possibly other sites.
  
      The source for Pax will continue to change as long as the definition of 
***************
*** 56,62
      machines:
  
          Machine                 Operating System/Release
! 	-------------------------------------------------------
  	Altos 586		System III (2.3)
  	AT&T UNIX PC		System V.2 (Release 3.51)
  	Cray 2			UNICOS

--- 56,62 -----
      machines:
  
          Machine                 Operating System/Release
! 	---------------------------------------------------
  	Altos 586		System III (2.3)
  	AT&T UNIX PC		System V.2 (Release 3.51)
          Convergent S/320	CTIX/68k 6.1, UNIX SysV 3.1
***************
*** 59,64
  	-------------------------------------------------------
  	Altos 586		System III (2.3)
  	AT&T UNIX PC		System V.2 (Release 3.51)
  	Cray 2			UNICOS
  	HP 9000			HP/UX 6.0.1
  	Mac II 			A/UX 1.0

--- 59,65 -----
  	---------------------------------------------------
  	Altos 586		System III (2.3)
  	AT&T UNIX PC		System V.2 (Release 3.51)
+         Convergent S/320	CTIX/68k 6.1, UNIX SysV 3.1
  	Cray 2			UNICOS
  	Encore CC		02.00.r088
  	HP 9000			HP/UX 6.0.1
***************
*** 60,65
  	Altos 586		System III (2.3)
  	AT&T UNIX PC		System V.2 (Release 3.51)
  	Cray 2			UNICOS
  	HP 9000			HP/UX 6.0.1
  	Mac II 			A/UX 1.0
  	NCR Tower		System V.2

--- 61,67 -----
  	AT&T UNIX PC		System V.2 (Release 3.51)
          Convergent S/320	CTIX/68k 6.1, UNIX SysV 3.1
  	Cray 2			UNICOS
+ 	Encore CC		02.00.r088
  	HP 9000			HP/UX 6.0.1
          IBM PC/AT		Microport SV/AT V2.4
  	Mac II 			A/UX 1.0
***************
*** 61,66
  	AT&T UNIX PC		System V.2 (Release 3.51)
  	Cray 2			UNICOS
  	HP 9000			HP/UX 6.0.1
  	Mac II 			A/UX 1.0
  	NCR Tower		System V.2
  	Pyramid			AT&T and Berkeley universe

--- 63,69 -----
  	Cray 2			UNICOS
  	Encore CC		02.00.r088
  	HP 9000			HP/UX 6.0.1
+         IBM PC/AT		Microport SV/AT V2.4
  	Mac II 			A/UX 1.0
  	NCR Tower		System V.2
  	Pyramid			AT&T and Berkeley universe
***************
*** 67,72
  	Sequent Symetry		Dynix 3.0
  	SGI Iris 4D/60G		UNIX 3.0
  	SGI Iris 4D/70G		UNIX 3.0
  	Sun 2			SunOS 3.4
  	Sun 2			SunOS 3.5
  	Sun 3			SunOS 3.4

--- 70,77 -----
  	Sequent Symetry		Dynix 3.0
  	SGI Iris 4D/60G		UNIX 3.0
  	SGI Iris 4D/70G		UNIX 3.0
+ 	SCO Xenix 386 		2.3.2
+ 	SCO Unix 386 		3.2
  	Sun 2			SunOS 3.4
  	Sun 2			SunOS 3.5
  	Sun 3			SunOS 3.4
***************
*** 76,82
  	VAX 8750		BSD 4.3 (Mt. Xinu)
  	VAX 8650		BSD 4.3 (Mt. Xinu)
  	VAX 780			BSD 4.3 (Berkeley)
! 	-------------------------------------------------------
  
      In future releases, the source will be moving toward ANSI C and POSIX 
      compatibility.  This should allow for portability over any system 

--- 81,87 -----
  	VAX 8750		BSD 4.3 (Mt. Xinu)
  	VAX 8650		BSD 4.3 (Mt. Xinu)
  	VAX 780			BSD 4.3 (Berkeley)
! 	---------------------------------------------------
  
      In future releases, the source will be moving toward ANSI C and POSIX 
      compatibility.  This should allow for portability over any system 
***************
*** 110,116
  
      THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
      IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!     WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  Please report any bug or problems to:
  

--- 115,121 -----
  
      THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
      IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  
  Please report any bug or problems to:
  
***************
*** 115,121
  Please report any bug or problems to:
  
  Mark Colburn
! NAPS International
  117 Mackubin St., Suite 1
  St. Paul MN   55102
  (612) 224-9108

--- 120,126 -----
  Please report any bug or problems to:
  
  Mark Colburn
! Minnetech Consulting, Inc.
  117 Mackubin St., Suite 1
  St. Paul MN   55102
  mark@@jhereg.MN.ORG
***************
*** 118,122
  NAPS International
  117 Mackubin St., Suite 1
  St. Paul MN   55102
- (612) 224-9108
  mark@@jhereg.MN.ORG

--- 123,126 -----
  Minnetech Consulting, Inc.
  117 Mackubin St., Suite 1
  St. Paul MN   55102
  mark@@jhereg.MN.ORG
Index: PATCHLEVEL
*** /tmp/,RCSt1a17193	Sun Feb 12 14:10:19 1989
--- PATCHLEVEL	Sun Feb 12 14:01:55 1989
***************
*** 1,2
! Patchlevel 0
! $Id: PATCHLEVEL,v 1.1 88/12/23 18:02:43 mark Rel $

--- 1,2 -----
! Patchlevel 1
! $Id: PATCHLEVEL,v 1.2 89/02/12 10:09:03 mark Exp $



@
