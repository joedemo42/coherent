head     1.35;
access   ;
symbols  ;
locks    ;
comment  @ * @;


1.35
date     91.04.20.01.35.52;  author root;  state Exp;
branches ;
next	1.34;

1.34
date     91.04.19.09.41.40;  author root;  state Exp;
branches ;
next	1.33;

1.33
date     91.04.17.14.15.48;  author root;  state Exp;
branches ;
next	1.32;

1.32
date     91.04.17.04.07.21;  author root;  state Exp;
branches ;
next	1.31;

1.31
date     91.04.17.03.16.33;  author root;  state Exp;
branches ;
next	1.30;

1.30
date     91.04.17.02.17.43;  author root;  state Exp;
branches ;
next	1.29;

1.29
date     91.04.16.22.40.19;  author root;  state Exp;
branches ;
next	1.28;

1.28
date     91.04.16.20.48.47;  author root;  state Exp;
branches ;
next	1.27;

1.27
date     91.04.16.16.38.47;  author root;  state Exp;
branches ;
next	1.26;

1.26
date     91.04.16.16.13.10;  author root;  state Exp;
branches ;
next	1.25;

1.25
date     91.04.16.01.45.35;  author root;  state Exp;
branches ;
next	1.24;

1.24
date     91.04.12.17.19.25;  author root;  state Exp;
branches ;
next	1.23;

1.23
date     91.04.11.12.51.50;  author root;  state Exp;
branches ;
next	1.22;

1.22
date     91.04.10.16.55.59;  author root;  state Exp;
branches ;
next	1.21;

1.21
date     91.04.10.15.21.41;  author root;  state Exp;
branches ;
next	1.20;

1.20
date     91.04.09.14.23.49;  author root;  state Exp;
branches ;
next	;


desc
@Seagate ST01/ST02 hard disk SCSI device driver.
@


1.35
log
@ssinit() - improved error recovery.
@
text
@#define MAXSSERR 3
static int sserrct;
/*
 * This is a driver for Seagate ST01/ST02 scsi host adapters.
 *
 * To do:
 * 1.	fix ss_rw() error recovery
 * 2.	reduce number of ss_rw() write errors
 * 3.	figure out what to do about drive parameters (HDGETA)
 * 4.	bootable driver, without/with "at" device(s)
 * 5.	rewrite data_in/data_out transfer phases in assembler
 * 6.	investigate queueing - see if sorting requests will help
 * 7.	use different queues for different SCSI id's
 * 8.	look into kernel for mystery of lost EOI's on IRQ 5.
 *
 * $Log:	/usr/src/sys/i8086/drv/RCS/ss.c,v $
 * Revision 1.34	91/04/19  09:41:40	root
 * Better error recovery, but needs work.
 * 
 * Revision 1.33	91/04/17  14:15:48	root
 * Starting to fix retry mechanism on ss_rw().
 * 
 * Revision 1.32	91/04/17  04:07:21	root
 * Accesses file system but has frequent BFERR 5's.
 * 
 * Revision 1.31	91/04/17  03:16:33	root
 * Now fdisk command works but mkfs fails.
 * 
 * Revision 1.30	91/04/17  02:17:43	root
 * Trying to figure out disconnect after write.
 * 
 * Revision 1.29	91/04/16  22:40:19	root
 * Whole disk devices working - need to implement HDGETA.
 * 
 * Revision 1.28	91/04/16  20:48:47	root
 * Kernel fdisk works, fdisk command gets garbage.
 * 
 * Revision 1.27	91/04/16  16:38:47	root
 * Typos fixed.  Locks up CPU on first open
 * 
 * Revision 1.26	91/04/16  16:13:10	root
 * First clean compile with block routine.
 * 
 * Revision 1.25	91/04/16  01:45:35	root
 * lots of strategy code added - but not ready to compile
 * 
 * Revision 1.24	91/04/12  17:19:25	root
 * Some rearrangements - still working on block & related routines
 * 
 * Revision 1.23	91/04/11  12:51:50	root
 * ssopen compiles - not tested
 * 
 * Revision 1.22	91/04/10  16:55:59	root
 * Starting to get block operations working.
 * 
 * Revision 1.21	91/04/10  15:21:41	root
 * Move define's to ss.h and scsiwork.h.  Other cleanup
 * 
 * Revision 1.20	91/04/09  14:23:49	root
 * Reads boot sector 100 times using IRQ on reconnect
 */

/*
 * Includes.
 */
#include	<coherent.h>
#include	<sys/io.h>
#include	<sys/sched.h>
#include	<sys/uproc.h>
#include	<sys/proc.h>
#include	<sys/con.h>
#include	<sys/stat.h>
#include	<sys/devices.h>		/* SCSI_MAJOR */
#include	<errno.h>

#include 	<sys/fdisk.h>
#include	<sys/hdioctl.h>
#include	<sys/buf.h>
#include	<scsiwork.h>
#include	<ss.h>

/*
 * Definitions.
 *	Constants.
 *	Macros with argument lists.
 *	Typedefs.
 *	Enums.
 */
#define DEV_SCSI_ID(dev)	((dev >> 4) & 0x0007)
#define DEV_LUN(dev)		((dev >> 2) & 0x0003)
#define DEV_DRIVE(dev)		((dev >> 2) & 0x001F)
#define DEV_PARTN(dev)		(dev & 0x0003)
#define DEV_SPECIAL(dev)	(dev & 0x0080)

#define HOST_ID		0x80	/* Host adapter is SCSI ID #7 */
#define HIPRI_RETRIES	400	/* # of times to retry while hogging CPU */
#define LOPRI_RETRIES	5	/* # of retries with sleep between tries */
#define WHOLE_DRIVE	NPARTN
#define WATCHDOG_SECONDS  4

#define IN_BUF_SIZE	512	/* buffer size in "ss" structs */

#define DEBUG	1
#if DEBUG
int stats[100], statsptr;
#define PUSHI		{ if(statsptr<100)stats[statsptr++] = i; }
#define POPI		{ if(sserrct<=MAXSSERR)printf("%d:",statsptr);while(statsptr)\
				if(sserrct<=MAXSSERR)printf("%d ",stats[--statsptr]);if(sserrct<=MAXSSERR)printf("\n");}
#define SSTELL(foo)	if(sserrct<=MAXSSERR)printf(foo)
#define SSTATUS		{uchar status = ffbyte(ss_csr);if(sserrct<=MAXSSERR)printf("status=%x\n", status);}
#define SSDUMP(ssp, text) {int i;\
	if(sserrct<=MAXSSERR)printf("%s: msg_in=%x cmdstat=%x\n", text, ssp->msg_in,\
	ssp->cmdstat);if(ssp->cmdlen)for(i=0;i<ssp->cmdlen;i++)\
	if(sserrct<=MAXSSERR)printf(" %x", ssp->cmdbuf[i]);if(sserrct<=MAXSSERR)printf(" cmd_bytes_out=%d",\
	ssp->cmd_bytes_out);\
	if(ssp->data_bytes_in)for(i=0;i<ssp->data_bytes_in;i++)\
	if(sserrct<=MAXSSERR)printf(" %x", ffbyte(ssp->in_buf+i));if(sserrct<=MAXSSERR)printf(" data_bytes_in=%d\n",\
	ssp->data_bytes_in);}
#else
#define PUSHI
#define POPI
#define SSTELL(foo)
#define SSTATUS
#define SSDUMP(ssp, text)
#endif

typedef unsigned char	uchar;
typedef unsigned long	ulong;
typedef struct ss {
	ulong	capacity;
	ulong	blocklen;
	ulong	bno;
	int	msg_in;
	int	dr_watch;	/* number of seconds for pending timeout */
	uchar	cmdbuf[G1CMDLEN];
	int	cmdlen;
	int	cmd_bytes_out;
	int	cmdstat;
	faddr_t	in_buf;
	int	in_buf_len;
	int	data_bytes_in;
	faddr_t	out_buf;
	int	out_buf_len;
	int	data_bytes_out;
	BUF	*bp;		/* current I/O request node, or NULL */
	struct	fdisk_s parmp[NPARTN+1];
	unsigned int	ptab_read:1;  /* 1 if partition table has been read */
	unsigned int	id_busy:1;  /* 1 if device with this SCSI id busy */
}	ss_type;

/*
 * Functions.
 *	Import Functions.
 *	Export Functions.
 *	Local Functions.
 */
extern int	nulldev();
extern int	nonedev();
extern unsigned char ffbyte();

static void	ssopen();		/* CON functions */
static void	ssclose();
static void	ssblock();
static void	ssread();
static void	sswrite();
static int	ssioctl();
static void	sswatch();
static void	ssload();
static void	ssunload();

static int	bus_dev_reset();	/* additional support functions */
static int	bus_info_xfer();
static int	bus_pre_xfer();
static int	chk_reconn();
static int	inquiry();
static int	mode_sense();
static int	read_cap();
static void	reconnect();
static int	req_sense();
static int	rezero();
static int	scsicmd();
static void	scsireset();
static void	ss_done();
static int	ss_rw();
static void	ss_start();
static void	ss_start_timing();
static void	ss_stop_timing();
static void	ssdelay();
static int	ssinit();
static void	ssintr();
static int	testready();

/*
 * Global Data.
 *	Import Variables.
 *	Export Variables.
 *	Local Variables.
 */
CON	sscon	= {
	DFBLK|DFCHR,			/* Flags */
	SCSI_MAJOR,			/* Major index */
	ssopen,				/* Open */
	ssclose,			/* Close */
	ssblock,			/* Block */
	ssread,				/* Read */
	sswrite,			/* Write */
	ssioctl,			/* Ioctl */
	nulldev,			/* Powerfail */
	sswatch,			/* Timeout */
	ssload,				/* Load */
	ssunload,			/* Unload */
	nulldev				/* Poll */
};

	/* Patch these Export Variables to configure the driver. */
int	NSDRIVE = 1;		/* Bitmap of attached SCSI drives. */
int	SS_INT = 5;		/* ST0[12] use either IRQ3 or IRQ5 */
int	SS_BASE = 0xDE00;	/* Segment addr of ST0x communication area */

static int	loading;	/* 1 ssload() is executing */
static BUF	dbuf;		/* For raw I/O */
static paddr_t	ss_base;	/* physical address of ST0x comm area */
static faddr_t	ss_fp;		/* (far *) to ST0x comm area */

static faddr_t	ss_ram;		/* (far *) to parameter RAM */
static faddr_t	ss_csr;		/* (far *) to control/status */
static faddr_t	ss_dat;		/* (far *) to data port */

static int	num_drives;	/* number of controller SCSI id's */
static ss_type *ss_tbl;		/* points to block of "ss" structs */
static int	st0x_busy;	/* 1 if SCSI host adapter busy */

static TIM	delay_tim;	/* needed for calls to ssdelay() */
static TIM	reset_tim;	/* needed for calls to scsireset() */
static TIM	timeout_tim;	/* needed for calls to timeout() */
static TIM	sst_tim;	/* for timeout() call from ss_start() */
static int	ss_expired;	/* 1 after local timeout */
static ss_type  *ss[MAX_SCSI_ID-1], rqs;

/*
 * ssload()	- load routine.
 *
 *	Action:	The controller is reset and the interrupt vector is grabbed.
 *		The drive characteristics are set up at this time.
 */
static void ssload()
{
	int erf = 0;  /* 1 if error occurs */
	int i;
	loading = 1;

	/*
	 * Claim IRQ vector.
	 */
	setivec(SS_INT, ssintr);

	/*
	 * Allocate a selector to map into ST0x memory-mapped comm area.
	 */
	ss_base = (paddr_t)((long)(unsigned)SS_BASE << 4);
	ss_fp = ptov(ss_base, (fsize_t)SS_SEL_LEN);

	ss_ram = ss_fp + SS_RAM;
	ss_csr = ss_fp + SS_CSR;
	ss_dat = ss_fp + SS_DAT;

	/*
	 * Primitive test of ST0x RAM.
	 */
	sfword(ss_ram, 0xA55A);
	sfword(ss_ram + 2, 0x3CC3);
	sfword(ss_ram + SS_RAM_LEN - 4, 0xA55A);
	sfword(ss_ram + SS_RAM_LEN - 2, 0x3CC3);
	if (ffword(ss_ram) != 0xA55A		/* fetch a "far" word */
	||  ffword(ss_ram + 2) != 0x3CC3
	||  ffword(ss_ram + SS_RAM_LEN - 4) != 0xA55A
	||  ffword(ss_ram + SS_RAM_LEN - 2) != 0x3CC3) {
		printf("Error - ST0x failed memory test\n");
		erf = 1;
	}

	/*
	 * Allocate drive structs.
	 *
	 * Do a single call to kalloc() then put allocated pieces into
	 * array ss.
	 */
	if (!erf) {
		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				num_drives++;
		if (num_drives == 0) {
			printf("Error - ss has no valid target id's\n");
			erf = 1;
		} else if ((ss_tbl = kalloc(num_drives*sizeof(ss_type)))
		== NULL) {
			printf("Error - ss can't allocate structs\n");
			erf = 1;
		} else
			kclear(ss_tbl, num_drives * sizeof(ss_type));
	}
	if (!erf) {
		ss_type *foo = ss_tbl;

		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				ss[i] = foo++;
	}

	/*
	 * Initialize drives we know about (i.e. in NSDRIVE bitmap).
	 */
	st0x_busy++;
	if (!erf) {
		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				ssinit(i);
	}
	st0x_busy--;
	loading = 0;
}

/*
 * ssunload()	- unload routine.
 */
static void ssunload()
{
	/*
	 * Deallocate driver heap space.
	 */
	if (ss_tbl)
		kfree(ss_tbl);

	/*
	 * Free the ST0x selector.
	 */
	vrelse(ss_fp);

	/*
	 * Release IRQ vector.
	 */
	clrivec(SS_INT);
}

/*
 * ssopen()
 *
 *	Input:	dev = disk device to be opened.
 *		mode = access mode [IPR,IPW, IPR+IPW].
 *
 *	Action:	Validate the minor device.
 *		Update the paritition table if necessary.
 */
static void ssopen(dev, mode)
register dev_t	dev;
{
	int drive, partn;
	int valid_open;
	struct	fdisk_s	*fdp;
	ss_type * ssp;
	int s_id;

	/*
	 * Set up local variables.
	 */
	valid_open = 1;
	drive = DEV_SCSI_ID(dev);
	partn = DEV_PARTN(dev);
	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	fdp = ssp->parmp;
devmsg(dev, "ssopen");
	/*
	 * LUN must be zero.
	 * SCSI id must have corresponding 1 in NSDRIVE bitmapped variable.
	 */
	if (DEV_LUN(dev) != 0 || ((1 << drive) & NSDRIVE) == 0) {
		u.u_error = ENXIO;
		valid_open = 0;
	}

	/*
	 * If "special" bit is set, partition field must be zero.
	 */
	if (valid_open && DEV_SPECIAL(dev) && partn != 0) {
		u.u_error = ENXIO;
		valid_open = 0;
	}

	/*
	 * Subscripting gimmick for partition table.
	 */
	if (valid_open && dev & SDEV)
		partn = WHOLE_DRIVE;
	/*
	 * If not accessing whole drive and the partition table has not
	 * been read yet, try to read it now.
	 * Do this by calling fdisk() with partition table device on the drive
	 * that is being accessed.
	 */
	if (valid_open && partn != WHOLE_DRIVE && !(ssp->ptab_read)) {
		int fdisk_dev;

		fdisk_dev = (dev | SDEV) & 0xfff0;
devmsg(fdisk_dev, "calling fdisk");
		if (fdisk(fdisk_dev, fdp)) {
int p;
			fdp[WHOLE_DRIVE].p_size = ssp->capacity;
			fdp[WHOLE_DRIVE].p_base = 0;
printf("fdisk() succeeded\n");
for (p=0; p<=WHOLE_DRIVE; p++)
	printf("p=%d base=%ld size=%ld\n", p, fdp[p].p_base, fdp[p].p_size);
			ssp->ptab_read = 1;
		} else {
printf("fdisk() failed\n");
			u.u_error = ENXIO;
			valid_open = 0;
		}
	}

	/*
	 * Ensure partition lies within drive boundaries and is non-zero size.
	 */
	if (valid_open && partn != WHOLE_DRIVE
	&& (fdp[partn].p_base+fdp[partn].p_size) > fdp[WHOLE_DRIVE].p_size) {
		u.u_error = EBADFMT;
		valid_open = 0;
	}

	if (valid_open && partn != WHOLE_DRIVE && fdp[partn].p_size == 0) {
		u.u_error = ENODEV;
		valid_open = 0;
	}

	/*
	 * OK to open the device.
	 * Start watchdog timer (if not already started) for the host adapter.
	 */
	if (valid_open) {
		++drvl[SCSI_MAJOR].d_time;
	}
}

/*
 * ssclose()
 */
static void ssclose(dev)
dev_t dev;
{
	/*
	 * Decrement the number of watchdog timer requests open for host board.
	 */
	--drvl[SCSI_MAJOR].d_time;	
devmsg(dev, "ssclose");
}

/*
 * ssread()	- read a block from the raw disk
 *
 *	Input:	dev = disk device to be written to.
 *		iop = pointer to source I/O structure.
 *
 *	Action:	Invoke the common raw I/O processing code.
 */
static void ssread(dev, iop)
dev_t	dev;
IO	*iop;
{
	ioreq( &dbuf, iop, dev, BREAD, BFRAW|BFBLK|BFIOC );
}

/*
 * sswrite()	- write a block to the raw disk
 *
 *	Input:	dev = disk device to be written to.
 *		iop = pointer to source I/O structure.
 *
 *	Action:	Invoke the common raw I/O processing code.
 */
static void sswrite(dev, iop)
dev_t	dev;
IO	*iop;
{
	ioreq( &dbuf, iop, dev, BWRITE, BFRAW|BFBLK|BFIOC );
}

/*
 * ssioctl()
 *
 *	Input:	dev = disk device to be operated on.
 *		cmd = input/output request to be performed.
 *		vec = (pointer to) optional argument.
 *
 *	Action:	Validate the minor device.
 *		Update the paritition table if necessary.
 */
#define NHEAD	4
#define NSEC	52
#define NCYL	1004

static int ssioctl(dev, cmd, vec)
register dev_t	dev;
int cmd;
char * vec;
{
	int ret = 0;
	hdparm_t hdparm;
	struct	fdisk_s	*fdp;
	int s_id;
	ss_type * ssp;

	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	fdp = ssp->parmp;

	switch(cmd) {
	case HDGETA:
printf("HDGETA ");
		fdp = ssp->parmp;
		*(short *)&hdparm.landc[0] =
		*(short *)&hdparm.ncyl[0] = NCYL;
		hdparm.nhead = NHEAD;
		hdparm.nspt = NSEC;
printf("ncyl=%d nhead=%d nspt=%d\n",
  hdparm.ncyl[0]+((int)hdparm.ncyl[1]<<8), (int)hdparm.nhead, (int)hdparm.nspt);
		kucopy( &hdparm, vec, sizeof hdparm );
		ret = 0;
		break;
	default:
		u.u_error = EINVAL;
		ret = -1;
	}

	return ret;
}

/*
 * ssblock()	- queue a block to the disk
 *
 *	Input:	bp = pointer to block to be queued.
 *
 *	Action:	Queue a block to the disk.
 *		Make sure that the transfer is within the disk partition.
 */
static void ssblock(bp)
register BUF	*bp;
{
	register int s;
	struct	fdisk_s	*fdp;
	int partition, drive, s_id;
	dev_t dev;
	ss_type * ssp;
	int valid_op = 1;

	bp->b_resid = bp->b_count;

	/*
	 * Set up local variables.
	 */
	dev = bp->b_dev;
	partition = DEV_PARTN(dev);
	drive = DEV_DRIVE(dev);
	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	if (dev & SDEV)
		partition = WHOLE_DRIVE;
	fdp = ssp->parmp;

	/*
	 * Range check disk region.
	 */
	if (!(ssp->ptab_read)) {
		if ( partition == WHOLE_DRIVE ) {
			if ((bp->b_bno != 0) || (bp->b_count != BSIZE)) {
{if(sserrct<=MAXSSERR)printf("BF1 ");}
				bp->b_flag |= BFERR;
				valid_op = 0;
			}
		} else {
{if(sserrct<=MAXSSERR)printf("BF2 ");}
			devmsg(dev, "no partition table");
			bp->b_flag |= BFERR;
			valid_op = 0;
		}
	}
	/*
	 * Check for read at end of partition.
	 * (Need to return with b_resid = BSIZE to signal end of volume.)
	 */
	else if ((bp->b_req == BREAD) && (bp->b_bno == fdp[partition].p_size)) {
		valid_op = 0;
	}
	/*
	 * Check for read past end of partition.
	 */
	else if ( (bp->b_bno + (bp->b_count/BSIZE))
	> fdp[partition].p_size ) {
{if(sserrct<=MAXSSERR)printf("BF3 ");}
		bp->b_flag |= BFERR;
		valid_op = 0;
	}

	/*
	 * Operation appears valid.
	 * Fill fields in the node and queue the request.
	 */
	if (valid_op) {

/* if(sserrct<=MAXSSERR)printf("ssblock: drv=%x bno=%lx bp=%x flag=%x\n",
	drive, bp->b_bno, bp, bp->b_flag); */

		ssq_wr_tail(bp);
		ss_start();
	/*
	 * Operation cannot be done.  Release the kernel buffer structure.
	 * Value of "bp->b_flag" tells caller if error occurred.
	 */
	} else { 	/* "valid_op" is FALSE */
		bdone(bp);
	}
}

/*
 * ssintr()	- Interrupt routine.
 *
 * If we have been reselected by a recognized target device
 *	let kernel get out of interrupt mode (defer) and do SCSI
 *	reconnect stuff.
 */
static void ssintr()
{
	int s_id;

	s_id = chk_reconn();
	if (s_id != -1)
		reconnect(s_id);
/*		defer(reconnect, s_id); */
}

/*
 * sswatch()
 *
 * Invoked once per second if any devices going through this driver are open.
 * Poll for any reselect, in case interrupt got lost.
 */
static void sswatch()
{
	int s_id, rs_id;
	ss_type * ssp;

	for (s_id = 0; s_id < MAX_SCSI_ID-1; s_id++) {
		ssp = ss[s_id];
		if (ssp && ssp->dr_watch) {
			ssp->dr_watch--;
			if (ssp->dr_watch == 0) {
{if(sserrct<=MAXSSERR)printf("BF4 ");}
				bus_dev_reset(s_id);
				ssp->bp->b_flag |= BFERR;
{if(sserrct<=MAXSSERR)printf("SCSI id #%d: bno=%lu <Watchdog Timeout>\n", s_id, ss[s_id]->bp->b_bno);}
				ss_done(s_id);
			} else {
				while (1) {
					rs_id = chk_reconn();
					if (rs_id == -1)
						break;
					else
						reconnect(rs_id);
				} /* endwhile */
			}
		}
	} /* endfor */
}

/*
 * bus_wait()
 *
 * Wait for specified bit values to appear in Status Register.
 * This uses a tight loop and does not expect to be interrupted.
 *
 * Argument "flags" is a double-byte value;  the high byte is ANDed with
 * status register contents, and the result is tested for equality with
 * the low byte.
 *
 * Return 1 if values wanted appeared, 0 if timeout occurred.
 */
static int bus_wait(flags)
unsigned short flags;
{
	int found, i;
	unsigned char status;

	found = 0;
	for ( i = 0; i < HIPRI_RETRIES; i++) {
		status = ffbyte(ss_csr);
		if ((status & (flags >> 8)) == (flags & 0xff)) {
			found = 1;
			break;
		}
	}

	if (!found)
		{if(sserrct<=MAXSSERR)printf("TO:f=%x s=%x ", flags, status);}

	return found;
}

/*
 * ssinit()
 *
 * Attempt to initialize the (unique) drive with a given SCSI id.
 * Assume only one drive per SCSI id, having LUN = 0.
 * 
 * Return 1 if success, 0 if failure.
 */
static int ssinit(s_id)
int s_id;
{
	int try;
	int retval = 0;
	uchar query_buf[MODESENSELEN];
	ss_type * ssp = ss[s_id];
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));

/*FOO*/
bus_dev_reset(s_id);
	/*
	 * Try Test Unit Ready command.
	 * If it fails, reset SCSI bus and target device, and try again.
	 */
printf("T");
	for (try = 0; !retval && try < LOPRI_RETRIES; try++) {
		if (testready(s_id))
			retval = 1;
		else {
printf("X");
			if (ssp->cmdstat == CS_BUSY)
				ssdelay(50);
			else if (ssp->cmdstat == CS_CHECK)
				req_sense(s_id);
			else if (s_id == chk_reconn())
			{
printf("-r-");
				ssdelay(50);
			}
			else
				scsireset();
		}
#if 0
		scsireset();
		bus_dev_reset(s_id);
#endif
	} /* endfor */
	if (!retval)
		devmsg(dev, "Test Unit Ready Failed");

printf("R");
	if (retval)
		if (req_sense(s_id)) {
			retval = 1;
		} else
			devmsg(dev, "Request Sense Failed");

	if (retval)
		if (inquiry(s_id, query_buf)) {
			query_buf[INQUIRYLEN] = 0;
			devmsg(dev, query_buf + 8);
			if (query_buf[0] == 0) {
				retval = 1;
			} else
				devmsg(dev, "Not Direct Access Device");
		} else
			devmsg(dev, "Inquiry Failed");

	if (retval)
		if (read_cap(s_id, query_buf)) {
			retval = 1;
			ssp->capacity = query_buf[3] | (query_buf[2] << 8)
			| (((long)(query_buf[1])) << 16)
			| (((long)(query_buf[0])) << 24);
			ssp->blocklen = query_buf[7] | (query_buf[6] << 8)
			| (((long)(query_buf[5])) << 16)
			| (((long)(query_buf[4])) << 24);
printf("capacity=%ld   block length=%ld\n", ssp->capacity, ssp->blocklen);
		} else
			devmsg(dev, "Read Capacity Failed");

	if (retval)
		if (mode_sense(s_id, query_buf)) {
#define FMT_PG	(4+8+8+12)
#define DDG_PG	(4+8+8+12+24)
			uchar heads;
			unsigned short spt;
			ulong cyls;
spt=((int)query_buf[FMT_PG+10]<<8) + query_buf[FMT_PG+11];
cyls=((int)query_buf[DDG_PG+2]<<16) + ((int)query_buf[DDG_PG+3]<<8) + query_buf[DDG_PG+4];
heads=query_buf[DDG_PG+5];
printf("%d sectors per track\n", spt);
printf("%ld cylinders\n", cyls);
printf("%d heads\n", heads);
		} else
			devmsg(dev, "Mode Sense Failed");

ssp->id_busy=0;
	return retval;
}

/*
 * testready()
 *
 * Send Test Unit Ready command.
 * Retry after bus reset if necessary.
 *
 * Return 1 if unit is ready, 0 if not.
 */
static int testready(s_id)
int s_id;
{
	int retval;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[0] = ScmdTESTREADY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] =
		ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	retval = scsicmd(s_id);

	return retval;
}

/*
 * scsicmd()
 *
 * Send command packet to target device.
 * Start a new SCSI bus cycle when this routine is called.
 * If command status after sending is Device Check (CS_CHECK), do a
 * Request Sense to find out what happened and clear check status.
 *
 * Return 1 if command was send and status was good, else 0.
 */
static int scsicmd(s_id)
int s_id;
{
	int retval;
	ss_type *ssp = ss[s_id];

	if (retval = bus_pre_xfer(s_id)) {
		bus_info_xfer(ssp);
		retval = (ssp->cmdlen == ssp->cmd_bytes_out
			&& ssp->cmdstat == CS_GOOD);
	}

	if (ssp->cmdstat == CS_CHECK) {
		if (req_sense(s_id))
			retval = (ssp->cmdlen == ssp->cmd_bytes_out);
	}

	return retval;
}

/*
 * scsireset()
 *
 * Reset the SCSI bus.
 *
 * Allow settling time when turning reset on/off.
 * Settling times were determined empirically.
 * Each tick is 10 msec.
 *
 * If called while ssload() is running, don't return until reset is complete.
 * If called after ssload(), start up state machine and return.
 *
 * Either way, mark host adapter busy until reset completes.
 */
#define RESET_TICKS	40
static void scsireset()
{
	static int reset_state;

printf("!");
	/*
	 * During load, it's ok to do sleep() calls for reset settling.
	 * After load is finished, use timeout() to accomplish this.
	 */
	if (loading) {
		st0x_busy++;
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET);
		ssdelay(RESET_TICKS);
		sfbyte(ss_csr, 0);
		ssdelay(RESET_TICKS);
		st0x_busy--;
	} else {
		switch(reset_state) {
		case 0:
			st0x_busy++;
			sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET);
			timeout(&reset_tim, RESET_TICKS, scsireset, 0);
			reset_state = 1;
			break;
		case 1:
			sfbyte(ss_csr, 0);
			timeout(&reset_tim, RESET_TICKS, scsireset, 0);
			reset_state = 2;
			break;
		case 2:
			st0x_busy--;
			reset_state = 0;
			break;
		}
	}
}

/*
 * ssdelay()
 *
 * Delay for some number of clock ticks.
 * 286/386 kernel ticks are at 100Hz
 */
static void ssdelay(ticks)
int ticks;
{
	timeout(&delay_tim, ticks, wakeup, (int)&delay_tim);
	sleep((char *)&delay_tim, CVPAUSE, IVPAUSE, SVPAUSE);
}

/*
 * ss_start_timing()
 *
 * Start a timeout for some number of ticks.
 * Caller knows timer has expired when "ss_expired" goes to 1.
 *
 * Sample invocation:
 *	ss_start_timing(n);
 *	while (check for desired event fails) {
 *		if (ss_expired) {
 *			...failure stuff..
 *			break;
 *		}
 *		ssdelay(m); <= needed to allow kernel to update timers
 *	}
 */
static void ss_start_timing(ticks)
int ticks;
{
	ss_expired = 0;
	timeout(&timeout_tim, ticks, ss_stop_timing, 1);
}

/*
 * ss_stop_timing()
 *
 * Stub function called only by ss_start_timing()
 */
static void ss_stop_timing(flagval)
int flagval;
{
	ss_expired = flagval;
}

/*
 * bus_pre_xfer()
 *
 * Do bus cycle phases prior to the information transfer phases.
 * This includes arbitration and selection.
 */
static int bus_pre_xfer(s_id)
int s_id;
{
	int tries;
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));
	int ret = 0;

	for (tries = 0; !ret && tries < LOPRI_RETRIES; tries++) {
if (tries>0)break;
		/*
		 * Do ST0x arbitration.
		 */
		sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
		sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
		sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */

		/*
		 * SCSI spec says there is "no maximum" to the wait for arbitration
		 * complete.
		 */
		if (!bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL)) {
			if (ffbyte(ss_csr) & (RS_REQUEST|RS_BUSY))
				ret = 1;
			continue;
		}

		/*
		 * Arbitration complete.  Now select, with ATN to allow messages.
		 */
		sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);

		if (!bus_wait(RS_BUSY << 8 | RS_BUSY))
			continue;

		/*
		 * Send "Identify" Message with Disconnect allowed.
		 */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);

		if (!bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
			continue;

		/*
		 * During ssload(), diagnostics are running and we don't
		 * want disconnects.  At other times, disconnect is ok.
		 */
		if (loading)
			sfbyte(ss_dat, MSG_IDENTIFY);
		else
			sfbyte(ss_dat, MSG_IDENT_DC);
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ENABLE_IRPT);
		ret = 1;
	}

	return ret;
}

/*
 * bus_info_xfer()
 *
 * Do bus cycle information transfer phases.
 * This includes message in/out, command in/out, and data in/out.
 *
 * If cmdlen is nonzero, cmdbuf is an array of bytes of that length,
 * to be sent to the target.
 *
 * Return 1 if bus timeout did not occur, else 0.
 *
 * pseudocode:
 *
 * while (wait for REQ true or BUSY false on SCSI bus)
 *   if (BUSY false)
 *     break from while loop
 *   else
 *     switch (xfer phase = RS_CTRL_DATA|RS_I_O|RS_MESSAGE)
 *       case XP_MSG_IN/XP_MSG_OUT/...
 *         handle the indicated information transfer phase
 *     endswitch
 *   endif
 * endwhile
 */
static int bus_info_xfer(ssp)
ss_type *ssp;
{
	int bus_timeout;
	uchar phase_type;
	uchar msg_in;
	int no_msg_rcvd = 1;
	int s;
	int bytes_to_send;
int we_wrote=0;

	ssp->cmd_bytes_out = 0;
	ssp->msg_in = -1;
	s = sphi();
	while(req_wait(&bus_timeout)) {
		phase_type = ffbyte(ss_csr) & (RS_MESSAGE|RS_I_O|RS_CTRL_DATA);
		switch (phase_type) {
		case XP_MSG_IN:
			msg_in = ffbyte(ss_dat);
			switch(msg_in){
			case MSG_CMD_CMPLT:
				ssp->msg_in = msg_in;
				sfbyte(ss_csr, WC_ENABLE_IRPT);
				break;
			case MSG_SAVE_DPTR:
				break;
			case MSG_RSTOR_DPTR:
				break;
			case MSG_DISCONNECT:
				ssp->msg_in = msg_in;
				sfbyte(ss_csr, WC_ENABLE_IRPT);
				break;
			case MSG_ABORT:
				break;
			case MSG_DEV_RESET:
				break;
			case MSG_IDENTIFY:
				break;
			case MSG_IDENT_DC:
				break;
			}
			break;
		case XP_MSG_OUT:
			/*
			 * This case shouldn't happen.  We weren't
			 * asserting ATTENTION.  Abort the bus cycle.
			 */
			sfbyte(ss_csr, WC_ENABLE_SCSI);
			sfbyte(ss_dat, MSG_ABORT); 
			break;
		case XP_STAT_IN:
			ssp->cmdstat = ffbyte(ss_dat);
			break;
		case XP_CMD_OUT:
			/*
			 * Ship out command bytes.
			 * Reset SCSI bus if too many command bytes are wanted.
			 */
			bytes_to_send = ssp->cmdlen - ssp->cmd_bytes_out;
			if(bytes_to_send > 0) {
				sfbyte(ss_dat, ssp->cmdbuf[ssp->cmd_bytes_out++]);
				/*
				 * If just sent last byte, allow interrupts.
				 */
				if (bytes_to_send == 1) {
					spl(s);
					s = sphi();
				}
			} else {	/* This case should not happen. */
SSDUMP(ssp, "Command overrun");
				scsireset();
			}
			break;
		case XP_DATA_IN:
			/*
			 * If caller's buffer has room, keep incoming
			 * data byte.  Else toss it.
			 */
			if (ssp->data_bytes_in < ssp->in_buf_len && ssp->in_buf) {
				uchar dat;

				dat = ffbyte(ss_dat);
				sfbyte(ssp->in_buf + ssp->data_bytes_in, dat);
				ssp->data_bytes_in++;
			} else
				ffbyte(ss_dat);
			break;
		case XP_DATA_OUT:
#if 0
if (!we_wrote) {
	we_wrote=1;
	{if(sserrct<=MAXSSERR)printf("W");}
}
#endif
			/*
			 * Copy output buffer bytes to data register.
			 */
			if (ssp->data_bytes_out < ssp->out_buf_len && ssp->out_buf) {
				uchar dat;

				dat = ffbyte(ssp->out_buf + ssp->data_bytes_out);
				sfbyte(ss_dat, dat);
				ssp->data_bytes_out++;
			} else { /* This case should not happen. */
SSDUMP(ssp, "Data out overrun");
				scsireset();
			}
			break;
		default:
			break;
		} /* endswitch */
	}
	spl(s);
switch(ssp->cmdstat) {
case -1:
	break;
case CS_GOOD:
	break;
case CS_CHECK:
	{if(sserrct<=MAXSSERR)printf("CSK",ssp->cmdstat);}
	break;
case CS_BUSY:
	{if(sserrct<=MAXSSERR)printf("CSY",ssp->cmdstat);}
	break;
case CS_RESERVED:
default:
	{if(sserrct<=MAXSSERR)printf("CS%x",ssp->cmdstat);}
}
	return (bus_timeout) ? 0 : 1 ;
}
/*
 * req_wait()
 *
 * This routine is called at the start of each information transfer
 * phase and after the last such phase.
 *
 * It returns 1 if REQ is asserted on the SCSI bus, meaning another phase
 * may begin, and 0 otherwise.  A REQ signal will not be seen if the function
 * times out or if BUSY drops.  A value of 1 is written to the pointer argument
 * if timeout occurred, else 0 is written.
 */
static int req_wait(to_ptr)
int *to_ptr;
{
	int req_found, i;
	unsigned char status;

	*to_ptr = 1;
	req_found = 0;
	for (i = 0; i < HIPRI_RETRIES; i++) {
		status = ffbyte(ss_csr);
		if (status & RS_REQUEST) {
			req_found = 1;
			*to_ptr = 0;
			break;
		} else if ((status & RS_BUSY) == 0) {
			*to_ptr = 0;
			break;
		}
	}

	if (*to_ptr)
		{if(sserrct<=MAXSSERR)printf("TX: s=%x ", status);}

	return req_found;
}

/*
 * req_sense()
 *
 * Request Sense for a device.  The main reason for doing this is to
 * clear a standing Command Status of Device Check.
 *
 * Full results are discarded.  Return 1 if Device returns No Sense or
 * or Unit Attention.  Else return 0.
 *
 */
static int req_sense(s_id)
int s_id;
{
	uchar sense_buf[SENSELEN];
	int ret = 0;

	rqs.cmdstat = -1;
	rqs.data_bytes_in = 0;
	rqs.data_bytes_out = 0;
	rqs.cmdbuf[0] = ScmdREQUESTSENSE;
	rqs.cmdbuf[1] = rqs.cmdbuf[2] = rqs.cmdbuf[3] =
		rqs.cmdbuf[5] = 0;
		rqs.cmdbuf[4] = SENSELEN;
	rqs.cmdlen = G0CMDLEN;
	rqs.in_buf_len = SENSELEN;
	rqs.out_buf_len = 0;
	FP_OFF(rqs.in_buf) = sense_buf;
	FP_SEL(rqs.in_buf) = sds;

	if (bus_pre_xfer(s_id)) {
		bus_info_xfer(&rqs);
		if (rqs.data_bytes_in == SENSELEN) {
			if (sense_buf[2] == 0x00)	/* No Sense.  AOK */
				ret = 1;
			else if (sense_buf[2] == 0x06 && sense_buf[12] == 0x29)
				ret = 1;
		}
	}

	return ret;
}

/*
 * inquiry()
 *
 * Inquiry command for a device.
 * Find out if device is direct access, removable, etc.
 *
 * Put result of inquiry into supplied buffer.
 * Return 1 if command succeeds, else 0.
 */
static int inquiry(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdINQUIRY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] =
		ssp->cmdbuf[5] = 0;
		ssp->cmdbuf[4] = INQUIRYLEN;
	ssp->cmdlen = G0CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = INQUIRYLEN;
	ssp->out_buf_len = 0;

	ret = scsicmd(s_id);
	ssp->id_busy = 0;

	return ret;
}

/*
 * mode_sense()
 *
 * Mode Sense command for a device.
 * Use this to get disk parameters:
 *	number of cylinders
 *	number of heads
 *	number of sectors per track.
 *
 * Put result of mode sense into supplied buffer.
 * Return 1 if command succeeds, else 0.
 */
static int mode_sense(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdMODESENSE;
	ssp->cmdbuf[1] = 0;
	ssp->cmdbuf[2] = 0x3F;
	ssp->cmdbuf[3] = 0;
	ssp->cmdbuf[4] = MODESENSELEN;
	ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = MODESENSELEN;
	ssp->out_buf_len = 0;

	ret = scsicmd(s_id);
	ssp->id_busy = 0;

	return ret;
}

/*
 * read_cap()
 *
 * Read Capacity command for a device.
 *
 * Return 1 if command succeeds, else 0.
 */
static int read_cap(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdREADCAPACITY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] = 0;
	ssp->cmdbuf[5] = ssp->cmdbuf[6] = ssp->cmdbuf[7] = ssp->cmdbuf[8] = 0;
	ssp->cmdbuf[9] = 0;
	ssp->cmdlen = G1CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = 8;
	ssp->out_buf_len = 0;

	ret = scsicmd(s_id);
	ssp->id_busy = 0;

	return ret;
}

/*
 * ss_start()
 *
 * Invoked whenever there might be I/O to do.
 *
 * Disallow re-entrancy in this routine (variable "locked").
 * If there is a next I/O request queued (peek at head of queue)
 *   get the target SCSI ID.
 *   If target is not busy
 *     remove request from queue
 *     mark target device busy
 *     start watchdog timer
 *     send command to host adapter
 *     if command succeeded
 *       cleanup after command
 *       adjust b_resid field
 *     else if command failed
 *       set error flag
 *       cleanup after command
 *     else (disconnected)
 *       do nothing
 */
static void ss_start()
{
#define RW_TRIES	5
	int s;
	BUF * bp;
	static char locked;
	int s_id;
	ss_type * ssp;
	struct	fdisk_s	*fdp;
	int partition;
	dev_t dev;
	static int retry[MAX_SCSI_ID-1];

	s = sphi();
	if(locked) {
		spl(s);
		return;
	}
	++locked;
	spl(s);

	if (st0x_busy) {
		timeout(&sst_tim, 50, ss_start, 0);
		return;
	}

	if((bp = ssq_rd_head()) != NULL) {
		s_id = DEV_SCSI_ID(bp->b_dev);
		ssp = ss[s_id];
		dev = bp->b_dev;
		partition = DEV_PARTN(dev);
		if (dev & SDEV)
			partition = WHOLE_DRIVE;
		fdp = ssp->parmp;
		if (!(ssp->id_busy)) {
			if (partition != WHOLE_DRIVE)
				ssp->bno = fdp[partition].p_base + bp->b_bno;
			else
				ssp->bno = bp->b_bno;
			ssp->bp = bp;
			ssp->id_busy = 1;
			ssp->dr_watch = WATCHDOG_SECONDS;
			if (ss_rw(s_id)) {
				retry[s_id] = 0;
				ssq_rm_head();
				if (bp->b_req == BREAD)
					bp->b_resid -= ssp->data_bytes_in;
				else
					bp->b_resid -= ssp->data_bytes_out;
				if (ssp->msg_in != MSG_DISCONNECT)
					ss_done(s_id);
/* if(sserrct<=MAXSSERR)printf("%d in  %d out\n",ssp->data_bytes_in,ssp->data_bytes_out); */
			} else {
				if (++retry[s_id] > RW_TRIES) {
{if(sserrct<=MAXSSERR)printf("BF5 ");}
					retry[s_id] = 0;
					ssq_rm_head();
					bp->b_flag |= BFERR;
					ss_done(s_id);
				} else {
					ssp->id_busy = 0;
					timeout(&sst_tim, 10, ss_start, 0);
{if(sserrct<=MAXSSERR)printf("R%d ",retry[s_id]);}
				}
			}
		}
	}
	--locked;
}

/*
 * ss_done
 *
 * Release current i/o buffer to the O/S.
 */
static void ss_done(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int s;

	s = sphi();
	ssp->id_busy = 0;
	ssp->dr_watch = 0;
	ssp->in_buf = ssp->out_buf = NULL;
	if (bp) {
		bdone(bp);
		ssp->bp = NULL;
	}
	spl(s);

	ss_start();
}

/*
 * bus_dev_reset()
 *
 * Send Bus Device Reset message to the given SCSI id.
 * Return 1 if host adapter was not busy and no obvious timeouts occurred,
 * else 0.
 */
static int bus_dev_reset(s_id)
{
	int bdr_ok = 1;
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));

{if(sserrct<=MAXSSERR)printf("bdr");}

	if (!loading && st0x_busy)
		bdr_ok = 0;

	if (bdr_ok) {
		/*
		 * Do ST0x arbitration.
		 */
		sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
		sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
		sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */

		/*
		 * SCSI spec says there is "no maximum" to the wait for
		 * arbitration complete.
		 */
		if (!bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL)) {
			bdr_ok = 0;
		}
	}

	/*
	 * Arbitration complete.  Now select, with ATN to allow messages.
	 */
	if (bdr_ok) {
		sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);

		if (!bus_wait(RS_BUSY << 8 | RS_BUSY))
			bdr_ok = 0;
	}

	if (bdr_ok) {
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);

		if (!bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
			bdr_ok = 0;
	}

	if (bdr_ok) {
		sfbyte(ss_csr, WC_ENABLE_SCSI);
		sfbyte(ss_dat, MSG_DEV_RESET);
		if (!bus_wait((0xFF << 8) | 0))
			bdr_ok = 0;
	}

{if(sserrct<=MAXSSERR)printf("%d",bdr_ok);}
	return bdr_ok;
}

/*
 * chk_reconn()
 *
 * Check SELECT to see if any SCSI device has tried to reconnect to the host
 * adapter.  Called if there is an interrupt, and by the timer in case
 * we somehow lose an interrupt.
 *
 * Return -1 if no reselect detected, or the SCSI ID of the reselecting
 * target if there is one.
 *
 * Call reconnect() after this if reselect has occurred.
 */
static int chk_reconn()
{
	uchar csr, dat;
	int s_id = -1;

	csr = ffbyte(ss_csr);
	if (csr & (RS_SELECT | RS_I_O)) {
		dat = ffbyte(ss_dat);
		if ((dat & HOST_ID) && (dat & NSDRIVE)) {
			dat &= ~HOST_ID;
			s_id = 0;
			while (dat >>=1)
				s_id++;
		}
	}

	return s_id;
}

/*
 * reconnect()
 *
 * Given SCSI ID of target device that is issuing reselect, do reconnect
 * SCSI bus stuff.
 */
static void reconnect(s_id)
int s_id;
{
	uchar dat;
	int cmd_ok = 0;
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;

	dat = ffbyte(ss_dat);
	if ((dat & HOST_ID) && (dat & (1 << s_id)) && ssp) {
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_BUSY);
		if (bus_wait(RS_SELECT << 8 | 0)) {
			sfbyte(ss_csr, WC_ENABLE_SCSI);
			cmd_ok = bus_info_xfer(ssp);
			if (bp) {
				if (bp->b_req == BREAD)
					bp->b_resid -= ssp->data_bytes_in;
				else
					bp->b_resid -= ssp->data_bytes_out;
				if (cmd_ok && ssp->cmdstat == CS_GOOD) {
					if (ssp->msg_in == MSG_DISCONNECT) {
						ssp->dr_watch = WATCHDOG_SECONDS;
					} else
						ss_done(s_id);
				} else {
{if(sserrct<=MAXSSERR)printf("BF6 ");}
					bp->b_flag |= BFERR;
					ss_done(s_id);
				}
			}
		}
	}
}

/*
 * ss_rw()
 *
 * Send read or write command to the host adapter.
 */
static int ss_rw(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int rw_ok = 0;
uchar rwc;

	ssp->cmdstat = -1;
	if (bp->b_req == BREAD) {
		ssp->cmdbuf[0] = ScmdREADEXTENDED;
		ssp->in_buf_len = bp->b_count;
		ssp->in_buf = bp->b_faddr;
		ssp->out_buf_len = 0;
		ssp->out_buf = NULL;
rwc='R';
	} else {
		ssp->cmdbuf[0] = ScmdWRITEXTENDED;
		ssp->in_buf_len = 0;
		ssp->in_buf = NULL;
		ssp->out_buf_len = bp->b_count;
		ssp->out_buf = bp->b_faddr;
rwc='W';
	}
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[1] = 0;
	ssp->cmdbuf[2] = ssp->bno >> 24;
	ssp->cmdbuf[3] = ssp->bno >> 16;
	ssp->cmdbuf[4] = ssp->bno >>  8;
	ssp->cmdbuf[5] = ssp->bno;
	ssp->cmdbuf[6] = 0;
	ssp->cmdbuf[7] = bp->b_count / (BSIZE * 256L);
	ssp->cmdbuf[8] = bp->b_count / BSIZE;
	ssp->cmdbuf[9] = 0;
	ssp->cmdlen = G1CMDLEN;

{ int s = sphi();
	rw_ok = bus_pre_xfer(s_id);
	if (rw_ok) {
		bus_info_xfer(ssp);
spl(s);
		rw_ok = (ssp->cmdlen == ssp->cmd_bytes_out);
if(!rw_ok) {
  uchar csr=ffbyte(ss_csr), dat=ffbyte(ss_dat);
  sserrct++; if (sserrct <=MAXSSERR) {
    {if(sserrct<=MAXSSERR)printf("F2 cmdlen=%d cmd_bytes_out=%d cmdstat=%d\n", ssp->cmdlen,
  	ssp->cmd_bytes_out, ssp->cmdstat);}
    {if(sserrct<=MAXSSERR)printf("%c msg_in=%x inl=%d ", rwc, ssp->msg_in, ssp->in_buf_len);}
    {if(sserrct<=MAXSSERR)printf("inb=%d otl=%d otb=%d\n", ssp->data_bytes_in, ssp->out_buf_len,
    ssp->data_bytes_out);}
    {if(sserrct<=MAXSSERR)printf("csr=%x dat=%x bno=%ld ",csr,dat,bp->b_bno);}
  }
}
	}
else {{if(sserrct<=MAXSSERR)printf("F1");}spl(s);}
}

	if (ssp->cmdstat == CS_CHECK) {
{if(sserrct<=MAXSSERR)printf("ss_rw(): requesting sense\n");}
		if (req_sense(s_id)) {
			rw_ok = (ssp->cmdlen == ssp->cmd_bytes_out);
if(!rw_ok) {if(sserrct<=MAXSSERR)printf("F3");}
		}
	}

	if (rw_ok) {
		rw_ok =
		(ssp->cmdstat == CS_GOOD || ssp->msg_in == MSG_DISCONNECT);
if(!rw_ok) {if(sserrct<=MAXSSERR)printf("F4");}
	}

	return rw_ok;

}

/*
 * rezero()
 *
 * Send Rezero Unit command.
 *
 * Return 1 if no timeouts occurred, 0 if not.
 */
static int rezero(s_id)
int s_id;
{
	int retval;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[0] = ScmdREZERO;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] =
		ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	retval = scsicmd(s_id);

	return retval;
}
@


1.34
log
@Better error recovery, but needs work.
@
text
@d1 1
d17 3
d96 1
a96 1
#define HIPRI_RETRIES	800	/* # of times to retry while hogging CPU */
d107 4
a110 4
#define POPI		{ printf("%d:",statsptr);while(statsptr)\
				printf("%d ",stats[--statsptr]);printf("\n");}
#define SSTELL(foo)	printf(foo)
#define SSTATUS		{uchar status = ffbyte(ss_csr);printf("status=%x\n", status);}
d112 1
a112 1
	printf("%s: msg_in=%x cmdstat=%x\n", text, ssp->msg_in,\
d114 1
a114 1
	printf(" %x", ssp->cmdbuf[i]);printf(" cmd_bytes_out=%d",\
d117 1
a117 1
	printf(" %x", ffbyte(ssp->in_buf+i));printf(" data_bytes_in=%d\n",\
d180 1
d191 1
d220 1
a220 1
static int	allow_dc;	/* 1 if we allow SCSI targets to disconnect */
d234 1
d250 1
d313 1
d319 2
a320 1
	allow_dc = 1;
d518 1
a518 1
printf("HDGETA\n");
d575 1
a575 1
printf("BFERR 1\n");
d580 1
a580 1
printf("BFERR 2\n");
d598 1
a598 1
printf("BFERR 3\n");
d609 1
a609 1
/* printf("ssblock: drv=%x bno=%lx bp=%x flag=%x\n",
d636 2
a637 1
		defer(reconnect, s_id);
d656 1
a656 1
printf("BFERR 4\n");
d659 1
a659 1
printf("SCSI id #%d: bno=%lu <Watchdog Timeout>\n", s_id, ss[s_id]->bp->b_bno);
d702 1
a702 1
		printf("ST0x timeout;  flags=%x status=%x\n", flags, status);
d736 11
a746 2
			if (ssp->cmdstat != CS_BUSY)
				;
a747 1
		ssdelay(100);
a750 2
		if (testready(s_id))
			retval = 1;
d821 1
d867 1
d871 5
d880 33
a912 5
printf("scsireset\n");
	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET);
	ssdelay(RESET_TICKS);
	sfbyte(ss_csr, 0);
	ssdelay(RESET_TICKS);
d1012 7
a1018 1
		if (allow_dc)
a1019 2
		else
			sfbyte(ss_dat, MSG_IDENTIFY);
a1061 1
	ssp->cmdstat = -1;
d1142 1
a1142 1
	printf("W");
d1170 1
a1170 1
	printf("CSK",ssp->cmdstat);
d1173 1
a1173 1
	printf("CSY",ssp->cmdstat);
d1177 1
a1177 1
	printf("CS%x",ssp->cmdstat);
d1213 1
a1213 1
		printf("ST0x info xfer timeout;  status=%x\n", status);
d1234 1
d1276 1
d1315 1
d1351 1
d1444 1
a1444 1
/* printf("%d in  %d out\n",ssp->data_bytes_in,ssp->data_bytes_out); */
d1447 1
a1447 1
printf("BFERR 5\n");
d1455 1
a1455 2
if(sserrct<=5)printf("R%d\n",retry[s_id]);
else printf("%d",retry[s_id]);
d1500 1
a1500 1
printf("bdr");
d1502 1
a1502 1
	if (st0x_busy)
d1548 1
a1548 1
printf("%d",bdr_ok);
d1570 1
a1570 1
	if (csr & RS_SELECT) {
d1598 1
a1598 1
	if ((dat & HOST_ID) && (dat & (1 << s_id)) && ssp && ssp->id_busy) {
d1614 1
a1614 1
printf("BFERR 6\n");
d1636 1
d1673 7
a1679 7
  sserrct++; if (sserrct <=5) {
    printf("F2 cmdlen=%d cmd_bytes_out=%d cmdstat=%d\n", ssp->cmdlen,
  	ssp->cmd_bytes_out, ssp->cmdstat);
    printf("%c msg_in=%x inl=%d ", rwc, ssp->msg_in, ssp->in_buf_len);
    printf("inb=%d otl=%d otb=%d\n", ssp->data_bytes_in, ssp->out_buf_len,
    ssp->data_bytes_out);
    printf("csr=%x dat=%x bno=%ld ",csr,dat,bp->b_bno);
d1683 1
a1683 1
else {printf("F1");spl(s);}
d1687 1
a1687 1
printf("ss_rw(): requesting sense\n");
d1690 1
a1690 1
if(!rw_ok) printf("F3");
d1697 1
a1697 1
if(!rw_ok) printf("F4");
d1703 25
@


1.33
log
@Starting to fix retry mechanism on ss_rw().
@
text
@d1 1
d6 8
a13 2
 *	figure out a better storage class for rqs
 *      make input buffer for commands dynamic (?)
d16 3
d167 1
a167 1
static void	bus_dev_reset();	/* additional support functions */
d214 1
d229 1
d310 1
a623 1
printf("@@");
d707 1
d713 2
d719 11
a729 3
	if (testready(s_id))
		retval = 1;
	else {
d734 4
a737 3
		else
			devmsg(dev, "Test Unit Ready Failed");
	}
d739 1
d786 1
d921 1
a921 1
	int ret;
d923 2
a924 1
	for (ret = 0, tries = 0; !ret && tries < LOPRI_RETRIES; tries++) {
d937 2
a938 1
			scsireset();
d960 4
a963 1
		sfbyte(ss_dat, MSG_IDENT_DC);
d1018 1
d1026 1
a1026 1
sfbyte(ss_csr, WC_ENABLE_IRPT); /* FOO */
d1032 2
d1109 15
d1145 1
a1145 1
	for ( i = 0; i < HIPRI_RETRIES; i++) {
d1187 1
d1231 1
d1271 1
d1304 1
d1355 5
d1393 6
a1398 2
				} else
printf("R%d\n",retry[s_id]);
a1430 9
 * BDR_CHECK_INTERVAL is the number of ticks to wait between checks for
 * SCSI Bus Free after sending Bus Device Reset.
 * BDR_CHECK_COUNT is the number of times to check for SCSI Bus Free
 * before giving up.
 */
#define BDR_CHECK_INTERVAL	10
#define BDR_CHECK_COUNT		100

/*
d1434 2
d1437 1
a1437 1
static void	bus_dev_reset(s_id)
d1439 1
a1439 1
	int tries;
d1441 7
a1447 2
printf("bus_dev_reset\n");
	for (tries = 0; tries < LOPRI_RETRIES; tries++) {
d1456 2
a1457 2
		 * SCSI spec says there is "no maximum" to the wait for arbitration
		 * complete.
d1460 1
a1460 2
			scsireset();
			continue;
d1462 1
d1464 4
a1467 3
		/*
		 * Arbitration complete.  Now select, with ATN to allow messages.
		 */
d1472 2
a1473 1
			continue;
d1475 1
d1480 2
a1481 1
			continue;
d1483 1
d1486 2
a1487 1
		break;
d1489 3
a1491 7
	for (tries = 0; tries < BDR_CHECK_COUNT; tries++) {
		if (ffbyte(ss_csr) == 0) {
	printf("bus device reset done\n");
			break;
		}
		ssdelay(BDR_CHECK_INTERVAL);
	}
d1545 13
a1557 8
			if (bp->b_req == BREAD)
				bp->b_resid -= ssp->data_bytes_in;
			else
				bp->b_resid -= ssp->data_bytes_out;
			if (cmd_ok && ssp->cmdstat == CS_GOOD) {
				if (ssp->msg_in == MSG_DISCONNECT) {
					ssp->dr_watch = WATCHDOG_SECONDS;
				} else
d1559 1
a1559 4
			} else {
printf("BFERR 6\n");
				bp->b_flag |= BFERR;
				ss_done(s_id);
d1575 2
a1576 1
	int retval;
d1582 3
d1587 2
d1591 1
d1605 4
a1608 1
	if (retval = bus_pre_xfer(s_id)) {
d1610 13
a1622 3
/* printf("cmdlen=%d cmd_bytes_out=%d cmdstat=%d\n", ssp->cmdlen,
	ssp->cmd_bytes_out, ssp->cmdstat); */
		retval = (ssp->cmdlen == ssp->cmd_bytes_out);
d1624 2
d1629 4
a1632 2
		if (req_sense(s_id))
			retval = (ssp->cmdlen == ssp->cmd_bytes_out);
d1635 8
a1642 3
	retval = (retval &&
		(ssp->cmdstat == CS_GOOD || ssp->msg_in == MSG_DISCONNECT));
	return retval;
@


1.32
log
@Accesses file system but has frequent BFERR 5's.
@
text
@d9 3
d1050 1
d1055 1
d1283 1
d1292 1
a1315 1
			ssq_rm_head();
d1319 2
a1326 2
				else
					printf("D");
d1329 1
d1331 6
a1336 2
				bp->b_flag |= BFERR;
				ss_done(s_id);
a1456 2
printf("R%d", s_id);
if(s_id!=0)s_id=-1;
@


1.31
log
@Now fdisk command works but mkfs fails.
@
text
@d9 3
d79 1
a79 1
#define HIPRI_RETRIES	400	/* # of times to retry while hogging CPU */
d583 2
a584 2
printf("ssblock: drv=%x bno=%lx bp=%x flag=%x\n",
	drive, bp->b_bno, bp, bp->b_flag);
a624 1
printf("*");
d1321 1
a1321 1
printf("%d in  %d out\n",ssp->data_bytes_in,ssp->data_bytes_out);
d1503 1
a1503 1
printf("ss_rw(%d)\n", s_id);
d1527 2
a1528 2
printf("cmdlen=%d cmd_bytes_out=%d cmdstat=%d\n", ssp->cmdlen,
	ssp->cmd_bytes_out, ssp->cmdstat);
@


1.30
log
@Trying to figure out disconnect after write.
@
text
@d9 3
a398 1
printf("BARF\n");
d619 1
a619 1
	int s_id;
a626 1
printf("1 s_id=%d dr_w=%d\n",s_id,ssp->dr_watch);
d635 2
a636 2
					s_id = chk_reconn();
					if (s_id == -1)
d639 1
a639 1
						reconnect(s_id);
d989 1
a1309 1
printf("2 s_id=%d dr_w=%d\n",s_id,ssp->dr_watch);
d1340 1
d1342 1
a1344 1
printf("3 s_id=%d dr_w=%d\n",s_id,ssp->dr_watch);
d1350 2
a1438 1
printf("chk_reconn: csr=%x dat=%x\n",csr,dat);
a1478 1
printf("4 s_id=%d dr_w=%d\n",s_id,ssp->dr_watch);
a1523 1
printf("ss_rw(): bus_pre_xfer ok\n");
d1528 1
a1528 2
	} else
printf("ss_rw(): bus_pre_xfer not ok\n");
a1537 1
printf("ss_rw(): retval=%d\n", retval);
@


1.29
log
@Whole disk devices working - need to implement HDGETA.
@
text
@d9 3
d153 1
a210 1
static int	dr_watch[MAX_SCSI_ID-1];
a362 1
printf("adj partn=%d\n", partn);
d466 3
a468 3
#define NHEAD	7
#define NSEC	28
#define NCYL	1066
d494 1
a494 1
  hdparm.ncyl[0] + hdparm.ncyl[1]<<8, (int)hdparm.nhead, (int)hdparm.nspt);
d625 1
d630 1
a631 1
printf("SCSI id #%d: bno=%lu <Watchdog Timeout>\n", s_id, ss[s_id]->bp->b_bno);
d690 1
a690 1
	uchar query_buf[INQUIRYLEN + 1];
d739 16
d772 2
d967 1
a969 2
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
d1043 4
d1121 2
d1161 2
d1180 39
d1232 2
a1293 1
		ssp->bp = bp;
a1298 4
		if (partition != WHOLE_DRIVE)
			ssp->bno = fdp[partition].p_base + bp->b_bno;
		else
			ssp->bno = bp->b_bno;
d1300 5
d1308 1
d1316 3
d1342 1
a1344 2
if (bp->b_flag & BFERR)
  printf("BFERR\n");
d1429 1
a1429 1
	uchar dat;
d1432 2
a1433 1
	if (ffbyte(ss_csr) && RS_SELECT) {
d1435 1
d1442 1
d1464 1
a1464 1
	if ((dat & HOST_ID) && (dat & (1 << s_id))) {
d1474 1
a1474 1
				if (ssp->msg_in == MSG_DISCONNECT)
d1476 2
a1477 1
				else
d1509 2
@


1.28
log
@Kernel fdisk works, fdisk command gets garbage.
@
text
@d9 3
d91 1
a91 1
	printf(" %x", ssp->in_buf[i]);printf(" data_bytes_in=%d\n",\
d113 1
a113 1
	uchar	*in_buf;
d116 1
a116 1
	uchar	*out_buf;
d375 1
d1014 4
a1017 2
				ssp->in_buf[ssp->data_bytes_in]
				= ffbyte(ss_dat);
d1027 4
a1030 1
				sfbyte(ss_dat, ssp->out_buf[ssp->data_bytes_out]);
d1103 2
a1104 1
	rqs.in_buf = sense_buf;
d1109 1
a1109 1
			if (rqs.in_buf[2] == 0x00)	/* No Sense.  AOK */
d1111 1
a1111 1
			else if (rqs.in_buf[2] == 0x06 && rqs.in_buf[12] == 0x29)
d1141 2
a1142 1
	ssp->in_buf = buf;
d1171 2
a1172 1
	ssp->in_buf = buf;
d1228 2
d1427 1
a1427 1
		ssp->in_buf = FP_OFF(bp->b_faddr);
d1431 1
a1431 1
		ssp->out_buf = FP_OFF(bp->b_faddr);
@


1.27
log
@Typos fixed.  Locks up CPU on first open
@
text
@d9 3
d334 1
a334 1

d357 1
a357 1

d361 2
d364 6
a369 2
	if (valid_open && partn != WHOLE_DRIVE && !(ssp->ptab_read))
		if (fdisk(dev, fdp)) {
d371 1
d373 1
a373 1
for (p=0; p<WHOLE_DRIVE; p++)
d381 1
d386 1
a386 1
	if (valid_open
d390 1
d393 1
a393 1
	if (valid_open && fdp[partn].p_size == 0) {
d417 1
d460 4
d470 4
d475 4
d480 12
a510 1
	register scsi_work_t *sw;
d538 1
d543 1
d561 1
d572 2
a573 2
printf("ssblock: drv %x bno %x:%x  bp=%x, flag = %o\n",
	drive, (long)sw->sw_bno, bp, bp->b_flag);
d575 1
a575 1
		ssq_wr_tail(sw);
d620 1
d1233 1
d1257 2
d1390 1
d1409 1
a1409 1

d1430 1
d1432 5
a1436 3
		retval = (ssp->cmdlen == ssp->cmd_bytes_out
			&& ssp->cmdstat == CS_GOOD);
	}
d1439 1
d1444 3
@


1.26
log
@First clean compile with block routine.
@
text
@d9 3
d194 1
a194 1
static ss_type *ss_block;	/* points to block of "ss" structs */
d257 1
a257 1
		} else if ((ss_block = kalloc(num_drives*sizeof(ss_type)))
d262 1
a262 1
			kclear(ss_block, num_drives * sizeof(ss_type));
d265 1
a265 1
		ss_type *foo = ss_block;
d290 2
a291 2
	if (ss_block)
		kfree(ss_block);
d669 1
a669 1
		if (inquiry(s_id), query_buf) {
d680 1
a680 1
		if (read_cap(s_id), query_buf) {
d1045 1
d1054 1
@


1.25
log
@lots of strategy code added - but not ready to compile
@
text
@d9 3
d97 1
a528 6
#ifdef BNO_CALC
		if (partition != WHOLE_DRIVE)
			sw->sw_bno = fdp[partition].p_base + bp->b_bno;
		else
			sw->sw_bno = bp->b_bno;
#endif
d555 1
a558 1
printf("@@");
d563 3
d579 2
d583 7
a589 3
				s_id = chk_reconn();
				if (s_id != -1)
					reconnect(s_id);
d640 2
d666 4
a669 4
		if (inquiry(s_id)) {
			ss[s_id]->in_buf[INQUIRYLEN] = 0;
			devmsg(dev, ss[s_id]->in_buf + 8);
			if (ss[s_id]->in_buf[0] == 0) {
d677 1
a677 1
		if (read_cap(s_id)) {
d679 7
a688 29
#if 0
	/*
	 * For test purposes only, try to read the partition table.
	 */
	if (retval) {
#define READ_PTS	1
int foo,fof;
for (foo=0,fof=0;foo<READ_PTS;){
	busted=0;
	drvl[SCSI_MAJOR].d_time++;
		if (read_pt(s_id)) {
			retval = 1;
		} else {
			devmsg(dev, "Read Partition Table Failed");
			break;
		}
foo++;
	if (!rpt_irpt){
		fof++;
		if (fof>=3) {
			printf("3 irq's lost\n");
			break;
		}
	}
} /*endfor*/
printf("%d read_pt's\n",foo);
	}
#endif

a729 1
	int tries;
d731 5
a735 4
	tries = 0;
	do {
		if (tries > 0)
			ssdelay(100);
d737 4
a740 5
		if (retval = bus_pre_xfer(s_id)) {
			bus_info_xfer(ssp);
			retval = (ssp->cmdlen == ssp->cmd_bytes_out
				&& ssp->cmdstat == CS_GOOD);
		}
a741 52
		if (ssp->cmdstat == CS_CHECK) {
			if (req_sense(s_id))
				retval = (ssp->cmdlen == ssp->cmd_bytes_out);
		}

		tries++;
	} while (ssp->cmdstat == CS_BUSY && tries < LOPRI_RETRIES);

	if (ssp->msg_in == MSG_DISCONNECT) {
		int connected = 0;
		uchar dat, csr;

printf("Disconnected ");
{
	int s;
	s=sphi();
	while(!rpt_irpt && !busted)
		sleep(&rpt_irpt, CVBLKIO,IVBLKIO,SVBLKIO);
	spl(s);
}
		for (tries = 0; tries < 10; tries++) {
			csr = ffbyte(ss_csr);
			if (csr & RS_SELECT) {
				dat = ffbyte(ss_dat);
				if (dat & HOST_ID) {
printf("%d tries Reconnected\n",tries);
					connected = 1;
					break;
				} else {
					int t;
printf("Host not selected\n");
					for (t = 0; t < 10; t++) {
						if (ffbyte(ss_csr) & RS_SELECT == 0) {
printf("Select dropped by target\n");
							break;
						}
						ssdelay(10);
					}
				}
			}
			ssdelay(10);
		}
		if (connected) {
			sfbyte(ss_csr, WC_ENABLE_SCSI | WC_BUSY);
			if (bus_wait(RS_SELECT << 8 | 0)) {
				sfbyte(ss_csr, WC_ENABLE_SCSI);
				bus_info_xfer(ssp);
				retval = (ssp->cmdstat == CS_GOOD);
			}
		}
	}

d977 1
a977 1
			if (ssp->data_bytes_out < ssp->out_buf_len && ssp->out_buf)
d980 1
a980 1
			else {	/* This case should not happen. */
d1070 1
d1073 1
a1073 1
static int inquiry(s_id)
d1075 1
d1080 1
d1086 1
d1090 1
d1102 1
a1102 1
static int read_cap(s_id)
d1104 1
d1109 1
d1115 1
d1119 1
a1119 9
	if (ret) {
		ssp->capacity = ssp->in_buf[3] | (ssp->in_buf[2] << 8)
		| (((long)(ssp->in_buf[1])) << 16)
		| (((long)(ssp->in_buf[0])) << 24);
		ssp->blocklen = ssp->in_buf[7] | (ssp->in_buf[6] << 8)
		| (((long)(ssp->in_buf[5])) << 16)
		| (((long)(ssp->in_buf[4])) << 24);
printf("capacity=%ld   block length=%ld\n", ssp->capacity, ssp->blocklen);
	}
d1153 3
d1169 7
a1217 28
 * read_pt()
 *
 * Read partition table for a device.
 *
 * Return 1 if command succeeds, else 0.
 */
static int read_pt(s_id)
int s_id;
{
	int ret = 0;
	ss_type * ssp = ss[s_id];

	ssp->cmdbuf[0] = ScmdREADEXTENDED;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] = 0;
	ssp->cmdbuf[5] = ssp->cmdbuf[6] = ssp->cmdbuf[7] = ssp->cmdbuf[9] = 0;
	ssp->cmdbuf[8] = 1;	/* transfer 1 block */
	ssp->cmdlen = G1CMDLEN;
	ssp->in_buf_len = BSIZE;

	ret = scsicmd(s_id);
	if (ret) {
printf("signature low:%x high:%x\n", ssp->in_buf[510], ssp->in_buf[511]);
	}

	return ret;
}

/*
d1321 1
d1324 1
d1326 20
a1345 5
	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_BUSY);
	if (bus_wait(RS_SELECT << 8 | 0)) {
		sfbyte(ss_csr, WC_ENABLE_SCSI);
		if (bus_info_xfer(ssp) && ssp->cmdstat == CS_GOOD)
			cmd_ok = 1;
d1347 1
a1347 7
/* This is not finished: dr_watch, bdone, id_busy, etc. 
and what of another disconnect??? */
/* no disconnect allowed for inquiry, test ready, read capacity, etc. */
		bp->b_resid -= BSIZE;
	if (cmd_ok)
	if (ssp->msg_in != MSG_DISCONNECT)
		ssp->dr_watch = WATCHDOG_SECONDS;
a1348 2
}

d1370 6
a1375 2
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] = 0;
	ssp->cmdbuf[5] = ssp->cmdbuf[6] = ssp->cmdbuf[9] = 0;
d1378 1
@


1.24
log
@Some rearrangements - still working on block & related routines
@
text
@a0 2
int rpt_irpt;
int busted;
d2 1
a2 1
 * This is a driver for Seagate ST01/ST02 scsi hard disk controllers.
d9 3
d61 1
a64 6
				/* Device States */
#define	SIDLE		0	/* controller idle */
#define	SRETRY		1	/* seeking */
#define	SREAD		2	/* reading */
#define	SWRITE		3	/* writing */

d90 1
d92 2
a93 2
	long	capacity;
	long	blocklen;
d95 1
d100 1
a100 1
	uchar	in_buf[IN_BUF_SIZE];
d103 4
a106 1
	BUF	*bp;
d135 1
a135 2
static void	chk_reconn();
static void	do_ss();
d138 1
d143 1
a192 1
static int	ss_state;	/* starts at SIDLE */
d380 2
a381 1
	 * OK - open the device.
d394 3
d521 2
a522 1
	 * See if we can allocate a request node for this operation.
d525 1
a525 16
		bp->b_actf = NULL;
		sw = (scsi_work_t *)kalloc( sizeof(*sw) );
		if (sw == NULL) {
			devmsg(dev, "out of kernel memory");
			bp->b_flag |= BFERR;
			valid_op = 0;
		}
	}

	/*
	 * Operation appears valid and we have a node for it.
	 * Fill fields in the node and queue the request.
	 */
	if (valid_op) {
		sw->sw_bp = bp;
		sw->sw_drv = drive;
d530 1
a530 1
		sw->sw_retry = 1;
d536 1
a536 2
		if (ss_state == SIDLE)
			ss_start();
d548 4
d555 6
a560 3
	printf("@@");
	rpt_irpt=1;
	wakeup(&rpt_irpt);
d568 2
a569 1
	int	s_id;
d571 6
a576 5
	for (s_id = 0; s_id < MAX_SCSI_ID-1; s_id++)
		if (dr_watch[s_id]) {
			dr_watch[s_id]--;
			chk_reconn();
			if (dr_watch[s_id] == 0) {
d579 4
d585 1
a585 4
	printf("*");
	busted = 1;
	drvl[SCSI_MAJOR].d_time--;
	wakeup(&rpt_irpt);
d673 1
a673 1
#if 1
a680 1
	rpt_irpt=0;
d968 1
d1032 1
a1032 1
			if (ssp->data_bytes_in < ssp->in_buf_len)
d1035 2
a1036 1
			else
a1037 1
			ssp->data_bytes_in++;
d1041 1
a1041 1
			 * Temporary filler.
d1043 7
a1049 1
			sfbyte(ss_dat, 0xAA);
d1193 1
a1193 2
 * Invoked whenever there is I/O to do.  Pull first request, if any,
 * off the queue, send it to the drive, and delete it from the queue.
d1196 15
d1215 1
a1215 1
	scsi_work_t *sw;
d1217 2
d1228 20
a1247 8
	if((sw = ssq_rm_head()) != NULL) {
		if (sw->sw_bp->b_req == BWRITE)
			ss_state = SWRITE;
		else if (sw->sw_bp->b_req == BREAD)
			ss_state = SREAD;
		else
			printf("Error:  b_req=%d\n", sw->sw_bp->b_req);
		do_ss(sw);
d1253 1
a1253 1
 * do_ss()
a1254 24
 * Begin a block read or write command as found in an "sw" queue entry.
 */
static void do_ss(sw)
struct scsi_work_t * sw;
{
	BUF * bp;

printf("do_ss\n");
	bp = sw->sw_bp;
	switch(ss_state) {
	case SREAD:
		bp->b_resid -= BSIZE;
		ss_done(sw);
		break;
	case SWRITE:
		bp->b_resid -= BSIZE;
		ss_done(sw);
		break;
	}
}

/*
 * ss_done
 *
d1257 2
a1258 2
static void ss_done(sw)
struct scsi_work_t * sw;
d1260 2
a1261 1
	BUF * bp;
d1263 4
a1266 5
printf("ss_done\n");
	if (sw) {
		bp = sw->sw_bp;

		ss_state = SIDLE;
d1268 1
a1268 1
		kfree(sw);
d1270 2
a1272 4
	if (ssq_rd_head())
		ss_start();
}

d1358 1
a1358 1
			printf("bus device reset done\n");
d1368 1
a1368 1
 * Poll to see if any SCSI device has tried to reconnect to the host
d1371 5
d1377 1
a1377 1
static void chk_reconn()
d1379 15
d1395 68
@


1.23
log
@ssopen compiles - not tested
@
text
@d11 3
d25 19
d45 4
d61 2
d93 18
d112 4
a115 1
 * Includes.
a116 30
#include	<coherent.h>
#include	<sys/io.h>
#include	<sys/sched.h>
#include	<sys/uproc.h>
#include	<sys/proc.h>
#include	<sys/con.h>
#include	<sys/stat.h>
#include	<sys/devices.h>		/* SCSI_MAJOR */
#include	<errno.h>

#include 	<sys/fdisk.h>
#include	<sys/hdioctl.h>
#include	<sys/buf.h>
#include	<scsiwork.h>
#include	<ss.h>

/*
 * Export Functions.
 */

/*
 * Export Variables - patch these to configure the driver.
 */
int	NSDRIVE = 1;		/* Bitmap of attached SCSI drives. */
int	SS_INT = 5;		/* ST0[12] use either IRQ3 or IRQ5 */
int	SS_BASE = 0xDE00;	/* Segment addr of ST0x communication area */

/*
 * Import Functions.
 */
a120 3
/*
 * Local Functions.
 */
d134 1
d150 4
a153 1
 * Local Variables.
a154 20
static BUF	dbuf;		/* For raw I/O */
static paddr_t	ss_base;	/* physical address of ST0x comm area */
static faddr_t	ss_fp;		/* (far *) to ST0x comm area */

static faddr_t	ss_ram;		/* (far *) to parameter RAM */
static faddr_t	ss_csr;		/* (far *) to control/status */
static faddr_t	ss_dat;		/* (far *) to data port */

static int	num_drives;	/* number of controller SCSI id's */
static struct ss *ss_block;	/* points to block of "ss" structs */
static int	st0x_busy;	/* 1 if SCSI host adapter busy */

static TIM	delay_tim;	/* needed for calls to ssdelay() */
static TIM	timeout_tim;	/* needed for calls to timeout() */
static int	ss_expired;	/* 1 after local timeout */
static int	ss_state;	/* starts at SIDLE */

/*
 * Driver CON entry - an export variable.
 */
d171 4
a174 5
/*
 * A per-drive structure - ss
 */
#define IN_BUF_SIZE	512
typedef unsigned char	uchar;
d176 3
a178 15
static struct ss	{
	long	capacity;
	long	blocklen;
	int	msg_in;
	uchar	cmdbuf[G1CMDLEN];
	int	cmdlen;
	int	cmd_bytes_out;
	int	cmdstat;
	uchar	in_buf[IN_BUF_SIZE];
	int	in_buf_len;
	int	data_bytes_in;
	struct	fdisk_s parmp[NPARTN+1];
	unsigned int	ptab_read:1;  /* 1 if partition table has been read */
	unsigned int	id_busy:1;  /* 1 if device with this SCSI id busy */
} *ss[MAX_SCSI_ID-1], rqs;
d180 15
d249 1
a249 1
		} else if ((ss_block = kalloc(num_drives*sizeof(struct ss)))
d254 1
a254 1
			kclear(ss_block, num_drives * sizeof(struct ss));
d257 1
a257 1
		struct ss *foo = ss_block;
d311 1
a311 1
	struct ss * ssp;
d467 1
a467 1
	struct ss * ssp;
d571 11
d584 1
a584 1
	drvl[SCSI_MAJOR].d_time=0;
d683 1
a683 1
	drvl[SCSI_MAJOR].d_time=1;
d718 1
a718 1
	struct ss * ssp = ss[s_id];
d743 1
a743 1
	struct ss *ssp = ss[s_id];
d958 1
a958 1
struct ss *ssp;
d1136 1
a1136 1
	struct ss * ssp = ss[s_id];
d1161 1
a1161 1
	struct ss * ssp = ss[s_id];
d1253 2
a1254 1
	bp = sw->sw_bp;
d1256 4
a1259 3
	ss_state = SIDLE;
	bdone(bp);
	kfree(sw);
d1276 1
a1276 1
	struct ss * ssp = ss[s_id];
d1356 11
@


1.22
log
@Starting to get block operations working.
@
text
@d11 3
a76 1
#include	<ss.h>
d82 1
a101 4
extern void ssq_wr_tail();
extern scsi_work_t * ssq_rd_head();
extern scsi_work_t * ssq_rm_head();

d303 1
a303 1
static void ssopen( dev, mode )
d307 4
a310 1
	int erf = 0;
d312 4
d318 3
d328 1
a328 1
		erf = 1;
d332 1
a332 1
	 * If "special" bit is set, partition must be zero.
d334 1
a334 1
	if (!erf && DEV_SPECIAL(dev) && partn != 0) {
d336 1
a336 1
		erf = 1;
d340 1
a340 1
	 * If "special" bit is NOT set, error return for now.
d342 2
a343 4
	if (!erf && !DEV_SPECIAL(dev)) {
		u.u_error = ENXIO;
		erf = 1;
	}
d346 2
a347 1
	 * OK - open the device.
d349 13
a361 4
	if (!erf) {
		++drvl[SCSI_MAJOR].d_time;
	}
#if 0
d365 2
a366 1
	if ((pparm[p].p_base+pparm[p].p_size) > pparm[d+NDRIVE*NPARTN].p_size)
d368 4
a371 1
	else if ( pparm[p].p_size == 0 )
d373 9
a381 1
#endif
d387 1
a387 1
static void ssclose( dev )
d394 1
a394 1
 * ssread()	- write a block to the raw disk
d401 1
a401 1
static void ssread( dev, iop )
d416 1
a416 1
static void sswrite( dev, iop )
d433 1
a433 1
static int ssioctl( dev, cmd, vec )
d660 1
a660 10
#if 0
	if (retval) {
		retval = fdisk(dev, ss[s_id]->parmp);
		if (retval) {
			printf("fdisk scsi id #%d succeeded\n", s_id);
			ss[s_id]->ptab_read = 1;
		} else
			printf("fdisk scsi id #%d failed\n", s_id);
	}
#else
a788 1
printf("Select deasserted by target\n");
@


1.21
log
@Move define's to ss.h and scsiwork.h.  Other cleanup
@
text
@a6 1
 *	turn on interrupts
d11 3
d645 1
d647 1
a647 1
for (foo=0,fof=0;foo<100;){
@


1.20
log
@Reads boot sector 100 times using IRQ on reconnect
@
text
@d12 2
a13 51
 * Revision 1.19	91/03/26  23:15:47	root
 * Reads partition table in prototype code
 * 
 * Revision 1.18	91/03/25  20:11:30	root
 * first raw read - disconnects
 * 
 * Revision 1.17	91/03/25  19:06:36	root
 * calls ssqueue functions - need real i/o
 * 
 * Revision 1.16	91/03/22  17:40:03	root
 * Need to do more with ss_start()
 * 
 * Revision 1.15	91/03/21  16:44:03	root
 * getting ready to call fdisk - finish ss_start next
 * 
 * Revision 1.14	91/03/20  17:25:14	root
 * Inquiry and Read Capacity working
 * 
 * Revision 1.13	91/03/18  17:43:18	root
 * add retry logic to scsicmd(); general cleanup
 * 
 * Revision 1.12	91/03/14  17:22:28	root
 * Test Ready now works, including Req Sense
 * 
 * Revision 1.11	91/03/14  15:45:12	root
 * has trouble with Test Ready using bus_info_xfer fsa
 * 
 * Revision 1.10	91/03/13  17:08:03	root
 * still more to do on bus_info_xfer
 * 
 * Revision 1.9	91/03/12  16:08:23	root
 * need to finish bus_info_xfer()
 * 
 * Revision 1.8	91/03/11  17:41:10	root
 * started ssopen()/wrote stub for ssinit()
 * 
 * Revision 1.7	91/03/08  17:07:28	root
 * Does Test Read and Request Sense properly.
 * 
 * Revision 1.6	91/03/07  16:41:31	root
 * sends Test Ready, Starts to Request Sense
 * 
 * Revision 1.5	91/03/07  11:48:39	root
 * Now sends Identify and Abort messages & completes a SCSI bus cycle
 *
 * Revision 1.4	91/03/06  16:31:45	root
 * tried to send Identify message - get status 0x40 & fail
 *
 * Revision 1.3	91/03/05  17:03:43	root
 * Goes thru arbitration (sans IRQ) successfully
 *
a24 26
#define SS_RAM		0x1800	/* Offset of parameter RAM */
#define SS_CSR		0x1A00	/* Offset of control/status register */
#define SS_DAT		0x1C00	/* Offset of data port */

#define SS_RAM_LEN	128	/* ST0x has 128 bytes of RAM */
#define SS_DAT_LEN	0x400	/* Byte range mapped to data port */
#define SS_SEL_LEN	0x2000	/* Total size of memory-mapped area */

#define WC_ENABLE_SCSI	0x80	/* Write Control (WC) register bits */
#define WC_ENABLE_IRPT	0x40
#define WC_ENABLE_PRTY	0x20
#define WC_ARBITRATE	0x10
#define WC_ATTENTION	0x08
#define WC_BUSY  	0x04
#define WC_SELECT  	0x02
#define WC_SCSI_RESET  	0x01

#define RS_ARBIT_COMPL	0x80	/* Read STATUS (RS) register bits */
#define RS_PRTY_ERROR	0x40
#define RS_SELECT	0x20
#define RS_REQUEST	0x10
#define RS_CTRL_DATA	0x08
#define RS_I_O  	0x04
#define RS_MESSAGE  	0x02
#define RS_BUSY  	0x01

a29 19
#define G0CMDLEN	6	/* Group 0 commands are 6 bytes long  */
#define G1CMDLEN	10	/* Group 1 commands are 10 bytes long */
#define SENSELEN	22	/* number of bytes returned w/ req sense */
#define INQUIRYLEN	54	/* number of bytes returned w/ inquiry */

				/* Message types */
#define MSG_CMD_CMPLT	0x00	/* Command Complete */
#define MSG_SAVE_DPTR	0x02	/* Save SCSI data pointer */
#define MSG_RSTOR_DPTR	0x03	/* Restore SCSI pointers */
#define MSG_DISCONNECT	0x04	/* Target is about to disconnect */
#define MSG_ABORT	0x06	/* End the current SCSI bus cycle */
#define MSG_DEV_RESET	0x0C	/* Bus Device Reset */
#define MSG_IDENT_DC	0xC0	/* Identify, with Disconnect allowed */

#define CS_GOOD		0x00	/* Command Status from the drive */
#define CS_CHECK	0x02
#define CS_BUSY		0x08
#define CS_RESERVED	0x18

a35 12
/*
 * Information Transfer Phase masks -
 * setting of RS_MESSAGE, RS_I_O, and RS_CTRL_DATA determines which of six
 * possible info transfer phases is occurring.
 */
#define XP_MSG_IN	(RS_MESSAGE | RS_I_O | RS_CTRL_DATA)
#define XP_MSG_OUT	(RS_MESSAGE          | RS_CTRL_DATA)
#define XP_STAT_IN	(             RS_I_O | RS_CTRL_DATA)
#define XP_CMD_OUT	(                      RS_CTRL_DATA)
#define XP_DATA_IN	(             RS_I_O               )
#define XP_DATA_OUT	(                                 0)

d70 1
a70 1
#include	<devices.h>		/* SCSI_MAJOR */
d72 1
d104 1
a104 3
static void	ssload();
static void	ssunload();
static void	ssopen();
d106 1
d111 10
a120 2
static void	ssblock();
static int	ssinit();
d123 2
a124 3
static void	ssdelay();
static int	bus_pre_xfer();
static int	bus_info_xfer();
d127 2
a128 3
static int	req_sense();
static int	inquiry();
static int	read_cap();
a129 4
static void	ss_start();
static void	ss_done();
static void	do_ss();
static void	bus_dev_reset();
d435 1
d437 2
a446 1

a448 2
	bp->b_resid = bp->b_count;
	
d458 1
a458 2
				bdone(bp);
				return;
d463 1
a463 2
			bdone(bp);
			return;
d471 1
a471 2
		bdone(bp);
		return;
d479 1
a479 2
		bdone(bp);
		return;
d482 11
a492 7
	bp->b_actf = NULL;
	sw = (scsi_work_t *)kalloc( sizeof(*sw) );
	if (sw == NULL) {
		devmsg(dev, "out of kernel memory");
		bp->b_flag |= BFERR;
		bdone(bp);
		return;
a493 7
	sw->sw_bp = bp;
	sw->sw_drv = drive;
	if (partition != WHOLE_DRIVE)
		sw->sw_bno = fdp[partition].p_base + bp->b_bno;
	else
		sw->sw_bno = bp->b_bno;
	sw->sw_retry = 1;
d495 13
d511 10
a520 3
	ssq_wr_tail(sw);
	if (ss_state == SIDLE)
		ss_start();
a525 6
#if 0
static int irpted;
static long x;
for (x = 0, irpted = 0; x < 100000L; x++)  if (irpted) break;
#endif

a583 16
 *
 * Pseudocode:
 *
 * retval = 0
 * if Test Unit Ready command fails, even after SCSI reset and retry
 *   print "Test Unit Ready fails"
 * else if Request Sense command fails
 *   print "Request Sense fails"
 * else if Read Capacity command succeeds
 *   print "Read Capacity fails"
 * else if partition table can't be read
 *   print "can't get partition table"
 * else
 *   print "SCSI id #n initialized"
 *   retval = 1
 * return retval
d591 4
d671 2
a785 2
int RESET_ON_TICKS = 40;
int RESET_OFF_TICKS = 40;
d790 1
a790 1
	ssdelay(RESET_ON_TICKS);
d792 1
a792 1
	ssdelay(RESET_OFF_TICKS);
a940 4
			/*
			 * Only pay attention to first msg byte in.
			 * Don't care about extended messages.
			 */
a941 1
printf("msg_in = %x\n", msg_in);
@
