head     1.46;
access   ;
symbols  ;
locks    ;
comment  @ * @;


1.46
date     91.05.16.21.54.10;  author root;  state Exp;
branches ;
next	1.45;

1.45
date     91.05.16.17.47.26;  author root;  state Exp;
branches ;
next	1.44;

1.44
date     91.05.16.14.17.20;  author root;  state Exp;
branches ;
next	1.43;

1.43
date     91.05.16.01.08.22;  author root;  state Exp;
branches ;
next	1.42;

1.42
date     91.05.15.23.58.22;  author root;  state Exp;
branches ;
next	1.41;

1.41
date     91.05.15.21.57.55;  author root;  state Exp;
branches 1.41.1.1;
next	1.40;

1.40
date     91.05.15.15.19.52;  author root;  state Exp;
branches 1.40.1.1;
next	1.39;

1.39
date     91.05.15.09.35.58;  author root;  state Exp;
branches ;
next	1.38;

1.38
date     91.05.14.10.05.37;  author root;  state Exp;
branches ;
next	1.37;

1.37
date     91.05.13.15.02.21;  author root;  state Exp;
branches ;
next	1.36;

1.36
date     91.05.13.11.08.25;  author root;  state Exp;
branches ;
next	;

1.40.1.1
date     91.05.15.23.21.27;  author root;  state Exp;
branches ;
next	;

1.41.1.1
date     91.05.15.23.47.43;  author root;  state Exp;
branches ;
next	;


desc
@Seagate ST01/ST02 device driver - state machine version.
@


1.46
log
@Hang bug fixed.  Raw i/o > 1 block reads 0.
@
text
@/*
 * Device driver for Seagate ST01/ST02 scsi host adapters.
 *
 * To do:
 *	set host_claimed conscientiously
 *	works but hogs CPU during big dd to /dev/null
 *
 *	bufq_rd_head()
 *	bufq_rm_head()
 *	bufq_wr_tail()
 *
 *	backoff & retry when bdr or req sense needed
 *	nonzero LUN's
 *	assembler I/O
 *
 * $Log:	/usr/src/sys/i8086/drv/RCS/ss.c,v $
 * Revision 1.45	91/05/16  17:47:26	root
 * Still trying to test ss_get.  Always hangs.
 * 
 * Revision 1.44	91/05/16  14:17:20	root
 * Drop unneeded fields from ss struct.  Try ss_get().
 * 
 * Revision 1.43	91/05/16  01:08:22	root
 * Needs assembler I/O most.
 * 
 * Revision 1.42	91/05/15  23:58:22	root
 * COH fdisk command gives junk when DEBUG=1, ok if DEBUG=3
 * 
 * Revision 1.41	91/05/15  21:57:55	root
 * First working version.
 * 
 * Revision 1.40	91/05/15  15:19:52	root
 * First clean compile of state machine version.
 * 
 * Revision 1.39	91/05/15  09:35:58	root
 * Code recover, do_connect, etc..
 * 
 * Revision 1.38	91/05/14  10:05:37	root
 * Code ss_mach().
 * 
 * Revision 1.37	91/05/13  15:02:21	root
 * Initial state machine hacks.
 * 
 * Revision 1.36	91/05/13  11:08:25	root
 * Last version before using state machine logic.
 * 
 */

/*
 * Debug levels.
 * DEBUG = 0	No debug output.
 * DEBUG = 1	Debug output on error only.
 * DEBUG = 2	Debug output on error only and at other selected places.
 * DEBUG = 3	Maximum debug output.
 */
#if (DEBUG >= 1)
#define PR1(str)		printf(str)
#else
#define PR1(str)
#endif
#if (DEBUG >= 2)
#define PR2(str)		printf(str)
#else
#define PR2(str)
#endif
#if (DEBUG >= 3)
#define PR3(str)		printf(str)
#else
#define PR3(str)
#endif

/* TEMPORARY S**T */
#define bufq_rd_head(s_id)	ssq_rd_head()
#define bufq_rm_head(s_id)	ssq_rm_head()
#define bufq_wr_tail(s_id, foo)	ssq_wr_tail(foo)

/*
 * Includes.
 */
#include	<coherent.h>
#include	<sys/io.h>
#include	<sys/sched.h>
#include	<sys/uproc.h>
#include	<sys/proc.h>
#include	<sys/con.h>
#include	<sys/stat.h>
#include	<sys/devices.h>		/* SCSI_MAJOR */
#include	<errno.h>

#include 	<sys/fdisk.h>
#include	<sys/hdioctl.h>
#include	<sys/buf.h>
#include	<scsiwork.h>
#include	<ss.h>

/*
 * Definitions.
 *	Constants.
 *	Macros with argument lists.
 *	Typedefs.
 *	Enums.
 */
#define DEV_SCSI_ID(dev)	((dev >> 4) & 0x0007)
#define DEV_LUN(dev)		((dev >> 2) & 0x0003)
#define DEV_DRIVE(dev)		((dev >> 2) & 0x001F)
#define DEV_PARTN(dev)		(dev & 0x0003)
#define DEV_SPECIAL(dev)	(dev & 0x0080)

#define HOST_ID		0x80	/* Host adapter is SCSI ID #7 */
#define HIPRI_RETRIES	400	/* # of times to retry while hogging CPU */
#define LOPRI_RETRIES	5	/* # of retries with sleep between tries */
#define WHOLE_DRIVE	NPARTN

#define BUS_FREE	((ffbyte(ss_csr) & (RS_BUSY | RS_SELECT)) == 0)
#define TGT_RSEL	\
	(  (ffbyte(ss_csr) & (RS_SELECT |  RS_I_O   )) \
	&& (ffbyte(ss_dat) & (HOST_ID   | (1<<s_id) )) )

#define DELAY_ARB	10	/* delays units are 10 msec (clock ticks) */
#define DELAY_BDR	30
#define DELAY_BSY	10
#define DELAY_RES	40
#define DELAY_RST	40

#define MAX_AVL_COUNT	10
#define MAX_BDR_COUNT	2
#define MAX_BSY_COUNT	2
#define MAX_TRY_COUNT	7

typedef unsigned char	uchar;
typedef unsigned int	uint;
typedef unsigned long	ulong;

typedef enum {			/* values for current driver state */
	SST_DEQUEUE =0,
	SST_BUS_DEV_RESET,
	SST_HIPRI_RESET,
	SST_LOPRI_RESET,
	SST_POLL_ARBITN,
	SST_POLL_BEGIN_IO,
	SST_POLL_RESELECT,
	SST_REQ_SENSE,
	SST_RESET_DONE,
	SST_RESET_OFF
} SST_TYPE;

typedef enum {			/* values for input to recovery routine */
	RV_A_TIMEOUT,
	RV_P_TIMEOUT,
	RV_R_TIMEOUT,
	RV_BF_TIMEOUT,
	RV_CS_BUSY,
	RV_CS_CHECK
} RV_TYPE;

typedef struct ss {
	ulong	capacity;
	ulong	blocklen;
	ulong	bno;
	int	msg_in;
	int	dr_watch;
	uchar	cmdbuf[G1CMDLEN];
	int	cmdlen;
	int	cmd_bytes_out;
	int	cmdstat;
	BUF	*bp;		/* current I/O request node, or NULL */
	struct	fdisk_s parmp[NPARTN+1];
	SST_TYPE state;
	TIM	tim;		/* for target-specific timers */
	uchar	avl_count;
	uchar	bdr_count;
	uchar	bsy_count;
	uchar	try_count;
	uint	busy:1;		/* 1 if command uses local buffer */
	uint	expired:1;	/* 1 if target's timer has expired */
	uint	ptab_read:1;	/* 1 if partition table has been read */
	uint	waiting:1;	/* 1 if target timer is running */
}	ss_type;

typedef struct {
	uint	ncyl;
	uchar	nhead;
	uchar	nspt;
}	drv_parm_type;

/*
 * Functions.
 *	Import Functions.
 *	Export Functions.
 *	Local Functions.
 */
extern int	nulldev();
extern int	nonedev();
extern unsigned char ffbyte();

static void	ssopen();		/* CON functions */
static void	ssclose();
static void	ssblock();
static void	ssread();
static void	sswrite();
static int	ssioctl();
static void	sswatch();
static void	ssload();
static void	ssunload();

static int	bus_dev_reset();	/* additional support functions */
static int	chk_reconn();
static void	do_connect();
static int	far_info_xfer();
static int	host_ident();
static void	init_pointers();
static int	inquiry();
static int	local_info_xfer();
static int	mode_sense();
static void	nonpolled();
static int	read_cap();
static void	recover();
static int	req_sense();
static int	rsel_handshake();
static void	ss_finished();
static void	ss_mach();
static void	set_timeout();
static int	ssinit();
static void	ssintr();
static int	start_arb();
static void	stop_timeout();

/*
 * Global Data.
 *	Import Variables.
 *	Export Variables.
 *	Local Variables.
 */
CON	sscon	= {
	DFBLK|DFCHR,			/* Flags */
	SCSI_MAJOR,			/* Major index */
	ssopen,				/* Open */
	ssclose,			/* Close */
	ssblock,			/* Block */
	ssread,				/* Read */
	sswrite,			/* Write */
	ssioctl,			/* Ioctl */
	nulldev,			/* Powerfail */
	sswatch,			/* Timeout */
	ssload,				/* Load */
	ssunload,			/* Unload */
	nulldev				/* Poll */
};

	/* Patch these Export Variables to configure the driver. */
int	NSDRIVE = 1;		/* Bitmap of attached SCSI drives. */
int	SS_INT = 5;		/* ST0[12] use either IRQ3 or IRQ5 */
int	SS_BASE = 0xDE00;	/* Segment addr of ST0x communication area */

#define NCYL	1004
#define NHEAD	4
#define NSPT	52

drv_parm_type drv_parm[MAX_SCSI_ID-1] = {
	{ NCYL, NHEAD, NSPT},
	{ 0, 0, 0},
	{ 0, 0, 0},
	{ 0, 0, 0},
	{ 0, 0, 0},
	{ 0, 0, 0},
	{ 0, 0, 0}
};

static BUF	dbuf;		/* For raw I/O */
static paddr_t	ss_base;	/* physical address of ST0x comm area */
static faddr_t	ss_fp;		/* (far *) to ST0x comm area */

static faddr_t	ss_ram;		/* (far *) to parameter RAM */
static faddr_t	ss_csr;		/* (far *) to control/status */
static faddr_t	ss_dat;		/* (far *) to data port */

static int	num_drives;	/* number of controller SCSI id's */

static int	do_sst_op;	/* 1 when state machine iteration continues */
static int	host_claimed;	/* -1 or SCSI id of target using the host */
static int	ss_expired;	/* 1 after local timeout */

static ss_type	*ss_tbl;	/* points to block of "ss" structs */
static ss_type  *ss[MAX_SCSI_ID-1];

/*
 * ssload()	- load routine.
 *
 *	Action:	The controller is reset and the interrupt vector is grabbed.
 *		The drive characteristics are set up at this time.
 */
static void ssload()
{
	int erf = 0;  /* 1 if error occurs */
	int i;

	/*
	 * Claim IRQ vector.
	 */
	setivec(SS_INT, ssintr);

	/*
	 * Allocate a selector to map into ST0x memory-mapped comm area.
	 */
	ss_base = (paddr_t)((long)(unsigned)SS_BASE << 4);
	ss_fp = ptov(ss_base, (fsize_t)SS_SEL_LEN);

	ss_ram = ss_fp + SS_RAM;
	ss_csr = ss_fp + SS_CSR;
	ss_dat = ss_fp + SS_DAT;
printf("ss_dat=%lx ", ss_dat);
	/*
	 * Primitive test of ST0x RAM.
	 */
	sfword(ss_ram, 0xA55A);
	sfword(ss_ram + 2, 0x3CC3);
	sfword(ss_ram + SS_RAM_LEN - 4, 0xA55A);
	sfword(ss_ram + SS_RAM_LEN - 2, 0x3CC3);
	if (ffword(ss_ram) != 0xA55A		/* fetch a "far" word */
	||  ffword(ss_ram + 2) != 0x3CC3
	||  ffword(ss_ram + SS_RAM_LEN - 4) != 0xA55A
	||  ffword(ss_ram + SS_RAM_LEN - 2) != 0x3CC3) {
		printf("Error - ST0x failed memory test\n");
		erf = 1;
	}

	/*
	 * Allocate drive structs.
	 *
	 * Do a single call to kalloc() then put allocated pieces into
	 * array ss.
	 *
	 * First allocate and clear storage.  Then hook up the pointers.
	 */
	if (!erf) {
		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				num_drives++;
		if (num_drives == 0) {
			printf("Error - ss has no valid target id's\n");
			erf = 1;
		} else if ((ss_tbl = kalloc(num_drives*sizeof(ss_type)))
		== NULL) {
			printf("Error - ss can't allocate structs\n");
			erf = 1;
		} else
			kclear(ss_tbl, num_drives * sizeof(ss_type));
	}
	if (!erf) {
		ss_type *foo = ss_tbl;

		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				ss[i] = foo++;
	}

	/*
	 * Initialize drives we know about (i.e. in NSDRIVE bitmap).
	 */
	host_claimed = -1;
	if (!erf) {
		for (i = 0; i < MAX_SCSI_ID -1; i++)
			if ((NSDRIVE >> i) & 1)
				ssinit(i);
	}
}

/*
 * ssunload()	- unload routine.
 */
static void ssunload()
{
	/*
	 * Deallocate driver heap space.
	 */
	if (ss_tbl)
		kfree(ss_tbl);

	/*
	 * Free the ST0x selector.
	 */
	vrelse(ss_fp);

	/*
	 * Release IRQ vector.
	 */
	clrivec(SS_INT);
}

/*
 * ssopen()
 *
 *	Input:	dev = disk device to be opened.
 *		mode = access mode [IPR,IPW, IPR+IPW].
 *
 *	Action:	Validate the minor device.
 *		Update the paritition table if necessary.
 */
static void ssopen(dev, mode)
register dev_t	dev;
{
	int drive, partn;
	int valid_open;
	struct	fdisk_s	*fdp;
	ss_type * ssp;
	int s_id;

	/*
	 * Set up local variables.
	 */
	valid_open = 1;
	drive = DEV_SCSI_ID(dev);
	partn = DEV_PARTN(dev);
	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	fdp = ssp->parmp;

#if (DEBUG >= 3)
devmsg(dev, "ssopen");
#endif

	/*
	 * LUN must be zero.
	 * SCSI id must have corresponding 1 in NSDRIVE bitmapped variable.
	 */
	if (DEV_LUN(dev) != 0 || ((1 << drive) & NSDRIVE) == 0) {
		u.u_error = ENXIO;
		valid_open = 0;
	}

	/*
	 * If "special" bit is set, partition field must be zero.
	 */
	if (valid_open && DEV_SPECIAL(dev) && partn != 0) {
		u.u_error = ENXIO;
		valid_open = 0;
	}

	/*
	 * Subscripting gimmick for partition table.
	 */
	if (valid_open && dev & SDEV)
		partn = WHOLE_DRIVE;
	/*
	 * If not accessing whole drive and the partition table has not
	 * been read yet, try to read it now.
	 * Do this by calling fdisk() with partition table device on the drive
	 * that is being accessed.
	 */
	if (valid_open && partn != WHOLE_DRIVE && !(ssp->ptab_read)) {
		int fdisk_dev;

		fdisk_dev = (dev | SDEV) & 0xfff0;

#if (DEBUG >=3)
		devmsg(fdisk_dev, "calling fdisk");
		if (fdisk(fdisk_dev, fdp)) {
			int p;

			fdp[WHOLE_DRIVE].p_size = ssp->capacity;
			fdp[WHOLE_DRIVE].p_base = 0;
			printf("fdisk() succeeded\n");
			for (p=0; p<=WHOLE_DRIVE; p++)
	printf("p=%d base=%ld size=%ld\n", p, fdp[p].p_base, fdp[p].p_size);
			ssp->ptab_read = 1;
		} else {
			printf("fdisk() failed\n");
			u.u_error = ENXIO;
			valid_open = 0;
		}
#else
		if (fdisk(fdisk_dev, fdp)) {
			fdp[WHOLE_DRIVE].p_size = ssp->capacity;
			fdp[WHOLE_DRIVE].p_base = 0;
			ssp->ptab_read = 1;
		} else {
			u.u_error = ENXIO;
			valid_open = 0;
		}
#endif

	}

	/*
	 * Ensure partition lies within drive boundaries and is non-zero size.
	 */
	if (valid_open && partn != WHOLE_DRIVE
	&& (fdp[partn].p_base+fdp[partn].p_size) > fdp[WHOLE_DRIVE].p_size) {
		u.u_error = EBADFMT;
		valid_open = 0;
	}

	if (valid_open && partn != WHOLE_DRIVE && fdp[partn].p_size == 0) {
		u.u_error = ENODEV;
		valid_open = 0;
	}

	/*
	 * OK to open the device.
	 * Start watchdog timer (if not already started) for the host adapter.
	 */
	if (valid_open) {
		++drvl[SCSI_MAJOR].d_time;
		++ssp->dr_watch;
	}
}

/*
 * ssclose()
 */
static void ssclose(dev)
dev_t dev;
{
	ss_type * ssp;
	int s_id;

	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];

	/*
	 * Decrement the number of watchdog timer requests open for host
	 * adapter and for target.
	 */
	--drvl[SCSI_MAJOR].d_time;	
	--ssp->dr_watch;

#if (DEBUG >= 3)
devmsg(dev, "ssclose");
#endif

}

/*
 * ssread()	- read a block from the raw disk
 *
 *	Input:	dev = disk device to be written to.
 *		iop = pointer to source I/O structure.
 *
 *	Action:	Invoke the common raw I/O processing code.
 */
static void ssread(dev, iop)
dev_t	dev;
IO	*iop;
{
	ioreq( &dbuf, iop, dev, BREAD, BFRAW|BFBLK|BFIOC );
}

/*
 * sswrite()	- write a block to the raw disk
 *
 *	Input:	dev = disk device to be written to.
 *		iop = pointer to source I/O structure.
 *
 *	Action:	Invoke the common raw I/O processing code.
 */
static void sswrite(dev, iop)
dev_t	dev;
IO	*iop;
{
	ioreq( &dbuf, iop, dev, BWRITE, BFRAW|BFBLK|BFIOC );
}

/*
 * ssioctl()
 *
 *	Input:	dev = disk device to be operated on.
 *		cmd = input/output request to be performed.
 *		vec = (pointer to) optional argument.
 *
 *	Action:	Validate the minor device.
 *		Update the paritition table if necessary.
 */

static int ssioctl(dev, cmd, vec)
register dev_t	dev;
int cmd;
char * vec;
{
	int ret = 0;
	hdparm_t hdparm;
	struct	fdisk_s	*fdp;
	int s_id;
	ss_type * ssp;

	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	fdp = ssp->parmp;

	switch(cmd) {
	case HDGETA:
PR3("HDGETA ");
		fdp = ssp->parmp;
		*(short *)&hdparm.landc[0] =
		*(short *)&hdparm.ncyl[0] = drv_parm[s_id].ncyl;
		hdparm.nhead = drv_parm[s_id].nhead;
		hdparm.nspt = drv_parm[s_id].nspt;
#if (DEBUG >= 3)
printf("ncyl=%d nhead=%d nspt=%d\n",
  hdparm.ncyl[0]+((int)hdparm.ncyl[1]<<8), (int)hdparm.nhead, (int)hdparm.nspt);
#endif
		kucopy( &hdparm, vec, sizeof hdparm );
		ret = 0;
		break;
	default:
		u.u_error = EINVAL;
		ret = -1;
	}

	return ret;
}

/*
 * ssblock()	- queue a block to the disk
 *
 *	Input:	bp = pointer to block to be queued.
 *
 *	Action:	Queue a block to the disk.
 *		Make sure that the transfer is within the disk partition.
 */
static void ssblock(bp)
register BUF	*bp;
{
	struct	fdisk_s	*fdp;
	int partition, drive, s_id;
	dev_t dev;
	ss_type * ssp;

	/*
	 * Set up local variables.
	 */
	dev = bp->b_dev;
	partition = DEV_PARTN(dev);
	drive = DEV_DRIVE(dev);
	s_id = DEV_SCSI_ID(dev);
	ssp = ss[s_id];
	if (dev & SDEV)
		partition = WHOLE_DRIVE;
	fdp = ssp->parmp;

	bp->b_resid = bp->b_count;

	/*
	 * Range check disk region.
	 */
	if (!(ssp->ptab_read)) {
		if ( partition == WHOLE_DRIVE ) {
			if ((bp->b_bno != 0) || (bp->b_count != BSIZE)) {
PR1("BF1 ");
				bp->b_flag |= BFERR;
				goto bad_open;
			}
		} else {
PR2("BF2 ");
			devmsg(dev, "no partition table");
			bp->b_flag |= BFERR;
			goto bad_open;
		}
	}

	/*
	 * Check for read at end of partition.
	 * (Need to return with b_resid = BSIZE to signal end of volume.)
	 */
	else if ((bp->b_req == BREAD) && (bp->b_bno == fdp[partition].p_size)) {
		goto bad_open;
	}

	/*
	 * Check for read past end of partition.
	 */
	else if ( (bp->b_bno + (bp->b_count/BSIZE))
	> fdp[partition].p_size ) {
PR3("BF3 ");
		bp->b_flag |= BFERR;
		goto bad_open;
	}

	/*
	 * Fail if request is for zero bytes or is not even # of blocks.
	 */
	if ((bp->b_count % BSIZE) || bp->b_count == 0) {
		bp->b_flag |= BFERR;
		goto bad_open;
	}

	/*
	 * Operation appears valid.
	 * Fill fields in the node and queue the request.
	 */
	bufq_wr_tail(s_id, bp);
	ss_mach(s_id);
	goto end_open;

	/*
	 * Operation cannot be done.  Release the kernel buffer structure.
	 * Value of "bp->b_flag" tells caller if error occurred.
	 */
bad_open:
		bdone(bp);

end_open:
	return;
}

/*
 * ssintr()	- Interrupt routine.
 *
 * If we have been reselected by a recognized target device
 *	let kernel get out of interrupt mode (defer) and do SCSI
 *	reconnect stuff.
 */
static void ssintr()
{
	int s_id;

	s_id = chk_reconn();
	if (s_id != -1) {
		defer(ss_mach, s_id);
PR3("!");
	}
}

/*
 * sswatch()
 *
 * Invoked once per second if any devices going through this driver are open.
 * Poll for any reselect, in case interrupt got lost.
 */
static void sswatch()
{
	int s_id;
	ss_type * ssp;

	for (s_id = 0; s_id < MAX_SCSI_ID-1; s_id++) {
		ssp = ss[s_id];
		if (ssp && ssp->dr_watch)
			defer(ss_mach, s_id);
	} /* endfor */
}

/*
 * bus_wait()
 *
 * Wait for specified bit values to appear in Status Register.
 * This uses a tight loop and does not expect to be interrupted.
 *
 * Argument "flags" is a double-byte value;  the high byte is ANDed with
 * status register contents, and the result is tested for equality with
 * the low byte.
 *
 * Return 1 if values wanted appeared, 0 if timeout occurred.
 */
static int bus_wait(flags)
unsigned short flags;
{
	int found, i;
	unsigned char status;

	found = 0;
	for ( i = 0; i < HIPRI_RETRIES; i++) {
		status = ffbyte(ss_csr);
		if ((status & (flags >> 8)) == (flags & 0xff)) {
			found = 1;
			break;
		}
	}

#if (DEBUG >= 1)
	if (!found)
		printf("TO:f=%x s=%x ", flags, status);
#endif

	return found;
}

/*
 * ssinit()
 *
 * Attempt to initialize the (unique) drive with a given SCSI id.
 * Assume only one drive per SCSI id, having LUN = 0.
 * 
 * Return 1 if success, 0 if failure.
 */
static int ssinit(s_id)
int s_id;
{
	int retval = 1;
	uchar query_buf[MODESENSELEN];
	ss_type * ssp = ss[s_id];
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));

	if (retval)
		if (inquiry(s_id, query_buf)) {
			query_buf[INQUIRYLEN] = 0;
#if (debug >= 2)
			devmsg(dev, query_buf + 8);
#endif
			if (query_buf[0] == 0) {
				retval = 1;
			} else
				devmsg(dev, "Not Direct Access Device");
		} else
			devmsg(dev, "Inquiry Failed");

	if (retval)
		if (read_cap(s_id, query_buf)) {
			retval = 1;
			ssp->capacity = query_buf[3] | (query_buf[2] << 8)
			| (((long)(query_buf[1])) << 16)
			| (((long)(query_buf[0])) << 24);
			ssp->blocklen = query_buf[7] | (query_buf[6] << 8)
			| (((long)(query_buf[5])) << 16)
			| (((long)(query_buf[4])) << 24);
#if (DEBUG >= 3)
printf("capacity=%ld   block length=%ld\n", ssp->capacity, ssp->blocklen);
#endif
		} else
			devmsg(dev, "Read Capacity Failed");

	if (retval)
		if (mode_sense(s_id, query_buf)) {
#if (DEBUG >= 3)
#define FMT_PG	(4+8+8+12)
#define DDG_PG	(4+8+8+12+24)

uchar heads;
unsigned short spt;
ulong cyls;

spt=((int)query_buf[FMT_PG+10]<<8) + query_buf[FMT_PG+11];
cyls=((int)query_buf[DDG_PG+2]<<16) + ((int)query_buf[DDG_PG+3]<<8) + query_buf[DDG_PG+4];
heads=query_buf[DDG_PG+5];
printf("%d sectors per track\n", spt);
printf("%ld cylinders\n", cyls);
printf("%d heads\n", heads);
#endif
		} else
			devmsg(dev, "Mode Sense Failed");

	return retval;
}

/*
 * far_info_xfer()
 *
 * Do bus cycle information transfer phases.
 * This includes message in/out, command in/out, and data in/out.
 *
 * If cmdlen is nonzero, cmdbuf is an array of bytes of that length,
 * to be sent to the target.
 *
 * Return 1 if bus timeout did not occur, else 0.
 *
 * pseudocode:
 *
 * while (wait for REQ true or BUSY false on SCSI bus)
 *   if (BUSY false)
 *     break from while loop
 *   else
 *     switch (xfer phase = RS_CTRL_DATA|RS_I_O|RS_MESSAGE)
 *       case XP_MSG_IN/XP_MSG_OUT/...
 *         handle the indicated information transfer phase
 *     endswitch
 *   endif
 * endwhile
 */
static int far_info_xfer(s_id)
int s_id;
{
	int bus_timeout;
	uchar phase_type;
	uchar msg_in;
	int s;
	int bytes_to_send;
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int xfer_good = 1;
	int xfer_count = bp->b_count - bp->b_resid;
	int i = 0;

	ssp->cmd_bytes_out = 0;
	ssp->msg_in = -1;
	s = sphi();
	while (req_wait(&bus_timeout) && xfer_good) {
		phase_type = ffbyte(ss_csr) & (RS_MESSAGE|RS_I_O|RS_CTRL_DATA);
		switch (phase_type) {
		case XP_MSG_IN:
			msg_in = ffbyte(ss_dat);
			switch(msg_in){
			case MSG_CMD_CMPLT:
				ssp->msg_in = msg_in;
				sfbyte(ss_csr, WC_ENABLE_IRPT);
				break;
			case MSG_SAVE_DPTR:
				break;
			case MSG_RSTOR_DPTR:
				break;
			case MSG_DISCONNECT:
				ssp->msg_in = msg_in;
				sfbyte(ss_csr, WC_ENABLE_IRPT);
				break;
			case MSG_ABORT:
				break;
			case MSG_DEV_RESET:
				break;
			case MSG_IDENTIFY:
				break;
			case MSG_IDENT_DC:
				break;
			}
			break;
		case XP_MSG_OUT:
			/*
			 * This case shouldn't happen.  We weren't
			 * asserting ATTENTION.  Abort the bus cycle.
			 */
			sfbyte(ss_csr, WC_ENABLE_SCSI);
			sfbyte(ss_dat, MSG_ABORT); 
			break;
		case XP_STAT_IN:
			ssp->cmdstat = ffbyte(ss_dat);
			break;
		case XP_CMD_OUT:
			/*
			 * Ship out command bytes.
			 * Reset SCSI bus if too many command bytes are wanted.
			 */
			bytes_to_send = ssp->cmdlen - ssp->cmd_bytes_out;
			if(bytes_to_send > 0) {
				sfbyte(ss_dat, ssp->cmdbuf[ssp->cmd_bytes_out++]);
				/*
				 * If just sent last byte, allow interrupts.
				 */
				if (bytes_to_send == 1) {
					spl(s);
					s = sphi();
				}
			} else {	/* This case should not happen. */
				xfer_good = 0;
			}
			break;
		case XP_DATA_IN:
			/*
			 * If caller's buffer has room, keep incoming
			 * data byte.  Else toss it.
			 */
			if (bp->b_req == BREAD)
				ss_get(ss_fp, bp->b_faddr + xfer_count, BSIZE);
			else
				xfer_good = 0;
			break;
		case XP_DATA_OUT:
			/*
			 * Copy output buffer bytes to data register.
			 */
			if (bp->b_req == BWRITE) {
				uchar dat;

				dat = ffbyte(bp->b_faddr + xfer_count + i);
				sfbyte(ss_dat, dat);
				i++;
			} else /* This case should not happen. */
				xfer_good = 0;
			break;
		default:
			break;
		} /* endswitch */
	}
	spl(s);
#if (DEBUG >= 1)
switch(ssp->cmdstat) {
case -1:
	if (msg_in != MSG_DISCONNECT)
		printf("CS-",ssp->cmdstat);
	break;
case CS_GOOD:
	break;
case CS_CHECK:
	printf("CSK",ssp->cmdstat);
	break;
case CS_BUSY:
	printf("CSY",ssp->cmdstat);
	break;
case CS_RESERVED:
default:
	printf("CS%x",ssp->cmdstat);
#endif
}
	return (bus_timeout) ? 0 : 1 ;
}

/*
 * req_wait()
 *
 * This routine is called at the start of each information transfer
 * phase and after the last such phase.
 *
 * It returns 1 if REQ is asserted on the SCSI bus, meaning another phase
 * may begin, and 0 otherwise.  A REQ signal will not be seen if the function
 * times out or if BUSY drops.  A value of 1 is written to the pointer argument
 * if timeout occurred, else 0 is written.
 */
static int req_wait(to_ptr)
int *to_ptr;
{
	int req_found, i;
	unsigned char status;

	*to_ptr = 1;
	req_found = 0;
	for (i = 0; i < HIPRI_RETRIES; i++) {
		status = ffbyte(ss_csr);
		if (status & RS_REQUEST) {
			req_found = 1;
			*to_ptr = 0;
			break;
		} else if ((status & RS_BUSY) == 0) {
			*to_ptr = 0;
			break;
		}
	}

#if (DEBUG >= 1)
	if (*to_ptr) {
		printf("TX: s=%x ", status);
	}
#endif

	return req_found;
}

/*
 * req_sense()
 *
 * Request Sense for a device.  The main reason for doing this is to
 * clear a standing Command Status of Device Check.
 *
 * Full results are discarded.  Return 1 if Device returns No Sense or
 * or Unit Attention.  Else return 0.
 *
 */
static int req_sense(s_id)
int s_id;
{
	uchar sense_buf[SENSELEN];
	uchar cmdbuf[G0CMDLEN];
	int ret = 0;

	cmdbuf[0] = ScmdREQUESTSENSE;
	cmdbuf[1] = 0;
	cmdbuf[2] = 0;
	cmdbuf[3] = 0;
	cmdbuf[4] = SENSELEN;
	cmdbuf[5] = 0;

	if (start_arb() && host_ident(s_id, 0) &&
	local_info_xfer(cmdbuf, G0CMDLEN, sense_buf, SENSELEN, NULL, 0)) {
		if (sense_buf[2] == 0x00)	/* No Sense.  AOK */
			ret = 1;
		else if (sense_buf[2] == 0x06 && sense_buf[12] == 0x29)
			ret = 1;
	}

	return ret;
}

/*
 * inquiry()
 *
 * Inquiry command for a device.
 * Find out if device is direct access, removable, etc.
 *
 * Put result of inquiry into supplied buffer.
 * Return 1 if command succeeds, else 0.
 */
static int inquiry(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	uchar cmdbuf[G0CMDLEN];

	cmdbuf[0] = ScmdINQUIRY;
	cmdbuf[1] = 0;
	cmdbuf[2] = 0;
	cmdbuf[3] = 0;
	cmdbuf[4] = INQUIRYLEN;
	cmdbuf[5] = 0;

	if (start_arb() && host_ident(s_id, 0) &&
	local_info_xfer(cmdbuf, G0CMDLEN, buf, INQUIRYLEN, NULL, 0))
		ret = 1;

	return ret;
}

/*
 * mode_sense()
 *
 * Mode Sense command for a device.
 * Use this to get disk parameters:
 *	number of cylinders
 *	number of heads
 *	number of sectors per track.
 *
 * Put result of mode sense into supplied buffer.
 * Return 1 if command succeeds, else 0.
 */
static int mode_sense(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	uchar cmdbuf[G0CMDLEN];

	cmdbuf[0] = ScmdMODESENSE;
	cmdbuf[1] = 0;
	cmdbuf[2] = 0x3F;
	cmdbuf[3] = 0;
	cmdbuf[4] = MODESENSELEN;
	cmdbuf[5] = 0;

	if (start_arb() && host_ident(s_id, 0) &&
	local_info_xfer(cmdbuf, G0CMDLEN, buf, MODESENSELEN, NULL, 0))
		ret = 1;

	return ret;
}

/*
 * read_cap()
 *
 * Read Capacity command for a device.
 *
 * Return 1 if command succeeds, else 0.
 */
static int read_cap(s_id, buf)
int s_id;
uchar * buf;
{
	int ret = 0;
	uchar cmdbuf[G1CMDLEN];

	cmdbuf[0] = ScmdREADCAPACITY;
	cmdbuf[1] = 0;
	cmdbuf[2] = 0;
	cmdbuf[3] = 0;
	cmdbuf[4] = 0;
	cmdbuf[5] = 0;
	cmdbuf[6] = 0;
	cmdbuf[7] = 0;
	cmdbuf[8] = 0;
	cmdbuf[9] = 0;

	if (start_arb() && host_ident(s_id, 0) &&
	local_info_xfer(cmdbuf, G1CMDLEN, buf, READCAPLEN, NULL, 0))
		ret = 1;

	return ret;
}

/*
 * bus_dev_reset()
 *
 * Send Bus Device Reset message to the given SCSI id.
 * Return 1 if host adapter was not busy and no obvious timeouts occurred,
 * else 0.
 */
static int bus_dev_reset(s_id)
{
	int bdr_ok = 1;
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));

PR1("bdr");

	if (bdr_ok) {
		/*
		 * Do ST0x arbitration.
		 */
		sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
		sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
		sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */

		/*
		 * SCSI spec says there is "no maximum" to the wait for
		 * arbitration complete.
		 */
		if (!bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL)) {
			bdr_ok = 0;
		}
	}

	/*
	 * Arbitration complete.  Now select, with ATN to allow messages.
	 */
	if (bdr_ok) {
		sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);

		if (!bus_wait(RS_BUSY << 8 | RS_BUSY))
			bdr_ok = 0;
	}

	if (bdr_ok) {
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);

		if (!bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
			bdr_ok = 0;
	}

	if (bdr_ok) {
		sfbyte(ss_csr, WC_ENABLE_SCSI);
		sfbyte(ss_dat, MSG_DEV_RESET);
		if (!bus_wait((0xFF << 8) | 0))
			bdr_ok = 0;
	}

	return bdr_ok;
}

/*
 * chk_reconn()
 *
 * Check SELECT to see if any SCSI device has tried to reconnect to the host
 * adapter.  Called if there is an interrupt, and by the timer in case
 * we somehow lose an interrupt.
 *
 * Return -1 if no reselect detected, or the SCSI ID of the reselecting
 * target if there is one.
 */
static int chk_reconn()
{
	uchar csr, dat;
	int s_id = -1;

	csr = ffbyte(ss_csr);
	if (csr & (RS_SELECT | RS_I_O)) {
		dat = ffbyte(ss_dat);
		if ((dat & HOST_ID) && (dat & NSDRIVE)) {
			dat &= ~HOST_ID;
			s_id = 0;
			while (dat >>=1)
				s_id++;
		}
	}

	return s_id;
}

/*
 * ss_mach()
 *
 *	Gives a distinct state machine for each target device.
 */
void	ss_mach(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp;
	int s;

	do_sst_op = 1; /* plan to run this routine again in most cases */
	while (do_sst_op) {
		bp = ssp->bp;  /* nonpolled() below can change ssp->bp */
		switch (ssp->state) {
		/*
		 * Polling states execute whether ssp->waiting or not.
		 */
		case SST_POLL_ARBITN:
PR3("PA ");
			if (ffbyte(ss_csr) & RS_ARBIT_COMPL) {
				ssp->waiting = 0;
				if (host_ident(s_id, 1))
					do_connect(s_id);
				else
					recover(s_id, RV_P_TIMEOUT);
			} else {
				if (ssp->expired) {
					ssp->expired = 0;
					recover(s_id, RV_A_TIMEOUT);
				} else
					do_sst_op = 0;
			}
			break;
		case SST_POLL_BEGIN_IO:
PR3("PBI ");
			if (bp == NULL)
				ssp->state = SST_DEQUEUE;
			else {
				/*
				 * At this point a SCSI command is about to
				 * be initiated.  It may be a retry.
				 */
				if (host_claimed == -1 && BUS_FREE && BUS_FREE) {
					host_claimed = s_id;
					ssp->waiting = 0;
					init_pointers(s_id);
					s=sphi();
					if (start_arb()) {
						if (host_ident(s_id, 1)) {
							do_connect(s_id);
							spl(s);
						} else {
							spl(s);
							recover(s_id, RV_P_TIMEOUT);
						}
					} else {
						spl(s);
						ssp->state = SST_POLL_ARBITN;
						set_timeout(s_id, DELAY_ARB);
					}
				} else { /* host busy or bus not free */
					++ssp->avl_count;
					if (ssp->avl_count >= MAX_AVL_COUNT)
						recover(s_id, RV_BF_TIMEOUT);
					else
						set_timeout(s_id, DELAY_BSY);
				}
			}
			break;
		case SST_POLL_RESELECT:
PR3("PR ");
			if (TGT_RSEL) {
				ssp->waiting = 0;
				s=sphi();
				if (rsel_handshake()) {
					do_connect(s_id);
					spl(s);
				} else {
					spl(s);
					recover(s_id, RV_P_TIMEOUT);
				}
			} else  { /* Reselect poll is negative */
				if (ssp->expired) {
					ssp->expired = 0;
					recover(s_id, RV_R_TIMEOUT);
				} else
					do_sst_op = 0;
			}
			break;
		default:
			if (ssp->waiting)
				do_sst_op = 0;
			else {
				/*
				 * Nonpolling states execute only if no
				 * target timer is running.
				 */
				nonpolled(s_id);
			}
		} /* endswitch */
	} /* endwhile */
}

/*
 * nonpolled()
 *
 * Part of ss_mach() - handling of nonpolling states is taken out simply
 * for readability.
 */
static void nonpolled(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	struct	fdisk_s	*fdp;
	int partition;
	dev_t dev;

	switch (ssp->state) {
	case SST_BUS_DEV_RESET:
PR3("BDR ");
		if (bus_dev_reset(s_id)) {
			do_sst_op = 0;
			set_timeout(s_id, DELAY_BDR);
			ssp->state = SST_REQ_SENSE;
		} else
			recover(s_id, RV_P_TIMEOUT);
		break;
	case SST_DEQUEUE:
		if(bufq_rd_head(s_id) != NULL && !ssp->busy) {
PR3("DQ ");
			ssp->busy = 1;
			bp = bufq_rm_head(s_id);
			ssp->bp = bp;
			dev = bp->b_dev;
			partition = DEV_PARTN(dev);
			if (dev & SDEV)
				partition = WHOLE_DRIVE;
			fdp = ssp->parmp;
			if (partition != WHOLE_DRIVE)
				ssp->bno = fdp[partition].p_base + bp->b_bno;
			else
				ssp->bno = bp->b_bno;
			if (bp->b_req == BREAD)
				ssp->cmdbuf[0] = ScmdREADEXTENDED;
			else
				ssp->cmdbuf[0] = ScmdWRITEXTENDED;
			ssp->cmdbuf[1] = 0;
			ssp->cmdbuf[2] = ssp->bno >> 24;
			ssp->cmdbuf[3] = ssp->bno >> 16;
			ssp->cmdbuf[4] = ssp->bno >>  8;
			ssp->cmdbuf[5] = ssp->bno;
			ssp->cmdbuf[6] = 0;
			ssp->cmdbuf[7] = 0;
			ssp->cmdbuf[8] = 1;
			ssp->cmdbuf[9] = 0;
			ssp->cmdlen = G1CMDLEN;
			init_pointers(s_id);
			ssp->bdr_count = 0;
			ssp->bsy_count = 0;
			ssp->try_count = 0;
			ssp->state = SST_POLL_BEGIN_IO;
		} else /* queue is empty or ssp->busy */
			do_sst_op = 0;
		break;
	case SST_HIPRI_RESET:
	case SST_LOPRI_RESET:
PR1("rst");
if ((ffbyte(ss_csr) & (RS_MESSAGE|RS_I_O|RS_CTRL_DATA)) == XP_MSG_OUT) {
	printf("honk");
	sfbyte(ss_csr, WC_ENABLE_SCSI);
	sfbyte(ss_dat, MSG_ABORT); 
}
		/*
		 * SST_LOPRI_RESET is same as SST_HIPRI_RESET for now.
		 * Later, can implement a delay to allow other targets to
		 * finish pending operations.
		 */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET); /* reset ON */
		ssp->state = SST_RESET_OFF;
		set_timeout(s_id, DELAY_RST);
		break;
	case SST_REQ_SENSE:
PR1("RQS ");
		if (req_sense(s_id))
			ssp->state = SST_POLL_BEGIN_IO;
		else
			recover(s_id, RV_P_TIMEOUT);
		break;
	case SST_RESET_DONE:
PR3("RDN ");
		ssp->state = SST_POLL_BEGIN_IO;
		break;
	case SST_RESET_OFF:
PR3("RFF ");
		sfbyte(ss_csr, 0); /* reset OFF */
		ssp->state = SST_RESET_DONE;
		set_timeout(s_id, DELAY_RST);
	} /* endswitch */
}

/*
 * start_arb()
 *
 * return 1 if host adapter returned Arbitration Complete within allotted
 * number of tries, else 0
 */
static int start_arb()
{
	sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
	sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
	sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */

	/*
	 * SCSI spec says there is "no maximum" to the wait for arbitration
	 * complete.
	 */
	return bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL);
}

/*
 * host_ident()
 *
 * This routine is the bridge in a SCSI bus cycle between Abitration
 * Complete and the Information Transfer phases.
 *
 * return 1 if everything went ok, 0 in case of timeout
 */
static int host_ident(s_id, disconnect)
int s_id;
int disconnect;
{
	int ret = 0;

	/*
	 * Arbitration complete.  Now select, with ATN to allow messages.
	 */
	sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);

	if (bus_wait(RS_BUSY << 8 | RS_BUSY)) {
		/*
		 * Assert ATTN so target expects incoming message byte.
		 */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);

		if (bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE))) {
			if (disconnect)
				sfbyte(ss_dat, MSG_IDENT_DC);
			else
				sfbyte(ss_dat, MSG_IDENTIFY);
			sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ENABLE_IRPT);
			ret = 1;
		}
	}
	return ret;
}

/*
 * rsel_handshake()
 *
 * After Reselect is detected, a couple steps are needed before entering
 * Information Transfer phases.  This routine does those steps.
 *
 * return 1 if ok, 0 in case of timeout.
 */
static int rsel_handshake()
{
	int ret = 0;

	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_BUSY);
	if (bus_wait(RS_SELECT << 8 | 0)) {
		sfbyte(ss_csr, WC_ENABLE_SCSI);
		ret = 1;
	}
	return ret;
}

/*
 * set_timeout()
 *
 * Start a timer so as not to wait forever in case something goes wrong while
 * waiting for an event.  Available delays are:
 *
 * 	DELAY_ARB -	wait for arbitration complete
 * 	DELAY_BDR -	allow settling time after Bus Device Reset
 * 	DELAY_BSY -	wait for not HOST_BUSY and bus free
 * 	DELAY_RES -	wait for reselect by target
 * 	DELAY_RST -	allow settling times when doing SCSI Bus Reset
 *
 * Second argument is number of clock ticks to wait until timer expiration.
 */
static void set_timeout(s_id, delay)
int s_id, delay;
{
	ss_type * ssp = ss[s_id];

	ssp->expired = 0;
	ssp->waiting = 1;
	do_sst_op =  0;
	timeout(&(ssp->tim), delay, stop_timeout, s_id);
}

/*
 * stop_timeout()
 *
 * Called on expiration of the timer for a given target.
 * Don't expire a timer if it's no longer active.
 */
static void stop_timeout(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];

	if (ssp->waiting) {
		ssp->expired = 1;
		ssp->waiting = 0;
	}
	ss_mach(s_id);
}

/*
 * init_pointers()
 *
 * Initialize command and data pointers when starting (or restarting)
 * a block i/o command.
 */
static void init_pointers(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;

	ssp->cmdstat = -1;
	ssp->cmd_bytes_out = 0;
	ssp->avl_count = 0;
}

/*
 * recover()
 *
 * This routine is called directly or indirectly from ss_mach().  It
 * determines what to do when the interface fails to behave as desired.
 *
 * Arguments are the SCSI id of the target HDC and an error type.
 * Error types are:
 *
 * RV_A_TIMEOUT (arbitration timeout)
 * Host adapter takes too long to respond with arbitration complete.
 * 
 * RV_P_TIMEOUT (protocol timeout)
 * Timeout waiting for desired SCSI bus status while connected to a target.
 * 
 * RV_R_TIMEOUT (reconnect timeout)
 * Timeout after target disconnects, waiting for reconnect.
 * 
 * RV_BF_TIMEOUT (bus free timeout)
 * Waited too long for host not busy and BUS_FREE.
 * 
 * RV_CS_BUSY (target device busy)
 * Command status returned was Busy.
 * 
 * RV_CS_CHECK (target device check)
 * Command status returned was CHECK.
 * 
 * Whenever an error occurs, one of the above inputs, together with the SCSI id
 * of the target, is sent to the recovery process.  The recovery process in turn
 * programs the next state for the machine.
 */
static void recover(s_id, errtype)
int s_id;
RV_TYPE errtype;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;

	++ssp->try_count;
	if (ssp->try_count < MAX_TRY_COUNT) {

		switch (errtype) {

		case RV_CS_BUSY:
			++ssp->bsy_count;
			if (ssp->bsy_count < MAX_BSY_COUNT) {
				ssp->state = SST_POLL_BEGIN_IO;
				set_timeout(s_id, DELAY_BSY);
			} else
				ssp->state = SST_BUS_DEV_RESET;
			break;

		case RV_CS_CHECK:
			ssp->state = SST_REQ_SENSE;
			break;

		case RV_P_TIMEOUT:
			/* fall thru */
		case RV_R_TIMEOUT:
			++ssp->bdr_count;
			if (ssp->bdr_count < MAX_BDR_COUNT)
				ssp->state = SST_BUS_DEV_RESET;
			else
				ssp->state = SST_LOPRI_RESET;
			break;

		case RV_BF_TIMEOUT:
			host_claimed = -1;
			/* fall thru */
		case RV_A_TIMEOUT:
			ssp->state = SST_HIPRI_RESET;
		}
	} else { /* try_count >= MAX_TRY_COUNT */
		if (bp) {
			bp->b_flag |= BFERR;
PR3("BF4 ");
		}
		ss_finished(s_id);
	}
}

/*
 * ss_finished
 *
 * Release current i/o buffer to the O/S.
 */
static void ss_finished(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int go_again = 1;

	if (host_claimed == s_id)
		host_claimed = -1;
	ssp->busy = 0;
	if (bp) {
		if (!(bp->b_flag & BFERR))
			bp->b_resid -= BSIZE;
		if ((bp->b_flag & BFERR) || bp->b_resid == 0) {
			ssp->bp = NULL;
			bdone(bp);
			go_again = 0;
		}
	}
	if (go_again) {
		ssp->state = SST_POLL_BEGIN_IO;
		ssp->bdr_count = 0;
		ssp->bsy_count = 0;
		ssp->try_count = 0;
	} else
		ssp->state = SST_DEQUEUE;
}

/*
 * do_connect()
 *
 * This function is called when the host is successfully connected to
 * the target.
 */
static void do_connect(s_id)
int s_id;
{
	int result;
	ss_type * ssp = ss[s_id];

	result = far_info_xfer(s_id);
	if (host_claimed == s_id)
		host_claimed = -1;
	if (!result)
		recover(s_id, RV_P_TIMEOUT);
	else if (ssp->msg_in == MSG_DISCONNECT) {
		ssp->state = SST_POLL_RESELECT;
		set_timeout(s_id, DELAY_RES);
	} else if (ssp->msg_in == MSG_CMD_CMPLT && ssp->cmdstat == CS_GOOD)
		ss_finished(s_id);
	else if (ssp->cmdstat == CS_BUSY)
		recover(s_id, RV_CS_BUSY);
	else if (ssp->cmdstat == CS_CHECK)
		recover(s_id, RV_CS_CHECK);
	else  /* something else went wrong */
		recover(s_id, RV_P_TIMEOUT);
}

/*
 * local_info_xfer()
 *
 * Do bus cycle information transfer phases.
 * Transfer is for a command which will produce local results in the driver.
 * Other ...info_xfer routine handles kernel block i/o commands.
 *
 * Return 1 if transfer succeeded, else 0.
 *
 */
static int local_info_xfer(cmdbuf, cmdlen, inbuf, inlen, outbuf, outlen)
uchar * cmdbuf, * inbuf, * outbuf;
uint cmdlen, inlen, outlen;
{
	int bus_timeout;
	uchar phase_type;
	int s;
	int cmd_bytes_out = 0;
	int data_bytes_in = 0;
	int data_bytes_out = 0;
	int ret = 0;
	int xfer_good = 1;
	int cmdstat = -1;
	int msg_in = -1;

	s = sphi();
	while (req_wait(&bus_timeout) && xfer_good) {
		phase_type = ffbyte(ss_csr) & (RS_MESSAGE|RS_I_O|RS_CTRL_DATA);
		switch (phase_type) {
		case XP_MSG_IN:
			msg_in = ffbyte(ss_dat);
			switch(msg_in){
			case MSG_CMD_CMPLT:
			case MSG_DISCONNECT:
				sfbyte(ss_csr, WC_ENABLE_IRPT);
				break;
			}
			break;
		case XP_MSG_OUT:
			/*
			 * This case shouldn't happen.  We weren't
			 * asserting ATTENTION.  Abort the bus cycle.
			 */
			sfbyte(ss_csr, WC_ENABLE_SCSI);
			sfbyte(ss_dat, MSG_ABORT); 
			break;
		case XP_STAT_IN:
			cmdstat = ffbyte(ss_dat);
			break;
		case XP_CMD_OUT:
			/*
			 * Ship out command bytes.
			 */
			if (cmd_bytes_out < cmdlen) {
				sfbyte(ss_dat, cmdbuf[cmd_bytes_out++]);
				/*
				 * If just sent last byte, allow interrupts.
				 */
				if (cmd_bytes_out == cmdlen) {
					spl(s);
					s = sphi();
				}
			} else {	/* This case should not happen. */
				xfer_good = 0;
			}
			break;
		case XP_DATA_IN:
			/*
			 * If caller's buffer has room, keep incoming
			 * data byte.  Else toss it.
			 */
			if (data_bytes_in < inlen) {
				inbuf[data_bytes_in++] = ffbyte(ss_dat);
			} else
				ffbyte(ss_dat);
			break;
		case XP_DATA_OUT:
			/*
			 * Copy output buffer bytes to data register.
			 */
			if (data_bytes_out < outlen) {
				sfbyte(outbuf[data_bytes_out++], ss_dat);
			} else { /* This case should not happen. */
				xfer_good = 0;
			}
			break;
		default:
			break;
		} /* endswitch */
	}
	spl(s);

	if (!bus_timeout && xfer_good && cmdstat == CS_GOOD)
		ret = 1;

	host_claimed = -1;
	return ret;
}
@


1.45
log
@Still trying to test ss_get.  Always hangs.
@
text
@a11 1
 *	mask interrupts on finishing arbitration, etc.
d17 3
a165 2
	int	data_bytes_in;
	int	data_bytes_out;
a626 1
	int valid_op = 1;
d640 2
d650 1
a650 1
				valid_op = 0;
d656 1
a656 1
			valid_op = 0;
d659 1
d665 1
a665 1
		valid_op = 0;
d667 1
d675 1
a675 1
		valid_op = 0;
d679 8
d690 4
a693 4
	if (valid_op) {
		bufq_wr_tail(s_id, bp);
		ss_mach(s_id);
	}
d698 1
a698 1
	else { 	/* "valid_op" is FALSE */
d700 3
a702 1
	}
d878 2
a879 1
int first=1;
d947 4
a950 23
if (bp->b_req == BREAD) {
	if (first) {
		first=0;
		printf("ss_fp=%lx ", ss_fp);
		printf("buf_f=%lx resid=%d ", bp->b_faddr, bp->b_resid);
	}
#if 0
	if (bp->b_resid <= SS_DAT_LEN) {
		ss_get(ss_fp, bp->b_faddr, (uint)bp->b_resid);
printf("word 1FC = %x\n", ffword(bp->b_faddr+0x1fc));
ssp->data_bytes_in += bp->b_resid;
	} else
#endif
			if (ssp->data_bytes_in < bp->b_count) {
				uchar dat;

				dat = ffbyte(ss_dat);
				sfbyte(bp->b_faddr + ssp->data_bytes_in, dat);
				ssp->data_bytes_in++;
			} else
				ffbyte(ss_dat);
} else
	xfer_good = 0;
d956 1
a956 2
if (bp->b_req == BWRITE) {
			if (ssp->data_bytes_out < bp->b_count) {
d959 1
a959 1
				dat = ffbyte(bp->b_faddr + ssp->data_bytes_out);
d961 2
a962 2
				ssp->data_bytes_out++;
			} else { /* This case should not happen. */
a963 3
			}
} else
	xfer_good = 0;
d1406 2
a1407 2
			ssp->cmdbuf[7] = bp->b_count / (BSIZE * 256L);
			ssp->cmdbuf[8] = bp->b_count / BSIZE;
a1587 2
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
a1589 3
	if (bp) {
		bp->b_resid = bp->b_count;
	}
d1683 1
d1689 7
a1695 6
		ssp->bp = NULL;
		if (bp->b_req == BREAD)
			bp->b_resid -= ssp->data_bytes_in;
		else
			bp->b_resid -= ssp->data_bytes_out;
		bdone(bp);
d1697 7
a1703 3
	ssp->state = SST_DEQUEUE;
	do_sst_op = 0;
	set_timeout(2);
@


1.44
log
@Drop unneeded fields from ss struct.  Try ss_get().
@
text
@d18 3
d311 1
a311 1

d865 1
d934 7
a940 1
	if (bp->b_resid <= SS_DAT_LEN)
d942 4
a945 1
	else {
a953 1
	}
d1430 5
d1679 1
a1679 1
		if (bp)
d1681 2
@


1.43
log
@Needs assembler I/O most.
@
text
@d18 3
a160 2
	faddr_t	in_buf;
	int	in_buf_len;
a161 2
	faddr_t	out_buf;
	int	out_buf_len;
d860 1
d929 5
a933 1
			if (ssp->data_bytes_in < ssp->in_buf_len && ssp->in_buf) {
d937 1
a937 1
				sfbyte(ssp->in_buf + ssp->data_bytes_in, dat);
d941 3
d949 2
a950 1
			if (ssp->data_bytes_out < ssp->out_buf_len && ssp->out_buf) {
d953 1
a953 1
				dat = ffbyte(ssp->out_buf + ssp->data_bytes_out);
d959 2
a1585 11
		if (bp->b_req == BREAD) {
			ssp->in_buf_len = bp->b_count;
			ssp->in_buf = bp->b_faddr;
			ssp->out_buf_len = 0;
			ssp->out_buf = NULL;
		} else {
			ssp->in_buf_len = 0;
			ssp->in_buf = NULL;
			ssp->out_buf_len = bp->b_count;
			ssp->out_buf = bp->b_faddr;
		}
a1681 1
	ssp->in_buf = ssp->out_buf = NULL;
d1691 2
@


1.42
log
@COH fdisk command gives junk when DEBUG=1, ok if DEBUG=3
@
text
@d18 3
d598 1
a599 1
#endif
d1608 1
a1608 1
 * RV_BF_TIMEOUT (reconnect timeout)
a1685 1
		ssp->state = SST_DEQUEUE;
d1692 1
@


1.41
log
@First working version.
@
text
@a11 1
 *	bus_pre_xfer() -> start_arb() + host_ident()
d18 3
a201 1
static int	bus_pre_xfer();
d826 1
a826 1
 * bus_pre_xfer()
a827 55
 * Do bus cycle phases prior to the information transfer phases.
 * This includes arbitration and selection.
 */
static int bus_pre_xfer(s_id)
int s_id;
{
	int dev = ((sscon.c_mind << 8) | 0x80 | (s_id << 4));
	int ret = 0;

	/*
	 * Do ST0x arbitration.
	 */
	sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
	sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
	sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */

	/*
	 * SCSI spec says there is "no maximum" to the wait for arbitration
	 * complete.
	 */
	if (!bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL)) {
		if (ffbyte(ss_csr) & (RS_REQUEST|RS_BUSY))
			ret = 1;
		goto frotz;
	}

	/*
	 * Arbitration complete.  Now select, with ATN to allow messages.
	 */
	sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);

	if (!bus_wait(RS_BUSY << 8 | RS_BUSY))
		goto frotz;

	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);

	if (!bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
	| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
		goto frotz;

	/*
	 * Disallow Disconnect.
	 */
	sfbyte(ss_dat, MSG_IDENTIFY);
	sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ENABLE_IRPT);
	ret = 1;

frotz:
	return ret;
}

/*
 * far_info_xfer()
 *
d863 1
a863 1
	while(req_wait(&bus_timeout) && xfer_good) {
d1040 1
a1040 1
	if (bus_pre_xfer(s_id) &&
d1074 1
a1074 1
	if (bus_pre_xfer(s_id) &&
d1107 1
a1107 1
	if (bus_pre_xfer(s_id) &&
d1139 1
a1139 1
	if (bus_pre_xfer(s_id) &&
d1258 1
a1258 1
				if (host_ident(s_id))
d1285 1
a1285 1
						if (host_ident(s_id)) {
d1453 1
a1453 1
 * host_ident(s_id)
d1460 1
a1460 1
static int host_ident(s_id)
d1462 1
d1480 4
a1483 1
			sfbyte(ss_dat, MSG_IDENT_DC); /* allow Disconnect */
d1748 1
a1748 1
	while(req_wait(&bus_timeout) && xfer_good) {
@


1.41.1.1
log
@Comment out spl stuff in ss_mach().
@
text
@a18 3
 * Revision 1.41	91/05/15  21:57:55	root
 * First working version.
 * 
d1337 1
a1337 1
/* ZZ					s=sphi(); */
d1341 1
a1341 1
/* ZZ							spl(s); */
d1343 1
a1343 1
/* ZZ							spl(s); */
d1347 1
a1347 1
/* ZZ						spl(s); */
d1364 1
a1364 1
/* ZZ				s=sphi(); */
d1367 1
a1367 1
/* ZZ					spl(s); */
d1369 1
a1369 1
/* ZZ					spl(s); */
@


1.40
log
@First clean compile of state machine version.
@
text
@d5 2
a6 4
 *	local commands: (right now there aren't any!)
 *		local_buf = 0
 *		local_done = 0
 *		local_failed = 0
a7 5
 * Cleanup:
 *	set host_claimed conscientiously
 *	get rid of declarations for deleted functions
 *
 * To try after initial working version:
d15 2
d19 3
d36 23
d62 1
a62 1
#define bufq_wr_tail(s_id, foo)	ssq_wr_head(foo)
a99 1
#define WATCHDOG_SECONDS  4
a100 2
#define IN_BUF_SIZE	512	/* buffer size in "ss" structs */

d120 1
a168 3
	uint	local_buf:1;	/* 1 if command uses local buffer */
	uint	local_done:1;	/* 1 if local command is finished */
	uint	local_fail:1;	/* 1 if local command ended in error */
a212 1
static int	rezero();
a213 3
static int	scsicmd();
static void	scsireset();
static void	ss_done();
a272 3
static TIM	reset_tim;	/* needed for calls to scsireset() */
static TIM	timeout_tim;	/* needed for calls to timeout() */

d411 2
d414 2
d448 3
a450 1
devmsg(fdisk_dev, "calling fdisk");
d452 2
a453 1
int p;
d456 2
a457 2
printf("fdisk() succeeded\n");
for (p=0; p<=WHOLE_DRIVE; p++)
d461 1
a461 1
printf("fdisk() failed\n");
d465 11
d520 2
d523 2
d585 1
a585 1
printf("HDGETA ");
d591 1
d595 1
d641 1
a641 1
printf("BF1 ");
d646 1
a646 1
printf("BF2 ");
d664 1
a664 1
printf("BF3 ");
d698 1
a698 1
	if (s_id != -1)
d700 2
d749 1
d752 1
d776 1
d778 1
d795 1
d797 1
d803 1
d806 5
a810 3
			uchar heads;
			unsigned short spt;
			ulong cyls;
d817 1
d1008 1
d1025 1
d1029 1
d1061 2
a1062 1
	if (*to_ptr)
d1064 2
d1212 1
a1212 1
printf("bdr");
d1298 2
a1299 1
	BUF * bp = ssp->bp;
d1303 1
d1309 1
d1325 2
a1326 1
			if (bp == NULL && ssp->local_buf == 0)
d1337 1
d1339 1
a1339 1
						if (host_ident(s_id))
d1341 3
a1343 1
						else
d1345 1
d1347 1
d1361 1
d1364 2
a1365 1
				if (rsel_handshake())
d1367 3
a1369 1
				else
d1371 1
d1411 1
d1421 1
d1458 1
d1469 1
d1476 1
d1480 1
d1533 1
a1533 8
			/*
			 * If using a local buffer rather than doing a kernel
			 * block i/o request, inhibit Disconnect.
			 */
			if (ss[s_id]->local_buf)
				sfbyte(ss_dat, MSG_IDENTIFY);
			else
				sfbyte(ss_dat, MSG_IDENT_DC);
a1711 3
		if (ssp->local_buf) {
			ssp->local_fail = 1;
		}
a1739 5
	if (ssp->local_buf) {
		ssp->local_buf = 0;
		ssp->local_done = 1;
		ssp->state = SST_POLL_BEGIN_IO;
	}
@


1.40.1.1
log
@Fix 2 bugs in version 1.40
@
text
@a23 3
 * Revision 1.40	91/05/15  15:19:52	root
 * First clean compile of state machine version.
 * 
d41 1
a41 1
#define bufq_wr_tail(s_id, foo)	ssq_wr_tail(foo)
d1247 1
a1247 1
	BUF * bp;
a1250 1
		bp = ssp->bp;
@


1.39
log
@Code recover, do_connect, etc..
@
text
@d2 1
a2 1
 * This is a driver for Seagate ST01/ST02 scsi host adapters.
d5 7
a12 8
 *	if (bp->b_req == BREAD) {...
 *	set host_claimed conscientiously
 *	ss_start() code moved elsewhere
 *	initialize and maintain retry counters
 *	inquiry()
 *	read_cap()
 *	mode_sense()
 *	req_sense() <- called from dblock!!!
d21 1
d24 3
d38 5
a183 1
static int	bus_info_xfer();
d187 1
d191 1
d202 1
a203 3
static void	ss_start();
static void	ss_start_timing();
static void	ss_stop_timing();
a204 1
static void	ssdelay();
a260 1
static TIM	delay_tim;	/* needed for calls to ssdelay() */
a261 1
static TIM	sst_tim;	/* for timeout() call from ss_start() */
a583 1
	register int s;
d641 1
a641 1
		bufq_wr_tail(bp, s_id);
d643 1
d648 1
a648 1
	} else { 	/* "valid_op" is FALSE */
a730 1
	int try;
d780 1
a780 1
 * ssdelay()
a781 16
 * Delay for some number of clock ticks.
 * 286/386 kernel ticks are at 100Hz
 *
 * This routine is of limited use as it can only be called via
 * ssload()/ssunload()/ssopen()/ssclose().
 */
static void ssdelay(ticks)
int ticks;
{
	timeout(&delay_tim, ticks, wakeup, (int)&delay_tim);
	sleep((char *)&delay_tim, CVPAUSE, IVPAUSE, SVPAUSE);
}

/*
 * bus_pre_xfer()
 *
a787 1
	int tries;
d791 6
a796 8
	for (tries = 0; !ret && tries < LOPRI_RETRIES; tries++) {
if (tries>0)break;
		/*
		 * Do ST0x arbitration.
		 */
		sfbyte(ss_csr, 0);		/* De-assert SCSI enable bit */
		sfbyte(ss_dat, HOST_ID);	/* Write my SCSI id to port */
		sfbyte(ss_csr, WC_ARBITRATE);	/* Start arbitration */
d798 9
a806 9
		/*
		 * SCSI spec says there is "no maximum" to the wait for arbitration
		 * complete.
		 */
		if (!bus_wait(RS_ARBIT_COMPL << 8 | RS_ARBIT_COMPL)) {
			if (ffbyte(ss_csr) & (RS_REQUEST|RS_BUSY))
				ret = 1;
			continue;
		}
d808 5
a812 5
		/*
		 * Arbitration complete.  Now select, with ATN to allow messages.
		 */
		sfbyte(ss_dat, HOST_ID | (1 << s_id));	/* Write both SCSI id's */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION | WC_SELECT);
d814 2
a815 2
		if (!bus_wait(RS_BUSY << 8 | RS_BUSY))
			continue;
d817 1
a817 4
		/*
		 * Send "Identify" Message with Disconnect allowed.
		 */
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ATTENTION);
d819 3
a821 3
		if (!bus_wait(((RS_REQUEST|RS_CTRL_DATA|RS_I_O|RS_MESSAGE) << 8)
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
			continue;
d823 6
a828 11
		/*
		 * During ssload(), diagnostics are running and we don't
		 * want disconnects.  At other times, disconnect is ok.
		 */
		if (loading)
			sfbyte(ss_dat, MSG_IDENTIFY);
		else
			sfbyte(ss_dat, MSG_IDENT_DC);
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_ENABLE_IRPT);
		ret = 1;
	}
d830 1
d835 1
a835 1
 * bus_info_xfer()
d858 2
a859 2
static int bus_info_xfer(ssp)
ss_type *ssp;
a863 1
	int no_msg_rcvd = 1;
d866 2
a867 1
int we_wrote=0;
d872 1
a872 1
	while(req_wait(&bus_timeout)) {
d927 1
a927 1
				scsireset();
a944 6
#if 0
if (!we_wrote) {
	we_wrote=1;
	printf("W");
}
#endif
d955 1
a955 1
				scsireset();
d965 2
d1033 1
d1036 6
a1041 12
	rqs.cmdstat = -1;
	rqs.data_bytes_in = 0;
	rqs.data_bytes_out = 0;
	rqs.cmdbuf[0] = ScmdREQUESTSENSE;
	rqs.cmdbuf[1] = rqs.cmdbuf[2] = rqs.cmdbuf[3] =
		rqs.cmdbuf[5] = 0;
		rqs.cmdbuf[4] = SENSELEN;
	rqs.cmdlen = G0CMDLEN;
	rqs.in_buf_len = SENSELEN;
	rqs.out_buf_len = 0;
	FP_OFF(rqs.in_buf) = sense_buf;
	FP_SEL(rqs.in_buf) = sds;
d1043 6
a1048 8
	if (bus_pre_xfer(s_id)) {
		bus_info_xfer(&rqs);
		if (rqs.data_bytes_in == SENSELEN) {
			if (sense_buf[2] == 0x00)	/* No Sense.  AOK */
				ret = 1;
			else if (sense_buf[2] == 0x06 && sense_buf[12] == 0x29)
				ret = 1;
		}
d1068 1
a1068 1
	ss_type * ssp = ss[s_id];
d1070 6
a1075 13
	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdINQUIRY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] =
		ssp->cmdbuf[5] = 0;
		ssp->cmdbuf[4] = INQUIRYLEN;
	ssp->cmdlen = G0CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = INQUIRYLEN;
	ssp->out_buf_len = 0;
d1077 3
a1079 2
	ret = scsicmd(s_id);
	ssp->id_busy = 0;
d1101 1
a1101 1
	ss_type * ssp = ss[s_id];
d1103 6
a1108 15
	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdMODESENSE;
	ssp->cmdbuf[1] = 0;
	ssp->cmdbuf[2] = 0x3F;
	ssp->cmdbuf[3] = 0;
	ssp->cmdbuf[4] = MODESENSELEN;
	ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = MODESENSELEN;
	ssp->out_buf_len = 0;
d1110 3
a1112 2
	ret = scsicmd(s_id);
	ssp->id_busy = 0;
d1129 1
a1129 1
	ss_type * ssp = ss[s_id];
d1131 10
a1140 13
	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->id_busy = 1;
	ssp->cmdbuf[0] = ScmdREADCAPACITY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] = 0;
	ssp->cmdbuf[5] = ssp->cmdbuf[6] = ssp->cmdbuf[7] = ssp->cmdbuf[8] = 0;
	ssp->cmdbuf[9] = 0;
	ssp->cmdlen = G1CMDLEN;
	FP_OFF(ssp->in_buf) = buf;
	FP_SEL(ssp->in_buf) = sds;
	ssp->in_buf_len = 8;
	ssp->out_buf_len = 0;
d1142 3
a1144 2
	ret = scsicmd(s_id);
	ssp->id_busy = 0;
d1150 1
a1150 1
 * ss_start()
a1151 91
 * Invoked whenever there might be I/O to do.
 *
 * Disallow re-entrancy in this routine (variable "locked").
 * If there is a next I/O request queued (peek at head of queue)
 *   get the target SCSI ID.
 *   If target is not busy
 *     remove request from queue
 *     mark target device busy
 *     start watchdog timer
 *     send command to host adapter
 *     if command succeeded
 *       cleanup after command
 *       adjust b_resid field
 *     else if command failed
 *       set error flag
 *       cleanup after command
 *     else (disconnected)
 *       do nothing
 */
static void ss_start()
{
#define RW_TRIES	5
	int s;
	BUF * bp;
	static char locked;
	int s_id;
	ss_type * ssp;
	struct	fdisk_s	*fdp;
	int partition;
	dev_t dev;
	static int retry[MAX_SCSI_ID-1];

	s = sphi();
	if(locked) {
		spl(s);
		return;
	}
	++locked;
	spl(s);

	if (st0x_busy) {
		timeout(&sst_tim, 50, ss_start, 0);
		return;
	}

	if((bp = ssq_rd_head()) != NULL) {
		s_id = DEV_SCSI_ID(bp->b_dev);
		ssp = ss[s_id];
		dev = bp->b_dev;
		partition = DEV_PARTN(dev);
		if (dev & SDEV)
			partition = WHOLE_DRIVE;
		fdp = ssp->parmp;
		if (!(ssp->id_busy)) {
			if (partition != WHOLE_DRIVE)
				ssp->bno = fdp[partition].p_base + bp->b_bno;
			else
				ssp->bno = bp->b_bno;
			ssp->bp = bp;
			ssp->id_busy = 1;
			ssp->dr_watch = WATCHDOG_SECONDS;
			if (ss_rw(s_id)) {
				retry[s_id] = 0;
				ssq_rm_head();
				if (bp->b_req == BREAD)
					bp->b_resid -= ssp->data_bytes_in;
				else
					bp->b_resid -= ssp->data_bytes_out;
				if (ssp->msg_in != MSG_DISCONNECT)
					ss_done(s_id);
			} else {
				if (++retry[s_id] > RW_TRIES) {
printf("BF5 ");
					retry[s_id] = 0;
					ssq_rm_head();
					bp->b_flag |= BFERR;
					ss_done(s_id);
				} else {
					ssp->id_busy = 0;
					timeout(&sst_tim, 10, ss_start, 0);
printf("R%d ",retry[s_id]);
				}
			}
		}
	}
	--locked;
}

/*
 * bus_dev_reset()
 *
a1267 1
				endif
d1278 1
a1278 1
				if (host_claimed == -1 && BUS_FREE) {
d1291 1
a1291 1
				} else  /* host busy or bus not free */
d1340 3
d1357 14
a1370 1
			init_pointers(s_id);
d1381 4
d1461 1
a1461 1
		| (RS_REQUEST|RS_CTRL_DATA|RS_MESSAGE)))
d1466 1
a1466 1
			if (ss[s_id]->local_buf))
d1517 1
a1517 1
	ssp->timing = 1;
d1528 1
a1528 1
static void stop_timeout(s_id);
a1559 1
			ssp->cmdbuf[0] = ScmdREADEXTENDED;
a1564 1
			ssp->cmdbuf[0] = ScmdWRITEXTENDED;
d1622 1
a1622 2
				ssp->state = SST_BUS_DEV_RST;
			}
d1634 1
a1634 1
				ssp->state = SST_BUS_DEV_RST;
a1636 1
			}
d1642 1
a1642 1
		case RV_A_TIMEOUT
d1645 1
a1645 1
	else { /* try_count >= MAX_TRY_COUNT */
a1670 1
		bdone(bp);
d1673 5
d1682 1
d1696 1
d1698 1
a1698 1
	result = info_xfer(s_id);
d1704 1
a1704 1
		target_state = SST_POLL_RESELECT;
d1708 1
a1708 1
	} else if (ssp->cmdstat == CS_BUSY)
d1710 1
a1710 1
	} else if (ssp->cmdstat == CS_CHECK)
d1715 99
@


1.38
log
@Code ss_mach().
@
text
@d5 16
a20 4
 *	bufq_wr_tail
 *	recover()
 *	do_connect()
 *	set_timeout()
d24 3
d80 11
d94 1
a94 1
typedef enum {
d106 10
d121 1
a121 1
	int	dr_watch;	/* number of seconds for pending timeout */
d136 11
a146 5
	unsigned int	busy:1;		/* 1 if command uses local buffer */
	unsigned int	expired:1;	/* 1 if target's timer has expired */
	unsigned int	local_buf:1;	/* 1 if command uses local buffer */
	unsigned int	ptab_read:1;	/* 1 if partition table has been read */
	unsigned int	waiting:1;	/* 1 if target timer is running */
d179 1
d181 1
d186 1
a186 1
static void	reconnect();
a193 1
static int	ss_rw();
d197 1
d202 1
d261 1
a261 1
static int	host_busy;	/* 1 when host is arbitrating or connected */
d341 1
d662 1
a662 1
		defer(ss_mach, s_id); */
d679 1
a679 1
			ss_mach(s_id);
d777 1
a777 1
 * scsireset()
a778 48
 * Reset the SCSI bus.
 *
 * Allow settling time when turning reset on/off.
 * Settling times were determined empirically.
 * Each tick is 10 msec.
 *
 * If called while ssload() is running, don't return until reset is complete.
 * If called after ssload(), start up state machine and return.
 *
 * Either way, mark host adapter busy until reset completes.
 */
#define RESET_TICKS	40
static void scsireset()
{
	static int reset_state;

printf("!");
	/*
	 * During load, it's ok to do sleep() calls for reset settling.
	 * After load is finished, use timeout() to accomplish this.
	 */
	if (loading) {
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET);
		ssdelay(RESET_TICKS);
		sfbyte(ss_csr, 0);
		ssdelay(RESET_TICKS);
	} else {
		switch(reset_state) {
		case 0:
			sfbyte(ss_csr, WC_ENABLE_SCSI | WC_SCSI_RESET);
			timeout(&reset_tim, RESET_TICKS, scsireset, 0);
			reset_state = 1;
			break;
		case 1:
			sfbyte(ss_csr, 0);
			timeout(&reset_tim, RESET_TICKS, scsireset, 0);
			reset_state = 2;
			break;
		case 2:
			reset_state = 0;
			break;
		}
	}
}

/*
 * ssdelay()
 *
d781 3
d793 1
a793 1
 * ss_start_timing()
a794 34
 * Start a timeout for some number of ticks.
 * Caller knows timer has expired when "ss_expired" goes to 1.
 *
 * Sample invocation:
 *	ss_start_timing(n);
 *	while (check for desired event fails) {
 *		if (ss_expired) {
 *			...failure stuff..
 *			break;
 *		}
 *		ssdelay(m); <= needed to allow kernel to update timers
 *	}
 */
static void ss_start_timing(ticks)
int ticks;
{
	ss_expired = 0;
	timeout(&timeout_tim, ticks, ss_stop_timing, 1);
}

/*
 * ss_stop_timing()
 *
 * Stub function called only by ss_start_timing()
 */
static void ss_stop_timing(flagval)
int flagval;
{
	ss_expired = flagval;
}

/*
 * bus_pre_xfer()
 *
d1291 1
a1291 1
 * ss_done
a1292 25
 * Release current i/o buffer to the O/S.
 */
static void ss_done(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int s;

	s = sphi();
	ssp->id_busy = 0;
	ssp->dr_watch = 0;
	ssp->in_buf = ssp->out_buf = NULL;
	if (bp) {
		bdone(bp);
		ssp->bp = NULL;
	}
	spl(s);

	ss_start();
}

/*
 * bus_dev_reset()
 *
a1358 2
 *
 * Call reconnect() after this if reselect has occurred.
d1380 1
a1380 1
 * reconnect()
a1381 135
 * Given SCSI ID of target device that is issuing reselect, do reconnect
 * SCSI bus stuff.
 */
static void reconnect(s_id)
int s_id;
{
	uchar dat;
	int cmd_ok = 0;
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;

	dat = ffbyte(ss_dat);
	if ((dat & HOST_ID) && (dat & (1 << s_id)) && ssp) {
		sfbyte(ss_csr, WC_ENABLE_SCSI | WC_BUSY);
		if (bus_wait(RS_SELECT << 8 | 0)) {
			sfbyte(ss_csr, WC_ENABLE_SCSI);
			cmd_ok = bus_info_xfer(ssp);
			if (bp) {
				if (bp->b_req == BREAD)
					bp->b_resid -= ssp->data_bytes_in;
				else
					bp->b_resid -= ssp->data_bytes_out;
				if (cmd_ok && ssp->cmdstat == CS_GOOD) {
					if (ssp->msg_in == MSG_DISCONNECT) {
						ssp->dr_watch = WATCHDOG_SECONDS;
					} else
						ss_done(s_id);
				} else {
printf("BF6 ");
					bp->b_flag |= BFERR;
					ss_done(s_id);
				}
			}
		}
	}
}

/*
 * ss_rw()
 *
 * Send read or write command to the host adapter.
 */
static int ss_rw(s_id)
int s_id;
{
	ss_type * ssp = ss[s_id];
	BUF * bp = ssp->bp;
	int rw_ok = 0;
uchar rwc;

	ssp->cmdstat = -1;
	if (bp->b_req == BREAD) {
		ssp->cmdbuf[0] = ScmdREADEXTENDED;
		ssp->in_buf_len = bp->b_count;
		ssp->in_buf = bp->b_faddr;
		ssp->out_buf_len = 0;
		ssp->out_buf = NULL;
rwc='R';
	} else {
		ssp->cmdbuf[0] = ScmdWRITEXTENDED;
		ssp->in_buf_len = 0;
		ssp->in_buf = NULL;
		ssp->out_buf_len = bp->b_count;
		ssp->out_buf = bp->b_faddr;
rwc='W';
	}
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[1] = 0;
	ssp->cmdbuf[2] = ssp->bno >> 24;
	ssp->cmdbuf[3] = ssp->bno >> 16;
	ssp->cmdbuf[4] = ssp->bno >>  8;
	ssp->cmdbuf[5] = ssp->bno;
	ssp->cmdbuf[6] = 0;
	ssp->cmdbuf[7] = bp->b_count / (BSIZE * 256L);
	ssp->cmdbuf[8] = bp->b_count / BSIZE;
	ssp->cmdbuf[9] = 0;
	ssp->cmdlen = G1CMDLEN;

{ int s = sphi();
	rw_ok = bus_pre_xfer(s_id);
	if (rw_ok) {
		bus_info_xfer(ssp);
spl(s);
		rw_ok = (ssp->cmdlen == ssp->cmd_bytes_out);
	}
else {{if(sserrct<=MAXSSERR)printf("F1");}spl(s);}
}

	if (ssp->cmdstat == CS_CHECK) {
{if(sserrct<=MAXSSERR)printf("ss_rw(): requesting sense\n");}
		if (req_sense(s_id)) {
			rw_ok = (ssp->cmdlen == ssp->cmd_bytes_out);
if(!rw_ok) {if(sserrct<=MAXSSERR)printf("F3");}
		}
	}

	if (rw_ok) {
		rw_ok =
		(ssp->cmdstat == CS_GOOD || ssp->msg_in == MSG_DISCONNECT);
if(!rw_ok) {if(sserrct<=MAXSSERR)printf("F4");}
	}

	return rw_ok;

}

/*
 * rezero()
 *
 * Send Rezero Unit command.
 *
 * Return 1 if no timeouts occurred, 0 if not.
 */
static int rezero(s_id)
int s_id;
{
	int retval;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[0] = ScmdREZERO;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] =
		ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	retval = scsicmd(s_id);

	return retval;
}

/*
 * ss_mach()
 *
d1404 2
a1405 1
				if (ssp->expired)
d1407 1
a1407 1
				else
d1412 1
a1412 1
		case SST_POLL_BEGIN_IO
d1420 2
a1421 2
				if (!host_busy && BUS_FREE) {
					host_busy = 1;
d1423 1
a1423 5
					ssp->cmd_bytes_out = 0;
					ssp->data_bytes_in = 0;
					ssp->data_bytes_out = 0;
					if (bp)
						bp->b_resid = bp->b_count;
d1431 1
a1431 1
						set_timeout(DELAY_ARB);
d1433 6
a1438 2
				} else  /* host_busy or bus not free */
					set_timeout(DELAY_BSY);
a1444 1
				if reconnect handshake succeeds
d1450 2
a1451 1
				if (ssp->expired)
d1453 1
a1453 1
				else
d1487 1
a1487 1
			set_timeout(DELAY_BDR);
d1493 1
a1493 1
		if(ssq_rd_head() != NULL && !ssp->busy) {
d1495 12
a1506 2
			bp = ssq_rm_head();
			form current block request - initialize try counts, etc.
d1520 1
a1520 1
		set_timeout(DELAY_RST);
d1534 1
a1534 1
		set_timeout(DELAY_RST);
d1618 217
@


1.37
log
@Initial state machine hacks.
@
text
@d5 5
d12 3
d60 4
a63 23
#define DEBUG	1
#if DEBUG
int stats[100], statsptr;
#define PUSHI		{ if(statsptr<100)stats[statsptr++] = i; }
#define POPI		{ if(sserrct<=MAXSSERR)printf("%d:",statsptr);while(statsptr)\
				if(sserrct<=MAXSSERR)printf("%d ",stats[--statsptr]);if(sserrct<=MAXSSERR)printf("\n");}
#define SSTELL(foo)	if(sserrct<=MAXSSERR)printf(foo)
#define SSTATUS		{uchar status = ffbyte(ss_csr);if(sserrct<=MAXSSERR)printf("status=%x\n", status);}
#define SSDUMP(ssp, text) {int i;\
	if(sserrct<=MAXSSERR)printf("%s: msg_in=%x cmdstat=%x\n", text, ssp->msg_in,\
	ssp->cmdstat);if(ssp->cmdlen)for(i=0;i<ssp->cmdlen;i++)\
	if(sserrct<=MAXSSERR)printf(" %x", ssp->cmdbuf[i]);if(sserrct<=MAXSSERR)printf(" cmd_bytes_out=%d",\
	ssp->cmd_bytes_out);\
	if(ssp->data_bytes_in)for(i=0;i<ssp->data_bytes_in;i++)\
	if(sserrct<=MAXSSERR)printf(" %x", ffbyte(ssp->in_buf+i));if(sserrct<=MAXSSERR)printf(" data_bytes_in=%d\n",\
	ssp->data_bytes_in);}
#else
#define PUSHI
#define POPI
#define SSTELL(foo)
#define SSTATUS
#define SSDUMP(ssp, text)
#endif
d68 12
d98 7
a104 1
	unsigned int	ptab_read:1;  /* 1 if partition table has been read */
a121 1
extern void	ss_mach();
d137 1
d140 1
d145 1
d149 1
d157 1
a157 1
static int	testready();
a208 1
static ss_type *ss_tbl;		/* points to block of "ss" structs */
d212 1
d214 3
a216 1
static TIM	sst_tim;	/* for timeout() call from ss_start() */
d218 2
a540 2
	bp->b_resid = bp->b_count;

d731 1
a731 1
 * testready()
a732 56
 * Send Test Unit Ready command.
 * Retry after bus reset if necessary.
 *
 * Return 1 if unit is ready, 0 if not.
 */
static int testready(s_id)
int s_id;
{
	int retval;
	ss_type * ssp = ss[s_id];

	ssp->cmdstat = -1;
	ssp->data_bytes_in = 0;
	ssp->data_bytes_out = 0;
	ssp->cmdbuf[0] = ScmdTESTREADY;
	ssp->cmdbuf[1] = ssp->cmdbuf[2] = ssp->cmdbuf[3] = ssp->cmdbuf[4] =
		ssp->cmdbuf[5] = 0;
	ssp->cmdlen = G0CMDLEN;
	retval = scsicmd(s_id);

	return retval;
}

/*
 * scsicmd()
 *
 * Send command packet to target device.
 * Start a new SCSI bus cycle when this routine is called.
 * If command status after sending is Device Check (CS_CHECK), do a
 * Request Sense to find out what happened and clear check status.
 *
 * Return 1 if command was send and status was good, else 0.
 */
static int scsicmd(s_id)
int s_id;
{
	int retval;
	ss_type *ssp = ss[s_id];

	if (retval = bus_pre_xfer(s_id)) {
		bus_info_xfer(ssp);
		retval = (ssp->cmdlen == ssp->cmd_bytes_out
			&& ssp->cmdstat == CS_GOOD);
	}

	if (ssp->cmdstat == CS_CHECK) {
		if (req_sense(s_id))
			retval = (ssp->cmdlen == ssp->cmd_bytes_out);
	}

	return retval;
}

/*
 * scsireset()
 *
a982 1
SSDUMP(ssp, "Command overrun");
a1016 1
SSDUMP(ssp, "Data out overrun");
a1361 3
	if (!loading && st0x_busy)
		bdr_ok = 0;

a1404 1
printf("%d",bdr_ok);
d1573 229
@


1.36
log
@Last version before using state machine logic.
@
text
@d7 3
d77 1
a97 1
	unsigned int	id_busy:1;  /* 1 if device with this SCSI id busy */
d100 6
d115 1
d176 14
a189 1
static int	loading;	/* 1 ssload() is executing */
a199 1
static int	st0x_busy;	/* 1 if SCSI host adapter busy */
d206 1
a206 1
static ss_type  *ss[MAX_SCSI_ID-1], rqs;
a217 1
	loading = 1;
d254 2
a281 1
	st0x_busy++;
a286 2
	st0x_busy--;
	loading = 0;
d407 1
d417 6
d424 2
a425 1
	 * Decrement the number of watchdog timer requests open for host board.
d428 1
a471 3
#define NHEAD	4
#define NSEC	52
#define NCYL	1004
d493 3
a495 3
		*(short *)&hdparm.ncyl[0] = NCYL;
		hdparm.nhead = NHEAD;
		hdparm.nspt = NSEC;
d547 1
a547 1
{if(sserrct<=MAXSSERR)printf("BF1 ");}
d552 1
a552 1
{if(sserrct<=MAXSSERR)printf("BF2 ");}
d570 1
a570 1
{if(sserrct<=MAXSSERR)printf("BF3 ");}
d580 2
a581 6

/* if(sserrct<=MAXSSERR)printf("ssblock: drv=%x bno=%lx bp=%x flag=%x\n",
	drive, bp->b_bno, bp, bp->b_flag); */

		ssq_wr_tail(bp);
		ss_start();
d604 1
a604 2
		reconnect(s_id);
/*		defer(reconnect, s_id); */
d615 1
a615 1
	int s_id, rs_id;
d620 2
a621 18
		if (ssp && ssp->dr_watch) {
			ssp->dr_watch--;
			if (ssp->dr_watch == 0) {
{if(sserrct<=MAXSSERR)printf("BF4 ");}
				bus_dev_reset(s_id);
				ssp->bp->b_flag |= BFERR;
{if(sserrct<=MAXSSERR)printf("SCSI id #%d: bno=%lu <Watchdog Timeout>\n", s_id, ss[s_id]->bp->b_bno);}
				ss_done(s_id);
			} else {
				while (1) {
					rs_id = chk_reconn();
					if (rs_id == -1)
						break;
					else
						reconnect(rs_id);
				} /* endwhile */
			}
		}
d653 1
a653 1
		{if(sserrct<=MAXSSERR)printf("TO:f=%x s=%x ", flags, status);}
d670 1
a670 1
	int retval = 0;
a674 33
/*FOO*/
bus_dev_reset(s_id);
	/*
	 * Try Test Unit Ready command.
	 * If it fails, reset SCSI bus and target device, and try again.
	 */
printf("T");
	for (try = 0; !retval && try < LOPRI_RETRIES; try++) {
		if (testready(s_id))
			retval = 1;
		else {
printf("X");
			if (ssp->cmdstat == CS_BUSY)
				ssdelay(50);
			else if (ssp->cmdstat == CS_CHECK)
				req_sense(s_id);
			else if (s_id == chk_reconn())
			{
printf("-r-");
				ssdelay(50);
			}
			else
				scsireset();
		}
#if 0
		scsireset();
		bus_dev_reset(s_id);
#endif
	} /* endfor */
	if (!retval)
		devmsg(dev, "Test Unit Ready Failed");

printf("R");
a675 6
		if (req_sense(s_id)) {
			retval = 1;
		} else
			devmsg(dev, "Request Sense Failed");

	if (retval)
a714 1
ssp->id_busy=0;
a798 1
		st0x_busy++;
a802 1
		st0x_busy--;
a805 1
			st0x_busy++;
a815 1
			st0x_busy--;
d1049 1
a1049 1
	{if(sserrct<=MAXSSERR)printf("W");}
d1077 1
a1077 1
	{if(sserrct<=MAXSSERR)printf("CSK",ssp->cmdstat);}
d1080 1
a1080 1
	{if(sserrct<=MAXSSERR)printf("CSY",ssp->cmdstat);}
d1084 1
a1084 1
	{if(sserrct<=MAXSSERR)printf("CS%x",ssp->cmdstat);}
d1120 1
a1120 1
		{if(sserrct<=MAXSSERR)printf("TX: s=%x ", status);}
a1350 1
/* if(sserrct<=MAXSSERR)printf("%d in  %d out\n",ssp->data_bytes_in,ssp->data_bytes_out); */
d1353 1
a1353 1
{if(sserrct<=MAXSSERR)printf("BF5 ");}
d1361 1
a1361 1
{if(sserrct<=MAXSSERR)printf("R%d ",retry[s_id]);}
d1406 1
a1406 1
{if(sserrct<=MAXSSERR)printf("bdr");}
d1454 1
a1454 1
{if(sserrct<=MAXSSERR)printf("%d",bdr_ok);}
d1520 1
a1520 1
{if(sserrct<=MAXSSERR)printf("BF6 ");}
a1576 11
if(!rw_ok) {
  uchar csr=ffbyte(ss_csr), dat=ffbyte(ss_dat);
  sserrct++; if (sserrct <=MAXSSERR) {
    {if(sserrct<=MAXSSERR)printf("F2 cmdlen=%d cmd_bytes_out=%d cmdstat=%d\n", ssp->cmdlen,
  	ssp->cmd_bytes_out, ssp->cmdstat);}
    {if(sserrct<=MAXSSERR)printf("%c msg_in=%x inl=%d ", rwc, ssp->msg_in, ssp->in_buf_len);}
    {if(sserrct<=MAXSSERR)printf("inb=%d otl=%d otb=%d\n", ssp->data_bytes_in, ssp->out_buf_len,
    ssp->data_bytes_out);}
    {if(sserrct<=MAXSSERR)printf("csr=%x dat=%x bno=%ld ",csr,dat,bp->b_bno);}
  }
}
@
