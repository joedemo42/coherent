
Index: list.c
*** /tmp/,RCSt1a17078	Sun Feb 12 14:07:03 1989
--- list.c	Sun Feb 12 14:02:13 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * list.c - List all files on an archive
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * list.c - List all files on an archive
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:14  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.2  89/02/12  10:04:43  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:14  mark
   * Initial revision
   * 

--- 30,38 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.2  89/02/12  10:04:43  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:14  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 39,45 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 384,390
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", syserr());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, "x %s symbolic link to %s\n", name, symnam);

--- 387,393 -----
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", strerror());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, "x %s symbolic link to %s\n", name, symnam);
***************
*** 395,401
  	    if ((asb->sb_nlink > 1) && (link = islink(name, asb))) {
  		fprintf(msgfile, "%s linked to %s\n", name, link->l_name); 
  	    } else {
! 		fprintf(msgfile, "x %s, %d bytes, %d tape blocks\n", 
  			name, asb->sb_size, ROUNDUP(asb->sb_size, 
  			BLOCKSIZE) / BLOCKSIZE);
  	    }

--- 398,404 -----
  	    if ((asb->sb_nlink > 1) && (link = islink(name, asb))) {
  		fprintf(msgfile, "%s linked to %s\n", name, link->l_name); 
  	    } else {
! 		fprintf(msgfile, "x %s, %ld bytes, %d tape blocks\n", 
  			name, asb->sb_size, ROUNDUP(asb->sb_size, 
  			BLOCKSIZE) / BLOCKSIZE);
  	    }
***************
*** 406,412
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", syserr());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, "a %s symbolic link to %s\n", name, symnam);

--- 409,415 -----
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", strerror());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, "a %s symbolic link to %s\n", name, symnam);
***************
*** 418,424
  	    if ((asb->sb_nlink > 1) && (link = islink(name, asb))) {
  		fprintf(msgfile, "link to %s\n", link->l_name); 
  	    } else {
! 		fprintf(msgfile, "%d Blocks\n", 
  			ROUNDUP(asb->sb_size, BLOCKSIZE) / BLOCKSIZE);
  	    }
  	    break;

--- 421,427 -----
  	    if ((asb->sb_nlink > 1) && (link = islink(name, asb))) {
  		fprintf(msgfile, "link to %s\n", link->l_name); 
  	    } else {
! 		fprintf(msgfile, "%ld Blocks\n", 
  			ROUNDUP(asb->sb_size, BLOCKSIZE) / BLOCKSIZE);
  	    }
  	    break;
***************
*** 439,445
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", syserr());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, " symbolic link to %s", name, symnam);

--- 442,448 -----
  	case S_IFLNK: 	/* This file is a symbolic link */
  	    i = readlink(name, symnam, PATH_MAX - 1);
  	    if (i < 0) {		/* Could not find symbolic link */
! 		warn("can't read symbolic link", strerror());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
  		fprintf(msgfile, " symbolic link to %s", symnam);
***************
*** 442,448
  		warn("can't read symbolic link", syserr());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
! 		fprintf(msgfile, " symbolic link to %s", name, symnam);
  	    }
  	    break;
  #endif

--- 445,451 -----
  		warn("can't read symbolic link", strerror());
  	    } else { 		/* Found symbolic link filename */
  		symnam[i] = '\0';
! 		fprintf(msgfile, " symbolic link to %s", symnam);
  	    }
  	    break;
  #endif
***************
*** 454,460
  	}
  	fputc('\n', msgfile);
      } else {
! 	fprintf(msgfile, "? %s %d blocks\n", name,
  		ROUNDUP(asb->sb_size, BLOCKSIZE) / BLOCKSIZE);
      }
  }

--- 457,463 -----
  	}
  	fputc('\n', msgfile);
      } else {
! 	fprintf(msgfile, "? %s %ld blocks\n", name,
  		ROUNDUP(asb->sb_size, BLOCKSIZE) / BLOCKSIZE);
      }
  }
***************
*** 518,525
  	    fprintf(msgfile, "\t        ");
  	}
  	fprintf(msgfile," %3s %2d %02d:%02d ",
! 	               monnames[atm->tm_mon], atm->tm_mday, 
! 		       atm->tm_hour, atm->tm_min);
      }
      fprintf(msgfile, "%s", name);
      if ((asb->sb_nlink > 1) && (from = islink(name, asb))) {

--- 521,528 -----
  	    fprintf(msgfile, "\t        ");
  	}
  	fprintf(msgfile," %3s %2d %02d:%02d ",
! 	        monnames[atm->tm_mon], atm->tm_mday, 
! 		atm->tm_hour, atm->tm_min);
      }
      fprintf(msgfile, "%s", name);
      if ((asb->sb_nlink > 1) && (from = islink(name, asb))) {
***************
*** 532,539
  #endif	/* S_IFLNK */
      putc('\n', msgfile);
  }
- 
- 
  
  
  /* print_mode - fancy file mode display

--- 535,540 -----
  #endif	/* S_IFLNK */
      putc('\n', msgfile);
  }
  
  
  /* print_mode - fancy file mode display
Index: mem.c
*** /tmp/,RCSt1a17083	Sun Feb 12 14:07:14 1989
--- mem.c	Sun Feb 12 14:02:14 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * mem.c - memory allocation and manipulation functions
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * mem.c - memory allocation and manipulation functions
   *
***************
*** 28,34
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:17  mark

--- 28,34 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.2  89/02/12  10:04:53  mark
***************
*** 31,36
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:17  mark
   * Initial revision
   * 

--- 31,39 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.2  89/02/12  10:04:53  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:17  mark
   * Initial revision
   * 
***************
*** 37,43
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 40,46 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 65,71
   * RETURNS
   *
   *	Normally returns the pointer to the newly allocated memory.  If
!  *	an error occurss, NULL is returned, and an error message is
   *	printed.
   *
   * ERRORS

--- 68,74 -----
   * RETURNS
   *
   *	Normally returns the pointer to the newly allocated memory.  If
!  *	an error occurs, NULL is returned, and an error message is
   *	printed.
   *
   * ERRORS
***************
*** 87,93
      char           *mem;
      static short    outofmem = 0;
  
!     if ((mem = (char *)malloc(len)) == NULL && !outofmem) {
  	outofmem++;
  	warn("mem_get()", "Out of memory");
      }

--- 90,96 -----
      char           *mem;
      static short    outofmem = 0;
  
!     if ((mem = (char *)malloc(len)) == (char *)NULL && !outofmem) {
  	outofmem++;
  	warn("mem_get()", "Out of memory");
      }
Index: namelist.c
*** /tmp/,RCSt1a19493	Mon Feb 13 09:15:28 1989
--- namelist.c	Mon Feb 13 09:14:57 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * namelist.c - track filenames given as arguments to tar/cpio/pax
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * namelist.c - track filenames given as arguments to tar/cpio/pax
   *
***************
*** 23,29
   * provided that the above copyright notice is duplicated in all such 
   * forms and that any documentation, advertising materials, and other 
   * materials related to such distribution and use acknowledge that the 
!  * software was developed * by Mark H. Colburn and sponsored by The 
   * USENIX Association. 
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR

--- 23,29 -----
   * provided that the above copyright notice is duplicated in all such 
   * forms and that any documentation, advertising materials, and other 
   * materials related to such distribution and use acknowledge that the 
!  * software was developed by Mark H. Colburn and sponsored by The 
   * USENIX Association. 
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
***************
*** 28,34
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:17  mark

--- 28,34 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.6  89/02/13  09:14:48  mark
***************
*** 31,36
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:17  mark
   * Initial revision
   * 

--- 31,51 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.6  89/02/13  09:14:48  mark
+  * Fixed problem with directory errors
+  * 
+  * Revision 1.5  89/02/12  12:14:00  mark
+  * Fixed misspellings
+  * 
+  * Revision 1.4  89/02/12  11:25:19  mark
+  * Modifications to compile and link cleanly under USG
+  * 
+  * Revision 1.3  89/02/12  10:40:23  mark
+  * Fixed casting problems
+  * 
+  * Revision 1.2  89/02/12  10:04:57  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:17  mark
   * Initial revision
   * 
***************
*** 37,43
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 52,58 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 68,73
  };
  
  
  /* Function Prototypes */
  
  #ifndef __STDC__

--- 83,93 -----
  };
  
  
+ /* Static Variables */
+ 
+ static struct dirinfo *stack_head = (struct dirinfo *)NULL;
+ 
+ 
  /* Function Prototypes */
  
  #ifndef __STDC__
***************
*** 123,129
      if (!p) {
  	fatal("cannot allocate memory for namelist entry\n");
      }
!     p->next = (struct nm_list *) NULL;
      p->length = i;
      strncpy(p->name, name, i);
      p->name[i] = '\0';		/* Null term */

--- 143,149 -----
      if (!p) {
  	fatal("cannot allocate memory for namelist entry\n");
      }
!     p->next = (struct nm_list *)NULL;
      p->length = i;
      strncpy(p->name, name, i);
      p->name[i] = '\0';		/* Null term */
***************
*** 231,237
      for (nlp = namelist; nlp != 0; nlp = nlp->next) {
  	if (!nlp->found) {
  	    fprintf(stderr, "%s: %s not found in archive\n",
! 			   myname, nlp->name);
  	}
  	free(nlp);
      }

--- 251,257 -----
      for (nlp = namelist; nlp != 0; nlp = nlp->next) {
  	if (!nlp->found) {
  	    fprintf(stderr, "%s: %s not found in archive\n",
! 	            myname, nlp->name);
  	}
  	free(nlp);
      }
***************
*** 235,242
  	}
  	free(nlp);
      }
!     namelist = (struct nm_list *) NULL;
!     namelast = (struct nm_list *) NULL;
  }
  
  

--- 255,262 -----
  	}
  	free(nlp);
      }
!     namelist = (struct nm_list *)NULL;
!     namelast = (struct nm_list *)NULL;
  }
  
  
***************
*** 326,332
  	    }
  	} else {
  	    if (in_subdir) {
! 		if ((d = readdir(dirp)) != NULL) {
  		    /* Skip . and .. */
  		    if (strcmp(d->d_name, ".") == 0 ||
  		        strcmp(d->d_name, "..") == 0) {

--- 346,352 -----
  	    }
  	} else {
  	    if (in_subdir) {
! 		if ((d = readdir(dirp)) != (struct dirent *)NULL) {
  		    /* Skip . and .. */
  		    if (strcmp(d->d_name, ".") == 0 ||
  		        strcmp(d->d_name, "..") == 0) {
***************
*** 345,351
  		    curr_dir = popdir();
  		    if (in_subdir) {
  			errno = 0;
! 			if ((dirp = opendir(curr_dir->dirname)) == NULL) {
  			    warn(curr_dir->dirname, "error opening directory (1)");
  			    in_subdir--;
  			}

--- 365,371 -----
  		    curr_dir = popdir();
  		    if (in_subdir) {
  			errno = 0;
! 			if ((dirp=opendir(curr_dir->dirname)) == (DIR *)NULL) {
  			    warn(curr_dir->dirname, "error opening directory (1)");
  			    in_subdir--;
  			}
***************
*** 360,366
  	    }
  	}
  	if ((err = LSTAT(name, statbuf)) < 0) {
! 	    warn(name, syserr());
  	    continue;
  	}
  	if (!names_from_stdin && (statbuf->sb_mode & S_IFMT) == S_IFDIR) {

--- 380,386 -----
  	    }
  	}
  	if ((err = LSTAT(name, statbuf)) < 0) {
! 	    warn(name, strerror());
  	    continue;
  	}
  	if (!names_from_stdin && (statbuf->sb_mode & S_IFMT) == S_IFDIR) {
***************
*** 367,373
  	    if (in_subdir) {
  		curr_dir->where = telldir(dirp);
  		pushdir(curr_dir);
! 		close(dirp);
  	    } 
  	    in_subdir++;
  

--- 387,393 -----
  	    if (in_subdir) {
  		curr_dir->where = telldir(dirp);
  		pushdir(curr_dir);
! 		closedir(dirp);
  	    } 
  	    in_subdir++;
  
***************
*** 372,379
  	    in_subdir++;
  
  	    /* Build new prototype name */
! 	    if ((curr_dir = (struct dirinfo *) 
! 		    mem_get(sizeof(struct dirinfo))) == NULL) {
  		exit(2);
  	    }
  	    strcpy(curr_dir->dirname, name);

--- 392,399 -----
  	    in_subdir++;
  
  	    /* Build new prototype name */
! 	    if ((curr_dir = (struct dirinfo *) mem_get(sizeof(struct dirinfo))) 
! 			  == (struct dirinfo *)NULL) {
  		exit(2);
  	    }
  	    strcpy(curr_dir->dirname, name);
***************
*** 383,393
  	    }
  	    curr_dir->dirname[len++] = '/';	/* Now add exactly one back */
  	    curr_dir->dirname[len] = '\0';/* Make sure null-terminated */
! 
! 	    errno = 0;
! 	    if ((dirp = opendir(curr_dir->dirname)) == NULL) {
! 		warn(curr_dir->dirname, "error opening directory (2)");
! 	    }
  	}
      } while (err < 0);
      return (0);

--- 403,424 -----
  	    }
  	    curr_dir->dirname[len++] = '/';	/* Now add exactly one back */
  	    curr_dir->dirname[len] = '\0';/* Make sure null-terminated */
!             curr_dir->where = 0;
!            
!             errno = 0;
!             do {
!                 if ((dirp = opendir(curr_dir->dirname)) == (DIR *)NULL) {
!                      warn(curr_dir->dirname, "error opening directory (2)");
!                      if (in_subdir > 1) {
!                           curr_dir = popdir();
!                      }
!                      in_subdir--;
!                      err = -1;
!                      continue;
!                 } else {
!                      seekdir(dirp, curr_dir->where);
! 		}
! 	    } while (in_subdir && (! dirp));
  	}
      } while (err < 0);
      return (0);
***************
*** 422,430
  }
  
  
- static struct dirinfo *stack_head = NULL;
- 
- 
  /* pushdir - pushes a directory name on the directory stack
   *
   * DESCRIPTION

--- 453,458 -----
  }
  
  
  /* pushdir - pushes a directory name on the directory stack
   *
   * DESCRIPTION
***************
*** 449,455
  
  #endif
  {
!     if  (stack_head == NULL) {
  	stack_head = info;
  	stack_head->next = NULL;
      } else {

--- 477,483 -----
  
  #endif
  {
!     if  (stack_head == (struct dirinfo *)NULL) {
  	stack_head = info;
  	stack_head->next = (struct dirinfo *)NULL;
      } else {
***************
*** 451,457
  {
      if  (stack_head == NULL) {
  	stack_head = info;
! 	stack_head->next = NULL;
      } else {
  	info->next = stack_head;
  	stack_head = info;

--- 479,485 -----
  {
      if  (stack_head == (struct dirinfo *)NULL) {
  	stack_head = info;
! 	stack_head->next = (struct dirinfo *)NULL;
      } else {
  	info->next = stack_head;
  	stack_head = info;
***************
*** 485,492
  {
      struct dirinfo	*tmp;
  
!     if (stack_head == NULL) {
! 	return(NULL);
      } else {
  	tmp = stack_head;
  	stack_head = stack_head->next;

--- 513,520 -----
  {
      struct dirinfo	*tmp;
  
!     if (stack_head == (struct dirinfo *)NULL) {
! 	return((struct dirinfo *)NULL);
      } else {
  	tmp = stack_head;
  	stack_head = stack_head->next;
Index: names.c
*** /tmp/,RCSt1a17093	Sun Feb 12 14:07:34 1989
--- names.c	Sun Feb 12 14:02:17 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * names.c - Look up user and/or group names. 
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * names.c - Look up user and/or group names. 
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:19  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.2  89/02/12  10:05:05  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:19  mark
   * Initial revision
   * 

--- 30,38 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.2  89/02/12  10:05:05  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:19  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 39,45 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
Index: pass.c
*** /tmp/,RCSt1a17098	Sun Feb 12 14:07:40 1989
--- pass.c	Sun Feb 12 14:02:19 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pass.c - handle the pass option of cpio
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pass.c - handle the pass option of cpio
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:20  mark

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.3  89/02/12  10:29:51  mark
***************
*** 30,35
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:20  mark
   * Initial revision
   * 

--- 30,41 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.3  89/02/12  10:29:51  mark
+  * Fixed misspelling of Replstr
+  * 
+  * Revision 1.2  89/02/12  10:05:09  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:20  mark
   * Initial revision
   * 
***************
*** 36,42
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 42,48 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 74,80
      int             fd;
      Stat            sb;
  
!     while (name_next(name, &sb) >= 0 && (fd = openi(name, &sb)) >= 0) {
  
  	if (rplhead != NULL) {
  	    rpl_name(name);

--- 80,86 -----
      int             fd;
      Stat            sb;
  
!     while (name_next(name, &sb) >= 0 && (fd = openin(name, &sb)) >= 0) {
  
  	if (rplhead != (Replstr *)NULL) {
  	    rpl_name(name);
***************
*** 76,82
  
      while (name_next(name, &sb) >= 0 && (fd = openi(name, &sb)) >= 0) {
  
! 	if (rplhead != NULL) {
  	    rpl_name(name);
  	}
  	if (get_disposition("pass", name) || get_newname(name, sizeof(name))) {

--- 82,88 -----
  
      while (name_next(name, &sb) >= 0 && (fd = openin(name, &sb)) >= 0) {
  
! 	if (rplhead != (Replstr *)NULL) {
  	    rpl_name(name);
  	}
  	if (get_disposition("pass", name) || get_newname(name, sizeof(name))) {
***************
*** 139,147
  	return (-1);
      }
      if (asb->sb_nlink > 1) {
- 	if (f_link && islink(from, asb) == (Link *) NULL) {
- 	    linkto(from, asb);
- 	}
  	linkto(to, asb);
      }
      if ((ofd = openo(to, asb, islink(to, asb), 1)) < 0) {

--- 145,150 -----
  	return (-1);
      }
      if (asb->sb_nlink > 1) {
  	linkto(to, asb);
      }
      if (f_link && islink(from, asb) == (Link *)NULL) {
***************
*** 144,150
  	}
  	linkto(to, asb);
      }
!     if ((ofd = openo(to, asb, islink(to, asb), 1)) < 0) {
  	return (-1);
      }
      if (ofd > 0) {

--- 147,156 -----
      if (asb->sb_nlink > 1) {
  	linkto(to, asb);
      }
!     if (f_link && islink(from, asb) == (Link *)NULL) {
! 	linkto(from, asb);
!     }
!     if ((ofd = openout(to, asb, islink(to, asb), 1)) < 0) {
  	return (-1);
      }
      if (ofd > 0) {
***************
*** 151,157
  	passdata(from, ifd, to, ofd);
      }
      tstamp[0] = asb->sb_atime;
!     tstamp[1] = f_modification_time ? asb->sb_mtime : time((time_t *) 0);
      utime(to, tstamp);
      return (ifd);
  }

--- 157,163 -----
  	passdata(from, ifd, to, ofd);
      }
      tstamp[0] = asb->sb_atime;
!     tstamp[1] = f_mtime ? asb->sb_mtime : time((time_t *) 0);
      utime(to, tstamp);
      return (ifd);
  }
Index: pathname.c
*** /tmp/,RCSt1a17103	Sun Feb 12 14:07:46 1989
--- pathname.c	Sun Feb 12 14:02:21 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pathname.c - directory/pathname support functions 
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pathname.c - directory/pathname support functions 
   *
***************
*** 26,32
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:21  mark

--- 26,32 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.2  89/02/12  10:05:13  mark
***************
*** 29,34
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:21  mark
   * Initial revision
   * 

--- 29,37 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.2  89/02/12  10:05:13  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:21  mark
   * Initial revision
   * 
***************
*** 35,41
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 38,44 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 51,57
   *
   *	Dirneed checks to see if a directory of the name pointed to by name
   *	exists.  If the directory does exist, then dirneed returns 0.  If
!  *	the directory does not exist and the f_create_dirs flag is set,
   *	then dirneed will create the needed directory, recursively creating
   *	any needed intermediate directory.
   *

--- 54,60 -----
   *
   *	Dirneed checks to see if a directory of the name pointed to by name
   *	exists.  If the directory does exist, then dirneed returns 0.  If
!  *	the directory does not exist and the f_dir_create flag is set,
   *	then dirneed will create the needed directory, recursively creating
   *	any needed intermediate directory.
   *
***************
*** 55,61
   *	then dirneed will create the needed directory, recursively creating
   *	any needed intermediate directory.
   *
!  *	If f_create_dirs is not set, then no directories will be created
   *	and a value of -1 will be returned if the directory does not
   *	exist.
   *

--- 58,64 -----
   *	then dirneed will create the needed directory, recursively creating
   *	any needed intermediate directory.
   *
!  *	If f_dir_create is not set, then no directories will be created
   *	and a value of -1 will be returned if the directory does not
   *	exist.
   *
***************
*** 66,72
   * RETURNS
   *
   *	Returns a 0 if the creation of the directory succeeded or if the
!  *	directory already existed.  If the f_create_dirs flag was not set
   *	and the named directory does not exist, or the directory creation 
   *	failed, a -1 will be returned to the calling routine.
   */

--- 69,75 -----
   * RETURNS
   *
   *	Returns a 0 if the creation of the directory succeeded or if the
!  *	directory already existed.  If the f_dir_create flag was not set
   *	and the named directory does not exist, or the directory creation 
   *	failed, a -1 will be returned to the calling routine.
   */
***************
*** 87,93
      int             ok;
      static Stat     sb;
  
!     last = NULL;
      for (cp = name; *cp;) {
  	if (*cp++ == '/') {
  	    last = cp;

--- 90,96 -----
      int             ok;
      static Stat     sb;
  
!     last = (char *)NULL;
      for (cp = name; *cp;) {
  	if (*cp++ == '/') {
  	    last = cp;
***************
*** 93,99
  	    last = cp;
  	}
      }
!     if (last == NULL) {
  	return (STAT(".", &sb));
      }
      *--last = '\0';

--- 96,102 -----
  	    last = cp;
  	}
      }
!     if (last == (char *)NULL) {
  	return (STAT(".", &sb));
      }
      *--last = '\0';
***************
*** 99,105
      *--last = '\0';
      ok = STAT(*name ? name : ".", &sb) == 0
  	? ((sb.sb_mode & S_IFMT) == S_IFDIR)
! 	: (f_create_dirs && dirneed(name) == 0 && dirmake(name, &sb) == 0);
      *last = '/';
      return (ok ? 0 : -1);
  }

--- 102,108 -----
      *--last = '\0';
      ok = STAT(*name ? name : ".", &sb) == 0
  	? ((sb.sb_mode & S_IFMT) == S_IFDIR)
! 	: (f_dir_create && dirneed(name) == 0 && dirmake(name, &sb) == 0);
      *last = '/';
      return (ok ? 0 : -1);
  }
***************
*** 176,182
      if (idx == 0) {
  	element[idx++] = absolute ? "" : "."; 
      }
!     element[idx] = NULL;
      name = begin;
      if (absolute) {
  	*name++ = '/';

--- 179,185 -----
      if (idx == 0) {
  	element[idx++] = absolute ? "" : "."; 
      }
!     element[idx] = (char *)NULL;
      name = begin;
      if (absolute) {
  	*name++ = '/';
Index: pax.1
*** /tmp/,RCSt1a17108	Sun Feb 12 14:07:54 1989
--- pax.1	Sun Feb 12 14:02:22 1989
***************
*** 1,4
! .\" $Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $
  .TH PAX 1 "USENIX Association" ""
  .SH NAME
  pax \- portable archive exchange 

--- 1,4 -----
! .\" $Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $
  .TH PAX 1 "USENIX Association" ""
  .SH NAME
  pax \- portable archive exchange 
***************
*** 213,218
  suffix multiplies 
  .I blocking 
  by 1048576 (1 megabyte).
  If not specified,
  .I blocking 
  is automatically determined on input and is ignored for 

--- 213,220 -----
  suffix multiplies 
  .I blocking 
  by 1048576 (1 megabyte).
+ For machines with 16-bit int's (VAXen, XENIX-286, etc.), 
+ the maximum buffer size is 32k-1.
  If not specified,
  .I blocking 
  is automatically determined on input and is ignored for 
***************
*** 219,225
  .B \-rw.
  .TP 1i
  .B \-c
! Complement the match sense of the the 
  .I pattern
  operands.
  .TP 1i

--- 221,227 -----
  .B \-rw.
  .TP 1i
  .B \-c
! Complement the match sense of the 
  .I pattern
  operands.
  .TP 1i
***************
*** 352,358
  .B \-r 
  option is used.
  The supported formats are:
! .TP 1i
  .I cpio
  The extended 
  .I CPIO

--- 354,361 -----
  .B \-r 
  option is used.
  The supported formats are:
! .RS 1i
! .TP 0.75i
  .I cpio
  The extended 
  .I CPIO
***************
*** 359,365
  interchange format specified in
  .B "Extended CPIO Format" in 
  .I "IEEE Std. 1003.1-1988."
! .TP 1i
  .I ustar
  The extended 
  .I TAR

--- 362,368 -----
  interchange format specified in
  .B "Extended CPIO Format" in 
  .I "IEEE Std. 1003.1-1988."
! .TP 0.75i
  .I ustar
  The extended 
  .I TAR
***************
*** 540,545
  format archives, link counts are listed as zero since the 
  .I ustar
  archive format does not keep link count information.
  .SH COPYRIGHT
  Copyright (c) 1989 Mark H. Colburn.  
  .br

--- 543,553 -----
  format archives, link counts are listed as zero since the 
  .I ustar
  archive format does not keep link count information.
+ .PP
+ On 16 bit architectures, the largest buffer size is 32k-1.
+ This is due, in part, to using integers in the buffer allocation schemes,
+ however, on many of these machines, it is not possible to allocate blocks
+ of memory larger than 32k.
  .SH COPYRIGHT
  Copyright (c) 1989 Mark H. Colburn.  
  .br
***************
*** 554,560
  .PP
  THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
! WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  .SH AUTHOR
  Mark H. Colburn
  .br

--- 562,568 -----
  .PP
  THE SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  .SH AUTHOR
  Mark H. Colburn
  .br
***************
*** 558,564
  .SH AUTHOR
  Mark H. Colburn
  .br
! NAPS International
  .br
  117 Mackubin Street, Suite 1
  .br

--- 566,572 -----
  .SH AUTHOR
  Mark H. Colburn
  .br
! Minnetech Consulting, Inc.
  .br
  117 Mackubin Street, Suite 1
  .br
Index: pax.c
*** /tmp/,RCSt1a17113	Sun Feb 12 14:08:07 1989
--- pax.c	Sun Feb 12 14:02:25 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * DESCRIPTION
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * DESCRIPTION
   *
***************
*** 46,52
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:23  mark

--- 46,52 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.2  89/02/12  10:05:17  mark
***************
*** 49,54
   * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
   * Revision 1.1  88/12/23  18:02:23  mark
   * Initial revision
   * 

--- 49,57 -----
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   *
   * $Log:	patch2,v $
# Revision 1.1  92/08/28  08:02:34  bin
# Initial revision
# 
+  * Revision 1.2  89/02/12  10:05:17  mark
+  * 1.2 release fixes
+  * 
   * Revision 1.1  88/12/23  18:02:23  mark
   * Initial revision
   * 
***************
*** 55,61
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  

--- 58,64 -----
   */
  
  #ifndef lint
! static char *ident = "$Id: patch2,v 1.1 92/08/28 08:02:34 bin Exp Locker: bin $";
  static char *copyright = "Copyright (c) 1989 Mark H. Colburn.\nAll rights reserved.\n";
  #endif /* ! lint */
  
***************
*** 88,94
  OFFSET          total;			/* Total number of bytes transferred */
  short           f_access_time;		/* Reset access times of input files */
  short           areof;			/* End of input volume reached */
! short           f_create_dirs;		/* Create missing directories */
  short           f_append;		/* Add named files to end of archive */
  short           f_create;		/* create a new archive */
  short           f_extract;		/* Extract named files from archive */

--- 91,97 -----
  OFFSET          total;			/* Total number of bytes transferred */
  short           f_access_time;		/* Reset access times of input files */
  short           areof;			/* End of input volume reached */
! short           f_dir_create;		/* Create missing directories */
  short           f_append;		/* Add named files to end of archive */
  short           f_create;		/* create a new archive */
  short           f_extract;		/* Extract named files from archive */
***************
*** 104,110
  short           f_newer;		/* append files to archive if newer */
  short		f_disposition;		/* ask for file disposition */
  short           f_reverse_match;	/* Reverse sense of pattern match */
! short           f_modification_time;	/* Retain file modification time */
  short           f_unconditional;	/* Copy unconditionally */
  time_t          now = 0;		/* Current time */
  uint            arvolume;		/* Volume number */

--- 107,113 -----
  short           f_newer;		/* append files to archive if newer */
  short		f_disposition;		/* ask for file disposition */
  short           f_reverse_match;	/* Reverse sense of pattern match */
! short           f_mtime;		/* Retain file modification time */
  short           f_unconditional;	/* Copy unconditionally */
  time_t          now = 0;		/* Current time */
  uint            arvolume;		/* Volume number */
***************
*** 110,116
  uint            arvolume;		/* Volume number */
  uint            blocksize = BLOCKSIZE;	/* Archive block size */
  FILE	       *msgfile;		/* message outpu file stdout/stderr */
! Replstr        *rplhead = NULL;		/* pointer to head of replstr list */
  Replstr        *rpltail;		/* pointer to tail of replstr list */
  
  

--- 113,119 -----
  uint            arvolume;		/* Volume number */
  uint            blocksize = BLOCKSIZE;	/* Archive block size */
  FILE	       *msgfile;		/* message outpu file stdout/stderr */
! Replstr        *rplhead = (Replstr *)NULL;	/*  head of replstr list */
  Replstr        *rpltail;		/* pointer to tail of replstr list */
  
  
***************
*** 234,241
       * of the tar and/or cpio interfaces...
       */
      f_unconditional = 1;
!     f_modification_time = 1;
!     f_create_dirs = 1;
      f_list = 1;
      blocksize = 0;
      blocking = 0;

--- 237,244 -----
       * of the tar and/or cpio interfaces...
       */
      f_unconditional = 1;
!     f_mtime = 1;
!     f_dir_create = 1;
      f_list = 1;
      blocksize = 0;
      blocking = 0;
***************
*** 258,264
  	    f_reverse_match = 1;
  	    break;
  	case 'd':
! 	    f_create_dirs = 0;
  	    break;
  	case 'f':
  	    if (blocksize == 0) {

--- 261,267 -----
  	    f_reverse_match = 1;
  	    break;
  	case 'd':
! 	    f_dir_create = 0;
  	    break;
  	case 'f':
  	    if (blocksize == 0) {
***************
*** 274,280
  	    f_link = 1;
  	    break;
  	case 'm':
! 	    f_modification_time = 0;
  	    break;
  	case 'o':
  	    f_owner = 1;

--- 277,283 -----
  	    f_link = 1;
  	    break;
  	case 'm':
! 	    f_mtime = 0;
  	    break;
  	case 'o':
  	    f_owner = 1;
***************
*** 358,364
      } else if (f_pass && optind < n_argc) {
  	dirname = n_argv[--n_argc];
  	if (LSTAT(dirname, &st) < 0) {
! 	    fatal(syserr());
  	}
  	if ((st.sb_mode & S_IFMT) != S_IFDIR) {
  	    fatal("Not a directory");

--- 361,367 -----
      } else if (f_pass && optind < n_argc) {
  	dirname = n_argv[--n_argc];
  	if (LSTAT(dirname, &st) < 0) {
! 	    fatal(strerror());
  	}
  	if ((st.sb_mode & S_IFMT) != S_IFDIR) {
  	    fatal("Not a directory");
***************
*** 465,471
  	    number = number * 10 + *idx++ - '0';
  	switch (*idx++) {
  	case 'b':
! 	    result += number * 512;
  	    continue;
  	case 'k':
  	    result += number * 1024;

--- 468,474 -----
  	    number = number * 10 + *idx++ - '0';
  	switch (*idx++) {
  	case 'b':
! 	    result += number * 512L;
  	    continue;
  	case 'k':
  	    result += number * 1024L;
***************
*** 468,474
  	    result += number * 512;
  	    continue;
  	case 'k':
! 	    result += number * 1024;
  	    continue;
  	case 'm':
  	    result += number * 1024 * 1024;

--- 471,477 -----
  	    result += number * 512L;
  	    continue;
  	case 'k':
! 	    result += number * 1024L;
  	    continue;
  	case 'm':
  	    result += number * 1024L * 1024L;
***************
*** 471,477
  	    result += number * 1024;
  	    continue;
  	case 'm':
! 	    result += number * 1024 * 1024;
  	    continue;
  	case '+':
  	    result += number;

--- 474,480 -----
  	    result += number * 1024L;
  	    continue;
  	case 'm':
! 	    result += number * 1024L * 1024L;
  	    continue;
  	case '+':
  	    result += number;
***************
*** 515,522
  
  #endif
  {
!     fprintf(stderr, "\
! Usage: %s -[cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
      fprintf(stderr, "\
         %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",

--- 518,524 -----
  
  #endif
  {
!     fprintf(stderr, "Usage: %s -[cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
      fprintf(stderr, "       %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
***************
*** 518,525
      fprintf(stderr, "\
  Usage: %s -[cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
!     fprintf(stderr, "\
!        %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
      fprintf(stderr, "\
         %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n\

--- 520,526 -----
  {
      fprintf(stderr, "Usage: %s -[cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
!     fprintf(stderr, "       %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
      fprintf(stderr, "       %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n              [-t device] [-x format] [pathname...]\n",
  	myname);
***************
*** 521,529
      fprintf(stderr, "\
         %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
!     fprintf(stderr, "\
!        %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n\
! 	   [-t device] [-x format] [pathname...]\n",
  	myname);
      fprintf(stderr, "\
         %s -r -w [-ilmopuvy] [-s replstr] [pathname...] directory\n",

--- 522,528 -----
  	myname);
      fprintf(stderr, "       %s -r [-cimopuvy] [-f archive] [-s replstr] [-t device] [pattern...]\n",
  	myname);
!     fprintf(stderr, "       %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n              [-t device] [-x format] [pathname...]\n",
  	myname);
      fprintf(stderr, "       %s -r -w [-ilmopuvy] [-s replstr] [pathname...] directory\n",
  	myname);
***************
*** 525,532
         %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n\
  	   [-t device] [-x format] [pathname...]\n",
  	myname);
!     fprintf(stderr, "\
!        %s -r -w [-ilmopuvy] [-s replstr] [pathname...] directory\n",
  	myname);
      exit(1);
  }

--- 524,530 -----
  	myname);
      fprintf(stderr, "       %s -w [-adimuvy] [-b blocking] [-f archive] [-s replstr]\n              [-t device] [-x format] [pathname...]\n",
  	myname);
!     fprintf(stderr, "       %s -r -w [-ilmopuvy] [-s replstr] [pathname...] directory\n",
  	myname);
      exit(1);
  }
Index: pax.h
*** /tmp/,RCSt1a17118	Sun Feb 12 14:08:18 1989
--- pax.h	Sun Feb 12 14:02:26 1989
***************
*** 1,6
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pax.h - defnitions for entire program
   *

--- 1,6 -----
  /* $Source: /src386/usr/bin/pax/patch2,v $
   *
!  * $Revision: 1.1 $
   *
   * pax.h - defnitions for entire program
   *
***************
*** 27,33
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   */
  
  #ifndef _PAX_H

--- 27,33 -----
   *
   * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
   * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
!  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   */
  
  #ifndef _PAX_H
***************
*** 53,59
  #  include <dirent.h>
  # endif
  #else
! # include <sys/dir.h>
  # define dirent direct
  #endif
  

--- 53,67 -----
  #  include <dirent.h>
  # endif
  #else
! # ifdef hpux
! #  include <ndir.h>
! # else
! #  ifdef XENIX_286
! #   include <sys/ndir.h>
! #  else XENIX_286
! #   include <sys/dir.h>
! #  endif XENIX_286
! # endif /* hpux */
  # define dirent direct
  #endif
  
***************
*** 74,79
  #ifdef XENIX
  #   include <sys/inode.h>
  #endif
  
  #include <pwd.h>
  #include <grp.h>

--- 82,90 -----
  #ifdef XENIX
  #   include <sys/inode.h>
  #endif
+ #ifdef XENIX_286
+ #include <sys/param.h>
+ #endif XENIX_286
  
  #include <pwd.h>
  #include <grp.h>
***************
*** 77,82
  
  #include <pwd.h>
  #include <grp.h>
  #include <sys/file.h>
  
  /* Defines */

--- 88,94 -----
  
  #include <pwd.h>
  #include <grp.h>
+ #ifndef XENIX_286
  #include <sys/file.h>
  #endif XENIX_286
  
***************
*** 78,83
  #include <pwd.h>
  #include <grp.h>
  #include <sys/file.h>
  
  /* Defines */
  

--- 90,96 -----
  #include <grp.h>
  #ifndef XENIX_286
  #include <sys/file.h>
+ #endif XENIX_286
  
  /* Defines */
  
***************
*** 331,338
  extern short	f_pass;
  extern short	f_disposition;
  extern short    f_reverse_match;
! extern short    f_modification_time;
! extern short    f_create_dirs;
  extern short    f_unconditional;
  extern short    f_newer;
  extern time_t   now;

--- 344,351 -----
  extern short	f_pass;
  extern short	f_disposition;
  extern short    f_reverse_match;
! extern short    f_mtime;
! extern short    f_dir_create;
  extern short    f_unconditional;
  extern short    f_newer;
  extern time_t   now;
Index: paxdir.c
*** /tmp/,RCSt1a17123	Sun Feb 12 14:08:27 1989
--- paxdir.c	Sun Feb 12 14:02:28 1989
***************
*** 213,219
      struct stat     sbuf;	/* result of fstat() */
  
      if ((fd = open(dirname, O_RDONLY)) < 0)
! 	return NULL;		/* errno set by open() */
  
      if (fstat(fd, &sbuf) != 0 || !S_ISDIR(sbuf.st_mode)) {
  	close(fd);

--- 213,219 -----
      struct stat     sbuf;	/* result of fstat() */
  
      if ((fd = open(dirname, O_RDONLY)) < 0)
! 	return ((DIR *)NULL);		/* errno set by open() */
  
      if (fstat(fd, &sbuf) != 0 || !S_ISDIR(sbuf.st_mode)) {
  	close(fd);
***************
*** 218,224
      if (fstat(fd, &sbuf) != 0 || !S_ISDIR(sbuf.st_mode)) {
  	close(fd);
  	errno = ENOTDIR;
! 	return NULL;		/* not a directory */
      }
      if ((dirp = (DIR *) malloc(sizeof(DIR))) == NULL
  	|| (dirp->dd_buf = (char *) malloc((unsigned) DIRBUF)) == NULL

--- 218,224 -----
      if (fstat(fd, &sbuf) != 0 || !S_ISDIR(sbuf.st_mode)) {
  	close(fd);
  	errno = ENOTDIR;
! 	return ((DIR *)NULL);		/* not a directory */
      }
      if ((dirp = (DIR *) malloc(sizeof(DIR))) == (DIR *)NULL
  	|| (dirp->dd_buf = (char *) malloc((unsigned) DIRBUF)) == (char *)NULL
***************
*** 220,227
  	errno = ENOTDIR;
  	return NULL;		/* not a directory */
      }
!     if ((dirp = (DIR *) malloc(sizeof(DIR))) == NULL
! 	|| (dirp->dd_buf = (char *) malloc((unsigned) DIRBUF)) == NULL
  	) {
  	register int    serrno = errno;
  	/* errno set to ENOMEM by sbrk() */

--- 220,227 -----
  	errno = ENOTDIR;
  	return ((DIR *)NULL);		/* not a directory */
      }
!     if ((dirp = (DIR *) malloc(sizeof(DIR))) == (DIR *)NULL
! 	|| (dirp->dd_buf = (char *) malloc((unsigned) DIRBUF)) == (char *)NULL
  	) {
  	register int    serrno = errno;
  	/* errno set to ENOMEM by sbrk() */
***************
*** 226,232
  	register int    serrno = errno;
  	/* errno set to ENOMEM by sbrk() */
  
! 	if (dirp != NULL)
  	    free((pointer) dirp);
  
  	close(fd);

--- 226,232 -----
  	register int    serrno = errno;
  	/* errno set to ENOMEM by sbrk() */
  
! 	if (dirp != (DIR *)NULL)
  	    free((pointer) dirp);
  
  	close(fd);
***************
*** 231,237
  
  	close(fd);
  	errno = serrno;
! 	return NULL;		/* not enough memory */
      }
      dirp->dd_fd = fd;
      dirp->dd_loc = dirp->dd_size = 0;	/* refill needed */

--- 231,237 -----
  
  	close(fd);
  	errno = serrno;
! 	return ((DIR *)NULL);		/* not enough memory */
      }
      dirp->dd_fd = fd;
      dirp->dd_loc = dirp->dd_size = 0;	/* refill needed */
***************
*** 259,265
  {
      register int	fd;
  
!     if ( dirp == NULL || dirp->dd_buf == NULL ) {
  	errno = EFAULT;
  	return -1;			/* invalid pointer */
      }

--- 259,265 -----
  {
      register int	fd;
  
!     if ( dirp == (DIR *)NULL || dirp->dd_buf == (char *)NULL ) {
  	errno = EFAULT;
  	return -1;			/* invalid pointer */
      }
***************
*** 290,296
  {
      register struct dirent *dp;	/* -> directory data */
  
!     if (dirp == NULL || dirp->dd_buf == NULL) {
  	errno = EFAULT;
  	return NULL;		/* invalid pointer */
      }

--- 290,296 -----
  {
      register struct dirent *dp;	/* -> directory data */
  
!     if (dirp == (DIR *)NULL || dirp->dd_buf == (char *)NULL) {
  	errno = EFAULT;
  	return (struct dirent *)NULL;		/* invalid pointer */
      }
***************
*** 292,298
  
      if (dirp == NULL || dirp->dd_buf == NULL) {
  	errno = EFAULT;
! 	return NULL;		/* invalid pointer */
      }
      do {
  	if (dirp->dd_loc >= dirp->dd_size)	/* empty or obsolete */

--- 292,298 -----
  
      if (dirp == (DIR *)NULL || dirp->dd_buf == (char *)NULL) {
  	errno = EFAULT;
! 	return (struct dirent *)NULL;		/* invalid pointer */
      }
      do {
  	if (dirp->dd_loc >= dirp->dd_size)	/* empty or obsolete */
***************
*** 303,309
  		getdents(dirp->dd_fd, dirp->dd_buf, (unsigned) DIRBUF)
  		) <= 0
  	    )
! 	    return NULL;	/* EOF or error */
  
  	dp = (struct dirent *) & dirp->dd_buf[dirp->dd_loc];
  	dirp->dd_loc += dp->d_reclen;

--- 303,309 -----
  		getdents(dirp->dd_fd, dirp->dd_buf, (unsigned) DIRBUF)
  		) <= 0
  	    )
! 	    return ((struct dirent *)NULL);	/* EOF or error */
  
  	dp = (struct dirent *) & dirp->dd_buf[dirp->dd_loc];
  	dirp->dd_loc += dp->d_reclen;
***************
*** 340,346
  {
      register bool   rewind;	/* "start over when stymied" flag */
  
!     if (dirp == NULL || dirp->dd_buf == NULL) {
  	errno = EFAULT;
  	return;			/* invalid pointer */
      }

--- 340,346 -----
  {
      register bool   rewind;	/* "start over when stymied" flag */
  
!     if (dirp == (DIR *)NULL || dirp->dd_buf == (char *)NULL) {
  	errno = EFAULT;
  	return;			/* invalid pointer */
      }
***************
*** 372,378
  	/* See whether the matching entry is in the current buffer. */
  
  	if ((dirp->dd_loc < dirp->dd_size	/* valid index */
! 	     || readdir(dirp) != NULL	/* next buffer read */
  	     && (dirp->dd_loc = 0, true)	/* beginning of buffer set */
  	     )
  	    && (dp = (struct dirent *) & dirp->dd_buf[dirp->dd_loc])->d_off

--- 372,378 -----
  	/* See whether the matching entry is in the current buffer. */
  
  	if ((dirp->dd_loc < dirp->dd_size	/* valid index */
! 	     || readdir(dirp) != (struct dirent *)NULL	/* next buffer read */
  	     && (dirp->dd_loc = 0, true)	/* beginning of buffer set */
  	     )
  	    && (dp = (struct dirent *) & dirp->dd_buf[dirp->dd_loc])->d_off
***************
*** 442,448
  
  #endif
  {
!     if (dirp == NULL || dirp->dd_buf == NULL) {
  	errno = EFAULT;
  	return -1;		/* invalid pointer */
      }

--- 442,448 -----
  
  #endif
  {
!     if (dirp == (DIR *)NULL || dirp->dd_buf == (char *)NULL) {
  	errno = EFAULT;
  	return -1;		/* invalid pointer */
      }
***************
*** 593,599
      }
  #endif
  
!     if (buf == NULL
  #ifdef ATT_SPEC
  	|| (unsigned long) buf % sizeof(long) != 0	/* ugh */
  #endif

--- 593,599 -----
      }
  #endif
  
!     if (buf == (char *)NULL
  #ifdef ATT_SPEC
  	|| (unsigned long) buf % sizeof(long) != 0	/* ugh */
  #endif
