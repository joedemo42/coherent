37	\fBaaa\fR		Adjust after addition
d5 0a	\fBaad\fR		Adjust AX before division
d4 0a	\fBaam\fR		Adjust AX after multiply
3f	\fBaas\fR		Adjust AL after subtraction
.sp \n(pDu
	\fBadc\fR		Add with carry
83 /2	\fBadcl\fR	\fIimm8s,rm32\fR
83 /2	\fBadcw\fR	\fIimm8s,rm16\fR
14	\fBadcb\fR	\fIimm8,al\fR
15	\fBadcw\fR	\fIimm16,ax\fR
15	\fBadcl\fR	\fIimm32,eax\fR
15	\fBadcl\fR	\fIimm32\fR
80 /2	\fBadcb\fR	\fIimm8,rm8\fR
81 /2	\fBadcw\fR	\fIimm16,rm16\fR
81 /2	\fBadcl\fR	\fIimm32,rm32\fR
12 /r	\fBadcb\fR	\fIrm8,r8\fR
13 /r	\fBadcw\fR	\fIrm16,r16\fR
13 /r	\fBadcl\fR	\fIrm32,r32\fR
10 /r	\fBadcb\fR	\fIr8,rm8\fR
11 /r	\fBadcw\fR	\fIr16,rm16\fR
11 /r	\fBadcl\fR	\fIr32,rm32\fR
.sp \n(pDu
	\fBadd\fR		Add
83 /0	\fBaddl\fR	\fIimm8s,rm32\fR
83 /0	\fBaddw\fR	\fIimm8s,rm16\fR
04	\fBaddb\fR	\fIimm8,al\fR
05	\fBaddw\fR	\fIimm16,ax\fR
05	\fBaddl\fR	\fIimm32,eax\fR
05	\fBaddl\fR	\fIimm32\fR
80 /0	\fBaddb\fR	\fIimm8,rm8\fR
81 /0	\fBaddw\fR	\fIimm16,rm16\fR
81 /0	\fBaddl\fR	\fIimm32,rm32\fR
02 /r	\fBaddb\fR	\fIrm8,r8\fR
03 /r	\fBaddw\fR	\fIrm16,r16\fR
03 /r	\fBaddl\fR	\fIrm32,r32\fR
00 /r	\fBaddb\fR	\fIr8,rm8\fR
01 /r	\fBaddw\fR	\fIr16,rm16\fR
01 /r	\fBaddl\fR	\fIr32,rm32\fR
.sp \n(pDu
	\fBand\fR		Logical AND
83 /4	\fBandl\fR	\fIimm8s,rm32\fR
83 /4	\fBandw\fR	\fIimm8s,rm16\fR
24	\fBandb\fR	\fIimm8,al\fR
25	\fBandw\fR	\fIimm16,ax\fR
25	\fBandl\fR	\fIimm32,eax\fR
25	\fBandl\fR	\fIimm32\fR
80 /4	\fBandb\fR	\fIimm8,rm8\fR
81 /4	\fBandw\fR	\fIimm16,rm16\fR
81 /4	\fBandl\fR	\fIimm32,rm32\fR
22 /r	\fBandb\fR	\fIrm8,r8\fR
23 /r	\fBandw\fR	\fIrm16,r16\fR
23 /r	\fBandl\fR	\fIrm32,r32\fR
20 /r	\fBandb\fR	\fIr8,rm8\fR
21 /r	\fBandw\fR	\fIr16,rm16\fR
21 /r	\fBandl\fR	\fIr32,rm32\fR
.sp \n(pDu
63 /r	\fBarpl\fR	\fIr16,rm16\fR	Adjust RPL field of selector
.sp \n(pDu
	\fBbound\fR		Check if register is within bounds
62 /r	\fBboundw\fR	\fIm16,r16\fR
62 /r	\fBboundl\fR	\fIm32,r32\fR
.sp \n(pDu
	\fBbsf\fR		Bit scan forward
0F bc	\fBbsfw\fR	\fIrm16,r16\fR
0F bc	\fBbsfl\fR	\fIrm32,r32\fR
.sp \n(pDu
	\fBbsr\fR		Bit scan reverse
0F bd	\fBbsrw\fR	\fIrm16,r16\fR
0F bd	\fBbsrl\fR	\fIrm32,r32\fR
.sp \n(pDu
	\fBbt\fR		Save bit in carry flag
0F a3	\fBbtw\fR	\fIr16,rm16\fR
0F a3	\fBbtl\fR	\fIr32,rm32\fR
0F ba /4	\fBbtw\fR	\fIimm8,rm16\fR
0F ba /4	\fBbtl\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBbtc\fR		Bit test and complement
0F bb	\fBbtcw\fR	\fIr16,rm16\fR
0F bb	\fBbtcl\fR	\fIr32,rm32\fR
0F ba /7	\fBbtcw\fR	\fIimm8,rm16\fR
0F ba /7	\fBbtcl\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBbtr\fR		Bit test and reset
0F b3	\fBbtrw\fR	\fIr16,rm16\fR
0F b3	\fBbtrl\fR	\fIr32,rm32\fR
0F ba /6	\fBbtrw\fR	\fIimm8,rm16\fR
0F ba /6	\fBbtrl\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBbts\fR		Bit test and set
0F ab	\fBbtsw\fR	\fIr16,rm16\fR
0F ab	\fBbtsl\fR	\fIr32,rm32\fR
0F ba /5	\fBbtsw\fR	\fIimm8,rm16\fR
0F ba /5	\fBbtsl\fR	\fIimm8,rm32\fR
.sp \n(pDu
e8	\fBcall\fR	\fIreli\fR	Call Procedure
98	\fBcbtw\fR		Sign extend AL
98	\fBcbw\fR		Sign extend AL
99	\fBcdq\fR		Double word to quad word
f8	\fBclc\fR		Clear carry
fc	\fBcld\fR		Clear direction Flag
fa	\fBcli\fR		Clear interrupt Flag
99	\fBcltd\fR		Double word to quad word
0F 06	\fBclts\fR		Clear task-switched flag in CR0
f5	\fBcmc\fR		Complement carry flag
.sp \n(pDu
	\fBcmp\fR		Compare
83 /7	\fBcmpl\fR	\fIimm8s,rm32\fR
83 /7	\fBcmpw\fR	\fIimm8s,rm16\fR
3c	\fBcmpb\fR	\fIimm8,al\fR
3d	\fBcmpw\fR	\fIimm16,ax\fR
3d	\fBcmpl\fR	\fIimm32,eax\fR
3d	\fBcmpl\fR	\fIimm32\fR
80 /7	\fBcmpb\fR	\fIimm8,rm8\fR
81 /7	\fBcmpw\fR	\fIimm16,rm16\fR
81 /7	\fBcmpl\fR	\fIimm32,rm32\fR
3a /r	\fBcmpb\fR	\fIrm8,r8\fR
3b /r	\fBcmpw\fR	\fIrm16,r16\fR
3b /r	\fBcmpl\fR	\fIrm32,r32\fR
38 /r	\fBcmpb\fR	\fIr8,rm8\fR
39 /r	\fBcmpw\fR	\fIr16,rm16\fR
39 /r	\fBcmpl\fR	\fIr32,rm32\fR
.sp \n(pDu
a6	\fBcmpsb\fR		Compare bytes
a7	\fBcmpsl\fR		Compare long
a7	\fBcmpsw\fR		Compare words
99	\fBcwd\fR		Word to double word
98	\fBcwde\fR		Sign extend AX
99	\fBcwtd\fR		Word to double word
98	\fBcwtl\fR		Sign extend AX
27	\fBdaa\fR		Decimal adjust after addition
2f	\fBdas\fR		Decimal adjust after subtraction
.sp \n(pDu
	\fBdec\fR		Decrement by 1
48 +r	\fBdecw\fR	\fIr16\fR
48 +r	\fBdecl\fR	\fIr32\fR
fe /1	\fBdecb\fR	\fIrm8\fR
ff /1	\fBdecw\fR	\fIrm16\fR
ff /1	\fBdecl\fR	\fIrm32\fR
.sp \n(pDu
	\fBdiv\fR		Unsigned divide
f6 /6	\fBdivb\fR	\fIrm8,al\fR
f6 /6	\fBdivb\fR	\fIrm8\fR
f7 /6	\fBdivw\fR	\fIrm16,ax\fR
f7 /6	\fBdivw\fR	\fIrm16\fR
f7 /6	\fBdivl\fR	\fIrm32,eax\fR
f7 /6	\fBdivl\fR	\fIrm32\fR
.sp \n(pDu
c8	\fBenter\fR	\fIimm8,imm16\fR	Make stack frame for procedure
d9 f0	\fBf2xm1\fR		ST = 2 ** ST - 1
d9 e1	\fBfabs\fR		ST = abs(ST)
.sp \n(pDu
	\fBfadd\fR		Floating add
d8 /0	\fBfadds\fR	\fIm32\fR
dc /0	\fBfaddl\fR	\fIm64\fR
d8 c0 +r	\fBfadd\fR	\fIfpreg,st0\fR
d8 c0 +r	\fBfadd\fR	\fIfpreg\fR
de c1	\fBfadd\fR
dc c0 +r	\fBfadd\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfaddp\fR		Floating add and pop
de c0 +r	\fBfaddp\fR	\fIst0,fpreg\fR
de c0 +r	\fBfaddp\fR	\fIfpreg\fR
de c1	\fBfaddp\fR
.sp \n(pDu
df /4	\fBfbld\fR	\fIm80\fR	Load Binary Coded Decimal
df /6	\fBfbstp\fR	\fIm80\fR	Store Binary Coded Decimal and Pop
d9 e0	\fBfchs\fR		Change Floating Sign
9B db e2	\fBfclex\fR		Clear floating point exception flags
.sp \n(pDu
	\fBfcom\fR		Floating Compare
d8 /2	\fBfcoms\fR	\fIm32\fR
dc /2	\fBfcoml\fR	\fIm64\fR
d8 d0 +r	\fBfcom\fR	\fIfpreg,st0\fR
d8 d0 +r	\fBfcom\fR	\fIfpreg\fR
d8 d1	\fBfcom\fR
.sp \n(pDu
	\fBfcomp\fR		Floating Compare and Pop
d8 /3	\fBfcomps\fR	\fIm32\fR
dc /3	\fBfcompl\fR	\fIm64\fR
d8 d8 +r	\fBfcomp\fR	\fIfpreg\fR
d8 d9	\fBfcomp\fR
.sp \n(pDu
de d9	\fBfcompp\fR		Floating Compare and pop twice
d9 ff	\fBfcos\fR		Cosine
d9 f6	\fBfdecstp\fR		Decrement Stack Top Pointer
.sp \n(pDu
	\fBfdiv\fR		Floating divide
d8 /6	\fBfdivs\fR	\fIm32\fR
dc /6	\fBfdivl\fR	\fIm64\fR
d8 f0 +r	\fBfdiv\fR	\fIfpreg,st0\fR
d8 f0 +r	\fBfdiv\fR	\fIfpreg\fR
de f1	\fBfdiv\fR
dc f0 +r	\fBfdiv\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfdivp\fR		Floating divide and pop
de f0 +r	\fBfdivp\fR	\fIst0,fpreg\fR
de f0 +r	\fBfdivp\fR	\fIfpreg\fR
de f1	\fBfdivp\fR
.sp \n(pDu
	\fBfdivr\fR		Reverse floating divide
d8 /7	\fBfdivrs\fR	\fIm32\fR
dc /7	\fBfdivrl\fR	\fIm64\fR
d8 f8 +r	\fBfdivr\fR	\fIfpreg,st0\fR
d8 f8 +r	\fBfdivr\fR	\fIfpreg\fR
de f9	\fBfdivr\fR
dc f8 +r	\fBfdivr\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfdivrp\fR		Reverse floating divide and pop
de f8 +r	\fBfdivrp\fR	\fIst0,fpreg\fR
de f8 +r	\fBfdivrp\fR	\fIfpreg\fR
de f9	\fBfdivrp\fR
.sp \n(pDu
dd c0 +r	\fBffree\fR	\fIfpreg\fR	Free Floating Point Register
.sp \n(pDu
	\fBfiadd\fR		Add integer to float
da /0	\fBfiaddl\fR	\fIm32\fR
de /0	\fBfiadds\fR	\fIm16\fR
.sp \n(pDu
	\fBficom\fR		Compare float to integer
da /2	\fBficoml\fR	\fIm32\fR
de /2	\fBficoms\fR	\fIm16\fR
.sp \n(pDu
	\fBficomp\fR		Compare float to integer and pop
da /3	\fBficompl\fR	\fIm32\fR
de /3	\fBficomps\fR	\fIm16\fR
.sp \n(pDu
	\fBfidiv\fR		Divide float by integer
da /6	\fBfidivl\fR	\fIm32\fR
de /6	\fBfidivs\fR	\fIm16\fR
.sp \n(pDu
	\fBfidivr\fR		Reverse divide integer by float
da /7	\fBfidivrl\fR	\fIm32\fR
de /7	\fBfidivrs\fR	\fIm16\fR
.sp \n(pDu
	\fBfild\fR		Load integer
db /0	\fBfildl\fR	\fIm32\fR
df /0	\fBfilds\fR	\fIm16\fR
df /5	\fBfildll\fR	\fIm64\fR
.sp \n(pDu
	\fBfimul\fR		Multiply integer to float
da /1	\fBfimull\fR	\fIm32\fR
de /1	\fBfimuls\fR	\fIm16\fR
.sp \n(pDu
d9 f7	\fBfincstp\fR		Increment Stack Top Pointer
9B db e3	\fBfinit\fR		Initialize Floating Point Unit
.sp \n(pDu
	\fBfist\fR		Store integer
db /2	\fBfistl\fR	\fIm32\fR
df /2	\fBfists\fR	\fIm16\fR
.sp \n(pDu
	\fBfistp\fR		Store integer and pop
db /3	\fBfistpl\fR	\fIm32\fR
df /3	\fBfistps\fR	\fIm16\fR
df /7	\fBfistpll\fR	\fIm32\fR
.sp \n(pDu
	\fBfisub\fR		Subtract integer from float
da /4	\fBfisubl\fR	\fIm32\fR
de /4	\fBfisubs\fR	\fIm16\fR
.sp \n(pDu
	\fBfisubr\fR		Reverse subtract integer from float
da /5	\fBfisubrl\fR	\fIm32\fR
de /5	\fBfisubrs\fR	\fIm16\fR
.sp \n(pDu
	\fBfld\fR		Load Real
d9 c0 +r	\fBfld\fR	\fIfpreg\fR
d9 /0	\fBflds\fR	\fIm32\fR
dd /0	\fBfldl\fR	\fIm32\fR
db /5	\fBfldt\fR	\fIm64\fR
.sp \n(pDu
d9 e8	\fBfld1\fR		Load Constant 1
d9 /5	\fBfldcw\fR	\fIm32\fR	Load Floating Point Control Word
d9 /4	\fBfldenv\fR	\fIm32\fR	Load FPU Environment
d9 ea	\fBfldl2e\fR		Load Constant log(e) base 2
d9 e9	\fBfldl2t\fR		Load Constant log(10) base 2
d9 ec	\fBfldlg2\fR		Load Constant log(2) base 10
d9 ed	\fBfldln2\fR		Load Constant log(2) base e
d9 eb	\fBfldpi\fR		Load Constant pi
d9 ee	\fBfldz\fR		Load Constant 0.0
.sp \n(pDu
	\fBfmul\fR		Floating multiply
d8 /1	\fBfmuls\fR	\fIm32\fR
dc /1	\fBfmull\fR	\fIm64\fR
d8 c8 +r	\fBfmul\fR	\fIfpreg,st0\fR
d8 c8 +r	\fBfmul\fR	\fIfpreg\fR
de c9	\fBfmul\fR
dc c8 +r	\fBfmul\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfmulp\fR		Floating multiply and pop
de c8 +r	\fBfmulp\fR	\fIst0,fpreg\fR
de c8 +r	\fBfmulp\fR	\fIfpreg\fR
de c9	\fBfmulp\fR
.sp \n(pDu
db e2	\fBfnclex\fR		Clear floating point exception flags no wait
db e3	\fBfninit\fR		Initialize Floating Point Unit no wait
d9 d0	\fBfnop\fR		No Operation
dd /6	\fBfnsave\fR	\fIm32\fR	Store FPU State no wait
d9 /7	\fBfnstcw\fR	\fIm32\fR	Store Control Word no wait
d9 /6	\fBfnstenv\fR	\fIm32\fR	Store FPU Environment no wait
.sp \n(pDu
	\fBfnstsw\fR		Store Status Word no wait
dd /7	\fBfnstsw\fR	\fIm16\fR
df e0	\fBfnstsw\fR	\fIax\fR
.sp \n(pDu
d9 f3	\fBfpatan\fR		Partial Arctangent
d9 f8	\fBfprem\fR		Partial Remainder toward 0
d9 f5	\fBfprem1\fR		Partial Remainder < 1/2 modulus
d9 f2	\fBfptan\fR		Partial Tangent
d9 fc	\fBfrndint\fR		Round To Integer
dd /4	\fBfrstor\fR	\fIm32\fR	Resore FPU State
db f4	\fBfrstpm\fR		set 287XL real mode (nop for 387/486)
9B dd /6	\fBfsave\fR	\fIm32\fR	Store FPU State
d9 fd	\fBfscale\fR		Scale
db e4	\fBfsetpm\fR		set 287 protected mode (nop for 387/486)
d9 fe	\fBfsin\fR		Sine
d9 fb	\fBfsincos\fR		Sine and Cosine
d9 fa	\fBfsqrt\fR		Square Root
.sp \n(pDu
	\fBfst\fR		Store Real
dd d0 +r	\fBfst\fR	\fIfpreg\fR
d9 /2	\fBfsts\fR	\fIm32\fR
dd /2	\fBfstl\fR	\fIm64\fR
.sp \n(pDu
9B d9 /7	\fBfstcw\fR	\fIm32\fR	Store Control Word
9B d9 /6	\fBfstenv\fR	\fIm32\fR	Store FPU Environment
.sp \n(pDu
	\fBfstp\fR		Store Real and pop
dd d8 +r	\fBfstp\fR	\fIfpreg\fR
d9 /3	\fBfstps\fR	\fIm32\fR
dd /3	\fBfstpl\fR	\fIm64\fR
db /7	\fBfstpt\fR	\fIm80\fR
.sp \n(pDu
	\fBfstsw\fR		Store Status Word
9B dd /7	\fBfstsw\fR	\fIm16\fR
9B df e0	\fBfstsw\fR	\fIax\fR
.sp \n(pDu
	\fBfsub\fR		Floating subtract
d8 /4	\fBfsubs\fR	\fIm32\fR
dc /4	\fBfsubl\fR	\fIm64\fR
d8 e0 +r	\fBfsub\fR	\fIfpreg,st0\fR
d8 e0 +r	\fBfsub\fR	\fIfpreg\fR
de e1	\fBfsub\fR
dc e0 +r	\fBfsub\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfsubp\fR		Floating subtract and pop
de e0 +r	\fBfsubp\fR	\fIst0,fpreg\fR
de e0 +r	\fBfsubp\fR	\fIfpreg\fR
de e1	\fBfsubp\fR
.sp \n(pDu
	\fBfsubr\fR		Reverse floating subtract
d8 /5	\fBfsubrs\fR	\fIm32\fR
dc /5	\fBfsubrl\fR	\fIm64\fR
d8 e8 +r	\fBfsubr\fR	\fIfpreg,st0\fR
d8 e8 +r	\fBfsubr\fR	\fIfpreg\fR
de e9	\fBfsubr\fR
dc e8 +r	\fBfsubr\fR	\fIst0,fpreg\fR
.sp \n(pDu
	\fBfsubrp\fR		Reverse floating subtract and pop
de e8 +r	\fBfsubrp\fR	\fIst0,fpreg\fR
de e8 +r	\fBfsubrp\fR	\fIfpreg\fR
de e9	\fBfsubrp\fR
.sp \n(pDu
d9 e4	\fBftst\fR		Test
.sp \n(pDu
	\fBfucom\fR		Unordered compare real
dd e0 +r	\fBfucom\fR	\fIst0,fpreg\fR
dd e0 +r	\fBfucom\fR	\fIfpreg\fR
dd e1	\fBfucom\fR
.sp \n(pDu
	\fBfucomp\fR		Unordered compare real and pop
dd e8 +r	\fBfucomp\fR	\fIst0,fpreg\fR
dd e8 +r	\fBfucomp\fR	\fIfpreg\fR
dd e9	\fBfucomp\fR
.sp \n(pDu
da e9	\fBfucompp\fR		Unordered compare %st %st1 and pop twice
9b	\fBfwait\fR		Wait for coprocessor
d9 e5	\fBfxam\fR		Examine
.sp \n(pDu
	\fBfxch\fR		Floating exchange
d9 c8 +r	\fBfxch\fR	\fIst0,fpreg\fR
d9 c8 +r	\fBfxch\fR	\fIfpreg,st0\fR
d9 c8 +r	\fBfxch\fR	\fIfpreg\fR
d9 c9	\fBfxch\fR
.sp \n(pDu
d9 f4	\fBfxtract\fR		Extract Exponent and Significand
d9 f1	\fBfyl2x\fR		%st1 * log(%st) base 2
d9 f9	\fBfyl2xp1\fR		%st1 * log(%st + 1.0) base 2
f4	\fBhlt\fR		Halt
ff /2	\fBicall\fR	\fIrm32\fR	Call indirect
.sp \n(pDu
	\fBidiv\fR		Signed divide
f6 /7	\fBidivb\fR	\fIrm8,al\fR
f6 /7	\fBidivb\fR	\fIrm8\fR
f7 /7	\fBidivw\fR	\fIrm16,ax\fR
f7 /7	\fBidivw\fR	\fIrm16\fR
f7 /7	\fBidivl\fR	\fIrm32,eax\fR
f7 /7	\fBidivl\fR	\fIrm32\fR
.sp \n(pDu
ff /4	\fBijmp\fR	\fIrm32\fR	Jump indirect
ff /3	\fBilcall\fR	\fIm32\fR	Long call indirect
ff /5	\fBiljmp\fR	\fIm32\fR	Long jump indirect
.sp \n(pDu
	\fBimul\fR		Signed multiply
f6 /5	\fBimulb\fR	\fIrm8\fR
f7 /5	\fBimulw\fR	\fIrm16\fR
f7 /5	\fBimull\fR	\fIrm32\fR
0F af /r	\fBimulw\fR	\fIrm16,r16\fR
0F af /r	\fBimull\fR	\fIrm32,r32\fR
6b	\fBimulw\fR	\fIimm8s,rm16,r16\fR
6b	\fBimull\fR	\fIimm8s,rm32,r32\fR
6b /r	\fBimulw\fR	\fIimm8s,r16\fR
6b /r	\fBimull\fR	\fIimm8s,r32\fR
69	\fBimulw\fR	\fIimm16,rm16,r16\fR
69	\fBimull\fR	\fIimm32,rm32,r32\fR
69 /r	\fBimulw\fR	\fIimm16,r16\fR
69 /r	\fBimull\fR	\fIimm32,r32\fR
.sp \n(pDu
	\fBin\fR		Input from port
ec	\fBin\fR	\fIdx,al\fR
ed	\fBin\fR	\fIdx,ax\fR
ed	\fBin\fR	\fIdx,eax\fR
e4	\fBinb\fR	\fIimm8\fR
e5	\fBinw\fR	\fIimm8\fR
e5	\fBinl\fR	\fIimm8\fR
ec	\fBinb\fR	\fI(dx)\fR
ed	\fBinw\fR	\fI(dx)\fR
ed	\fBinl\fR	\fI(dx)\fR
.sp \n(pDu
	\fBinc\fR		Increment by one
40 +r	\fBincw\fR	\fIr16\fR
40 +r	\fBincl\fR	\fIr32\fR
fe /0	\fBincb\fR	\fIrm8\fR
ff /0	\fBincw\fR	\fIrm16\fR
ff /0	\fBincl\fR	\fIrm32\fR
.sp \n(pDu
6c	\fBinsb\fR		Input byte from port into ES:(E)DI
6c	\fBinsb\fR	\fI(dx)\fR	Input byte from port into ES:(E)DI
6d	\fBinsl\fR		Input long from port into ES:(E)DI
6d	\fBinsl\fR	\fI(dx)\fR	Input long from port into ES:(E)DI
6d	\fBinsw\fR		Input word from port into ES:(E)DI
6d	\fBinsw\fR	\fI(dx)\fR	Input word from port into ES:(E)DI
cc	\fBint\fR	\fIcon3\fR	Interrupt 3
cd	\fBint\fR	\fIimm8\fR	Interrupt
ce	\fBinto\fR		Int 4 if overflow is 1
cf	\fBiret\fR		Interrupt return
cf	\fBiretd\fR		Different mode different opcode ?
07	\fBja\fR	\fIreli\fR	Jump if above
	
03	\fBjae\fR	\fIreli\fR	Jump if above or equal
02	\fBjb\fR	\fIreli\fR	Jump if below
06	\fBjbe\fR	\fIreli\fR	Jump if below or equal
02	\fBjc\fR	\fIreli\fR	Jump if carry
e3	\fBjcxz\fR	\fIrel8\fR	Jump if CX is zero
04	\fBje\fR	\fIreli\fR	Jump if equal
e3	\fBjecxz\fR	\fIrel8\fR	Jump if CX is zero
	
0f	\fBjg\fR	\fIreli\fR	Jump if greater
0d	\fBjge\fR	\fIreli\fR	Jump if greater or equal
0c	\fBjl\fR	\fIreli\fR	Jump if less
0e	\fBjle\fR	\fIreli\fR	Jump if less or equal
e9	\fBjmp\fR	\fIreli\fR	Jump absolute
06	\fBjna\fR	\fIreli\fR	Jump if not above
02	\fBjnae\fR	\fIreli\fR	Jump if not above or equal
03	\fBjnb\fR	\fIreli\fR	Jump if not below
07	\fBjnbe\fR	\fIreli\fR	Jump if not below or equal
03	\fBjnc\fR	\fIreli\fR	Jump if no carry
05	\fBjne\fR	\fIreli\fR	Jump if not equal
0e	\fBjng\fR	\fIreli\fR	Jump if not greater
0c	\fBjnge\fR	\fIreli\fR	Jump if not greater or equal
0d	\fBjnl\fR	\fIreli\fR	Jump if not less
0f	\fBjnle\fR	\fIreli\fR	Jump if not less or equal
01	\fBjno\fR	\fIreli\fR	Jump if not overflow
0b	\fBjnp\fR	\fIreli\fR	Jump if not parity
09	\fBjns\fR	\fIreli\fR	Jump if not sign
05	\fBjnz\fR	\fIreli\fR	Jump if not zero
00	\fBjo\fR	\fIreli\fR	Jump if overflow
0a	\fBjp\fR	\fIreli\fR	Jump if parity
0a	\fBjpe\fR	\fIreli\fR	Jump if parity even
0b	\fBjpo\fR	\fIreli\fR	Jump if parity odd
08	\fBjs\fR	\fIreli\fR	Jump if sign
04	\fBjz\fR	\fIreli\fR	Jump if zero
04	\fBjz\fR	\fIreli\fR	Jump if zero
9f	\fBlahf\fR		Load flags into AH register
.sp \n(pDu
	\fBlar\fR		Load access rights byte
0F 02 /r	\fBlarw\fR	\fIrm16,r16\fR
0F 02 /r	\fBlarl\fR	\fIrm32,r32\fR
.sp \n(pDu
9a	\fBlcall\fR	\fIimm16x,imm32\fR	Long call
.sp \n(pDu
	\fBlds\fR		load full pointer DS:r16
c5 /r	\fBldsw\fR	\fIm16,r16\fR
c5 /r	\fBldsl\fR	\fIm32,r32\fR
.sp \n(pDu
	\fBlea\fR		Load effective address
8d /r	\fBleaw\fR	\fIm16,r16\fR
8d /r	\fBleal\fR	\fIm32,r32\fR
.sp \n(pDu
c9	\fBleave\fR		High level procedure exit
.sp \n(pDu
	\fBles\fR		Load full pointer ES:r16
c4 /r	\fBlesw\fR	\fIm16,r16\fR
c4 /r	\fBlesl\fR	\fIm32,r32\fR
.sp \n(pDu
	\fBlfs\fR		Load full pointer FS:r16
0F b4 /r	\fBlfsw\fR	\fIm16,r16\fR
0F b4 /r	\fBlfsl\fR	\fIm32,r32\fR
.sp \n(pDu
	\fBlgdt\fR		Load m into DGTR
0F 01 /2	\fBlgdtw\fR	\fIm16\fR
0F 01 /2	\fBlgdtl\fR	\fIm32\fR
.sp \n(pDu
	\fBlgs\fR		Load full pointer GS:r16
0F b5 /r	\fBlgsw\fR	\fIm16,r16\fR
0F b5 /r	\fBlgsl\fR	\fIm32,r32\fR
.sp \n(pDu
	\fBlidt\fR		Load m into IDTR
0F 01 /3	\fBlidtw\fR	\fIm16\fR
0F 01 /3	\fBlidtl\fR	\fIm32\fR
.sp \n(pDu
ea	\fBljmp\fR	\fIimm16x,imm32\fR	Long jump
0F 00 /2	\fBlldt\fR	\fIrm16\fR	Load local descriptor table register
0F 01 /6	\fBlmsw\fR	\fIrm16\fR	Load machine status word
f0	\fBlock\fR		Assert lock signal for next instruction
ac	\fBlodsb\fR		Load string operand byte
ad	\fBlodsl\fR		Load string operand long
ad	\fBlodsw\fR		Load string operand word
e2	\fBloop\fR	\fIrel8\fR	Dec count jmp if count <> 0
e1	\fBloope\fR	\fIrel8\fR	Dec count jmp if count <> 0 and ZF = 1
e0	\fBloopne\fR	\fIrel8\fR	Dec count jmp if count <> 0 and ZF = 0
e0	\fBloopnz\fR	\fIrel8\fR	Dec count jmp if count <> 0 and ZF = 0
e1	\fBloopz\fR	\fIrel8\fR	Dec count jmp if count <> 0 and ZF = 1
cb	\fBlret\fR		Far return
ca	\fBlret\fR	\fIimm16\fR	Far return pop imm16 bytes of parms
.sp \n(pDu
	\fBlsl\fR		Load segment limit
0F 03 /r	\fBlslw\fR	\fIrm16,r16\fR
0F 03 /r	\fBlsll\fR	\fIrm32,r32\fR
.sp \n(pDu
	\fBlss\fR		Load full pointer SS:r16
0F b2 /r	\fBlssw\fR	\fIm16,r16\fR
0F b2 /r	\fBlssl\fR	\fIm32,r32\fR
.sp \n(pDu
0F 00 /3	\fBltr\fR	\fIrm16\fR	Load task register
.sp \n(pDu
	\fBmov\fR		Move data
a0	\fBmovb\fR	\fImoffs,al\fR
a1	\fBmovw\fR	\fImoffs,ax\fR
a1	\fBmovl\fR	\fImoffs,eax\fR
a2	\fBmovb\fR	\fIal,moffs\fR
a3	\fBmovw\fR	\fIax,moffs\fR
a3	\fBmovl\fR	\fIeax,moffs\fR
8a /r	\fBmovb\fR	\fIrm8,r8\fR
8b /r	\fBmovw\fR	\fIrm16,r16\fR
8b /r	\fBmovl\fR	\fIrm32,r32\fR
88 /r	\fBmovb\fR	\fIr8,rm8\fR
89 /r	\fBmovw\fR	\fIr16,rm16\fR
89 /r	\fBmovl\fR	\fIr32,rm32\fR
8c /r	\fBmovw\fR	\fIsreg,rm16\fR
8e /r	\fBmovw\fR	\fIrm16,sreg\fR
b0 +r	\fBmovb\fR	\fIimm8,r8\fR
b8 +r	\fBmovw\fR	\fIimm16,r16\fR
b8 +r	\fBmovl\fR	\fIimm32,r32\fR
c6	\fBmovb\fR	\fIimm8,rm8\fR
c7	\fBmovw\fR	\fIimm16,rm16\fR
c7	\fBmovl\fR	\fIimm32,rm32\fR
0F 20 /r	\fBmovl\fR	\fIctlreg,r32\fR
0F 22 /r	\fBmovl\fR	\fIr32,ctlreg\fR
0F 21 /r	\fBmovl\fR	\fIdbreg,r32\fR
0F 23 /r	\fBmovl\fR	\fIr32,dbreg\fR
0F 24 /r	\fBmovl\fR	\fItreg,r32\fR
0F 26 /r	\fBmovl\fR	\fIr32,treg\fR
.sp \n(pDu
a4	\fBmovsb\fR		Move bytes
a5	\fBmovsl\fR		Move longs
a5	\fBmovsw\fR		Move words
.sp \n(pDu
	\fBmovsx\fR		Move with sign extend
0F be /r	\fBmovsxb\fR	\fIrm8,r16\fR
0F be /r	\fBmovsxb\fR	\fIrm8,r32\fR
0F bf /r	\fBmovsxw\fR	\fIrm16,r32\fR
0F be /r	\fBmovsbw\fR	\fIrm8,r16\fR
0F be /r	\fBmovsbl\fR	\fIrm8,r32\fR
0F bf /r	\fBmovswl\fR	\fIrm16,r32\fR
.sp \n(pDu
	\fBmovzx\fR		Move with zero extend
0F b6 /r	\fBmovzxb\fR	\fIrm8,r16\fR
0F b6 /r	\fBmovzxb\fR	\fIrm8,r32\fR
0F b7 /r	\fBmovzxw\fR	\fIrm16,r32\fR
0F b6 /r	\fBmovzbw\fR	\fIrm8,r16\fR
0F b6 /r	\fBmovzbl\fR	\fIrm8,r32\fR
0F b7 /r	\fBmovzwl\fR	\fIrm16,r32\fR
.sp \n(pDu
	\fBmul\fR		Unsigned multiply
f6 /4	\fBmulb\fR	\fIrm8,al\fR
f6 /4	\fBmulb\fR	\fIrm8\fR
f7 /4	\fBmulw\fR	\fIrm16,ax\fR
f7 /4	\fBmulw\fR	\fIrm16\fR
f7 /4	\fBmull\fR	\fIrm32,eax\fR
f7 /4	\fBmull\fR	\fIrm32\fR
.sp \n(pDu
	\fBneg\fR		Negate
f6 /3	\fBnegb\fR	\fIrm8\fR
f7 /3	\fBnegw\fR	\fIrm16\fR
f7 /3	\fBnegl\fR	\fIrm32\fR
.sp \n(pDu
90	\fBnop\fR		No operation
.sp \n(pDu
	\fBnot\fR		Invert bits
f6 /2	\fBnotb\fR	\fIrm8\fR
f7 /2	\fBnotw\fR	\fIrm16\fR
f7 /2	\fBnotl\fR	\fIrm32\fR
.sp \n(pDu
	\fBor\fR		Logical inclusive OR
83 /1	\fBorl\fR	\fIimm8s,rm32\fR
83 /1	\fBorw\fR	\fIimm8s,rm16\fR
0c	\fBorb\fR	\fIimm8,al\fR
0d	\fBorw\fR	\fIimm16,ax\fR
0d	\fBorl\fR	\fIimm32,eax\fR
0d	\fBorl\fR	\fIimm32\fR
80 /1	\fBorb\fR	\fIimm8,rm8\fR
81 /1	\fBorw\fR	\fIimm16,rm16\fR
81 /1	\fBorl\fR	\fIimm32,rm32\fR
0a /r	\fBorb\fR	\fIrm8,r8\fR
0b /r	\fBorw\fR	\fIrm16,r16\fR
0b /r	\fBorl\fR	\fIrm32,r32\fR
08 /r	\fBorb\fR	\fIr8,rm8\fR
09 /r	\fBorw\fR	\fIr16,rm16\fR
09 /r	\fBorl\fR	\fIr32,rm32\fR
.sp \n(pDu
	\fBout\fR		Output from port
e6	\fBoutb\fR	\fIimm8\fR
e7	\fBoutw\fR	\fIimm8\fR
e7	\fBoutl\fR	\fIimm8\fR
ee	\fBoutb\fR	\fI(dx)\fR
ef	\fBoutw\fR	\fI(dx)\fR
ef	\fBoutl\fR	\fI(dx)\fR
ee	\fBout\fR	\fIal,dx\fR
ef	\fBout\fR	\fIax,dx\fR
ef	\fBout\fR	\fIeax,dx\fR
.sp \n(pDu
6e	\fBoutsb\fR		Output byte to port into ES:(E)DI
6f	\fBoutsl\fR		Output long to port into ES:(E)DI
6f	\fBoutsw\fR		Output word to port into ES:(E)DI
.sp \n(pDu
	\fBpop\fR		Pop a word from the stack
58 +r	\fBpopw\fR	\fIr16\fR
58 +r	\fBpopl\fR	\fIr32\fR
1f	\fBpopw\fR	\fIds\fR
07	\fBpopw\fR	\fIes\fR
17	\fBpopw\fR	\fIss\fR
0F a1	\fBpopw\fR	\fIfs\fR
0F a9	\fBpopw\fR	\fIgs\fR
8f /0	\fBpopw\fR	\fIm16\fR
8f /0	\fBpopl\fR	\fIm32\fR
.sp \n(pDu
	\fBpopa\fR		Pop all
61	\fBpopaw\fR
61	\fBpopal\fR
.sp \n(pDu
	\fBpopf\fR		Pop stack into flags
9d	\fBpopfw\fR
9d	\fBpopfl\fR
.sp \n(pDu
	\fBpush\fR		Push a word on the stack
50 +r	\fBpushw\fR	\fIr16\fR
50 +r	\fBpushl\fR	\fIr32\fR
6a	\fBpushb\fR	\fIimm8s\fR
68	\fBpushw\fR	\fIimm16\fR
68	\fBpushl\fR	\fIimm32\fR
0e	\fBpushw\fR	\fIcs\fR
1e	\fBpushw\fR	\fIds\fR
06	\fBpushw\fR	\fIes\fR
16	\fBpushw\fR	\fIss\fR
0F a0	\fBpushw\fR	\fIfs\fR
0F a8	\fBpushw\fR	\fIgs\fR
ff /6	\fBpushw\fR	\fIm16\fR
ff /6	\fBpushl\fR	\fIm32\fR
.sp \n(pDu
	\fBpusha\fR		Push all
60	\fBpushaw\fR
60	\fBpushal\fR
.sp \n(pDu
	\fBpushf\fR		Push flags
9c	\fBpushfw\fR
9c	\fBpushfl\fR
.sp \n(pDu
	\fBrcl\fR		Rotate carry left
d0 /2	\fBrclb\fR	\fIcon1,rm8\fR
d0 /2	\fBrclb\fR	\fIrm8\fR
d2 /2	\fBrclb\fR	\fIcl,rm8\fR
c0 /2	\fBrclb\fR	\fIimm8,rm8\fR
d1 /2	\fBrclw\fR	\fIcon1,rm16\fR
d1 /2	\fBrclw\fR	\fIrm16\fR
d3 /2	\fBrclw\fR	\fIcl,rm16\fR
c1 /2	\fBrclw\fR	\fIimm8,rm16\fR
d1 /2	\fBrcll\fR	\fIcon1,rm32\fR
d1 /2	\fBrcll\fR	\fIrm32\fR
d3 /2	\fBrcll\fR	\fIcl,rm32\fR
c1 /2	\fBrcll\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBrcr\fR		Rotate carry right
d0 /3	\fBrcrb\fR	\fIcon1,rm8\fR
d0 /3	\fBrcrb\fR	\fIrm8\fR
d2 /3	\fBrcrb\fR	\fIcl,rm8\fR
c0 /3	\fBrcrb\fR	\fIimm8,rm8\fR
d1 /3	\fBrcrw\fR	\fIcon1,rm16\fR
d1 /3	\fBrcrw\fR	\fIrm16\fR
d3 /3	\fBrcrw\fR	\fIcl,rm16\fR
c1 /3	\fBrcrw\fR	\fIimm8,rm16\fR
d1 /3	\fBrcrl\fR	\fIcon1,rm32\fR
d1 /3	\fBrcrl\fR	\fIrm32\fR
d3 /3	\fBrcrl\fR	\fIcl,rm32\fR
c1 /3	\fBrcrl\fR	\fIimm8,rm32\fR
.sp \n(pDu
f3	\fBrep\fR		rep following instruction CX times
f3	\fBrepe\fR		repe following instruction CX times or eq
f2	\fBrepne\fR		repne following instruction CX times or ne
f2	\fBrepnz\fR		alternate name for repnz
f3	\fBrepz\fR		alternate name for repe
c3	\fBret\fR		Return
c2	\fBret\fR	\fIimm16\fR	Return pop imm16 bytes of parms
.sp \n(pDu
	\fBrol\fR		Rotate left
d0 /0	\fBrolb\fR	\fIcon1,rm8\fR
d0 /0	\fBrolb\fR	\fIrm8\fR
d2 /0	\fBrolb\fR	\fIcl,rm8\fR
c0 /0	\fBrolb\fR	\fIimm8,rm8\fR
d1 /0	\fBrolw\fR	\fIcon1,rm16\fR
d1 /0	\fBrolw\fR	\fIrm16\fR
d3 /0	\fBrolw\fR	\fIcl,rm16\fR
c1 /0	\fBrolw\fR	\fIimm8,rm16\fR
d1 /0	\fBroll\fR	\fIcon1,rm32\fR
d1 /0	\fBroll\fR	\fIrm32\fR
d3 /0	\fBroll\fR	\fIcl,rm32\fR
c1 /0	\fBroll\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBror\fR		Rotate right
d0 /1	\fBrorb\fR	\fIcon1,rm8\fR
d0 /1	\fBrorb\fR	\fIrm8\fR
d2 /1	\fBrorb\fR	\fIcl,rm8\fR
c0 /1	\fBrorb\fR	\fIimm8,rm8\fR
d1 /1	\fBrorw\fR	\fIcon1,rm16\fR
d1 /1	\fBrorw\fR	\fIrm16\fR
d3 /1	\fBrorw\fR	\fIcl,rm16\fR
c1 /1	\fBrorw\fR	\fIimm8,rm16\fR
d1 /1	\fBrorl\fR	\fIcon1,rm32\fR
d1 /1	\fBrorl\fR	\fIrm32\fR
d3 /1	\fBrorl\fR	\fIcl,rm32\fR
c1 /1	\fBrorl\fR	\fIimm8,rm32\fR
.sp \n(pDu
9e	\fBsahf\fR		Store AH into flags
.sp \n(pDu
	\fBsal\fR		Shift arithmetic left
d0 /4	\fBsalb\fR	\fIcon1,rm8\fR
d0 /4	\fBsalb\fR	\fIrm8\fR
d2 /4	\fBsalb\fR	\fIcl,rm8\fR
c0 /4	\fBsalb\fR	\fIimm8,rm8\fR
d1 /4	\fBsalw\fR	\fIcon1,rm16\fR
d1 /4	\fBsalw\fR	\fIrm16\fR
d3 /4	\fBsalw\fR	\fIcl,rm16\fR
c1 /4	\fBsalw\fR	\fIimm8,rm16\fR
d1 /4	\fBsall\fR	\fIcon1,rm32\fR
d1 /4	\fBsall\fR	\fIrm32\fR
d3 /4	\fBsall\fR	\fIcl,rm32\fR
c1 /4	\fBsall\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBsar\fR		Shift arithmetic right
d0 /7	\fBsarb\fR	\fIcon1,rm8\fR
d0 /7	\fBsarb\fR	\fIrm8\fR
d2 /7	\fBsarb\fR	\fIcl,rm8\fR
c0 /7	\fBsarb\fR	\fIimm8,rm8\fR
d1 /7	\fBsarw\fR	\fIcon1,rm16\fR
d1 /7	\fBsarw\fR	\fIrm16\fR
d3 /7	\fBsarw\fR	\fIcl,rm16\fR
c1 /7	\fBsarw\fR	\fIimm8,rm16\fR
d1 /7	\fBsarl\fR	\fIcon1,rm32\fR
d1 /7	\fBsarl\fR	\fIrm32\fR
d3 /7	\fBsarl\fR	\fIcl,rm32\fR
c1 /7	\fBsarl\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBsbb\fR		Subtract with borrow
83 /3	\fBsbbl\fR	\fIimm8s,rm32\fR
83 /3	\fBsbbw\fR	\fIimm8s,rm16\fR
1c	\fBsbbb\fR	\fIimm8,al\fR
1d	\fBsbbw\fR	\fIimm16,ax\fR
1d	\fBsbbl\fR	\fIimm32,eax\fR
1d	\fBsbbl\fR	\fIimm32\fR
80 /3	\fBsbbb\fR	\fIimm8,rm8\fR
81 /3	\fBsbbw\fR	\fIimm16,rm16\fR
81 /3	\fBsbbl\fR	\fIimm32,rm32\fR
1a /r	\fBsbbb\fR	\fIrm8,r8\fR
1b /r	\fBsbbw\fR	\fIrm16,r16\fR
1b /r	\fBsbbl\fR	\fIrm32,r32\fR
18 /r	\fBsbbb\fR	\fIr8,rm8\fR
19 /r	\fBsbbw\fR	\fIr16,rm16\fR
19 /r	\fBsbbl\fR	\fIr32,rm32\fR
.sp \n(pDu
ae	\fBscasb\fR		Compare string bytes
af	\fBscasl\fR		Compare string longs
af	\fBscasw\fR		Compare string words
	
0F 97	\fBseta\fR	\fIrm8\fR	Set byte if above
0F 93	\fBsetae\fR	\fIrm8\fR	Set byte if above or equal
0F 92	\fBsetb\fR	\fIrm8\fR	Set byte if below
0F 96	\fBsetbe\fR	\fIrm8\fR	Set byte if below or equal
0F 92	\fBsetc\fR	\fIrm8\fR	Set byte if carry
0F 94	\fBsete\fR	\fIrm8\fR	Set byte if equal
0F 9f	\fBsetg\fR	\fIrm8\fR	Set byte if greater
0F 9d	\fBsetge\fR	\fIrm8\fR	Set byte if greater or equal
0F 9c	\fBsetl\fR	\fIrm8\fR	Set byte if less
0F 9e	\fBsetle\fR	\fIrm8\fR	Set byte if less or equal
0F 96	\fBsetna\fR	\fIrm8\fR	Set byte if not above
0F 92	\fBsetnae\fR	\fIrm8\fR	Set byte if not above or equal
0F 93	\fBsetnb\fR	\fIrm8\fR	Set byte if not below
0F 97	\fBsetnbe\fR	\fIrm8\fR	Set byte if not below or equal
0F 93	\fBsetnc\fR	\fIrm8\fR	Set byte if no carry
0F 95	\fBsetne\fR	\fIrm8\fR	Set byte if not equal
0F 9e	\fBsetng\fR	\fIrm8\fR	Set byte if not greater
0F 9c	\fBsetnge\fR	\fIrm8\fR	Set byte if not greater or equal
0F 9d	\fBsetnl\fR	\fIrm8\fR	Set byte if not less
0F 9f	\fBsetnle\fR	\fIrm8\fR	Set byte if not less or equal
0F 91	\fBsetno\fR	\fIrm8\fR	Set byte if not overflow
0F 9b	\fBsetnp\fR	\fIrm8\fR	Set byte if not parity
0F 99	\fBsetns\fR	\fIrm8\fR	Set byte if not sign
0F 95	\fBsetnz\fR	\fIrm8\fR	Set byte if not zero
0F 90	\fBseto\fR	\fIrm8\fR	Set byte if overflow
0F 9a	\fBsetp\fR	\fIrm8\fR	Set byte if parity
0F 9a	\fBsetpe\fR	\fIrm8\fR	Set byte if parity even
0F 9b	\fBsetpo\fR	\fIrm8\fR	Set byte if parity odd
0F 98	\fBsets\fR	\fIrm8\fR	Set byte if sign
0F 94	\fBsetz\fR	\fIrm8\fR	Set byte if zero
0F 94	\fBsetz\fR	\fIrm8\fR	Set byte if zero
	
0F 01 /0	\fBsgdt\fR	\fImem32\fR	Store gdtr
.sp \n(pDu
	\fBshl\fR		Shift arithmetic left
d0 /4	\fBshlb\fR	\fIcon1,rm8\fR
d0 /4	\fBshlb\fR	\fIrm8\fR
d2 /4	\fBshlb\fR	\fIcl,rm8\fR
c0 /4	\fBshlb\fR	\fIimm8,rm8\fR
d1 /4	\fBshlw\fR	\fIcon1,rm16\fR
d1 /4	\fBshlw\fR	\fIrm16\fR
d3 /4	\fBshlw\fR	\fIcl,rm16\fR
c1 /4	\fBshlw\fR	\fIimm8,rm16\fR
d1 /4	\fBshll\fR	\fIcon1,rm32\fR
d1 /4	\fBshll\fR	\fIrm32\fR
d3 /4	\fBshll\fR	\fIcl,rm32\fR
c1 /4	\fBshll\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBshld\fR		Shift double precision left
0F a4	\fBshldw\fR	\fIimm8,r16,rm16\fR
0F a4	\fBshldl\fR	\fIimm8,r32,rm32\fR
0F a5	\fBshldw\fR	\fIcl,r16,rm16\fR
0F a5	\fBshldl\fR	\fIcl,r32,rm32\fR
.sp \n(pDu
	\fBshr\fR		Shift right
d0 /5	\fBshrb\fR	\fIcon1,rm8\fR
d0 /5	\fBshrb\fR	\fIrm8\fR
d2 /5	\fBshrb\fR	\fIcl,rm8\fR
c0 /5	\fBshrb\fR	\fIimm8,rm8\fR
d1 /5	\fBshrw\fR	\fIcon1,rm16\fR
d1 /5	\fBshrw\fR	\fIrm16\fR
d3 /5	\fBshrw\fR	\fIcl,rm16\fR
c1 /5	\fBshrw\fR	\fIimm8,rm16\fR
d1 /5	\fBshrl\fR	\fIcon1,rm32\fR
d1 /5	\fBshrl\fR	\fIrm32\fR
d3 /5	\fBshrl\fR	\fIcl,rm32\fR
c1 /5	\fBshrl\fR	\fIimm8,rm32\fR
.sp \n(pDu
	\fBshrd\fR		Shift double precision right
0F ac	\fBshrdw\fR	\fIimm8,r16,rm16\fR
0F ac	\fBshrdl\fR	\fIimm8,r32,rm32\fR
0F ad	\fBshrdw\fR	\fIcl,r16,rm16\fR
0F ad	\fBshrdl\fR	\fIcl,r32,rm32\fR
0F ad	\fBshrdw\fR	\fIr16,rm16\fR
0F ad	\fBshrdl\fR	\fIr32,rm32\fR
.sp \n(pDu
0F 01 /1	\fBsidt\fR	\fImem32\fR	Store idtr
0F 00 /0	\fBsldt\fR	\fIrm16\fR	Store ldtr to EA word
0F 01 /4	\fBsmsw\fR	\fIrm16\fR	Store machine status to EA word
f9	\fBstc\fR		Set carry flag
fd	\fBstd\fR		Clear direction flag
fb	\fBsti\fR		Set interrupt flag
aa	\fBstosb\fR		Store string byte
ab	\fBstosl\fR		Store string long
ab	\fBstosw\fR		Store string word
0F 00 /1	\fBstr\fR		Store task register
.sp \n(pDu
	\fBsub\fR		Subtract
83 /5	\fBsubl\fR	\fIimm8s,rm32\fR
83 /5	\fBsubw\fR	\fIimm8s,rm16\fR
2c	\fBsubb\fR	\fIimm8,al\fR
2d	\fBsubw\fR	\fIimm16,ax\fR
2d	\fBsubl\fR	\fIimm32,eax\fR
2d	\fBsubl\fR	\fIimm32\fR
80 /5	\fBsubb\fR	\fIimm8,rm8\fR
81 /5	\fBsubw\fR	\fIimm16,rm16\fR
81 /5	\fBsubl\fR	\fIimm32,rm32\fR
2a /r	\fBsubb\fR	\fIrm8,r8\fR
2b /r	\fBsubw\fR	\fIrm16,r16\fR
2b /r	\fBsubl\fR	\fIrm32,r32\fR
28 /r	\fBsubb\fR	\fIr8,rm8\fR
29 /r	\fBsubw\fR	\fIr16,rm16\fR
29 /r	\fBsubl\fR	\fIr32,rm32\fR
.sp \n(pDu
	\fBtest\fR		Logical compare
a8	\fBtestb\fR	\fIimm8,al\fR
a9	\fBtestw\fR	\fIimm16,ax\fR
a9	\fBtestl\fR	\fIimm32,eax\fR
a9	\fBtestl\fR	\fIimm32\fR
f6 /0	\fBtestb\fR	\fIimm8,rm8\fR
f7 /0	\fBtestw\fR	\fIimm16,rm16\fR
f7 /0	\fBtestl\fR	\fIimm32,rm32\fR
84 /r	\fBtestb\fR	\fIr8,rm8\fR
85 /r	\fBtestw\fR	\fIr16,rm16\fR
85 /r	\fBtestl\fR	\fIr32,rm32\fR
.sp \n(pDu
0F 00 /4	\fBverr\fR	\fIrm16\fR	Verify segment for read
0F 00 /5	\fBverw\fR	\fIrm16\fR	Verify segment for write
9b	\fBwait\fR		Wait for coprocessor
.sp \n(pDu
	\fBxchg\fR		Exchange register
90 +r	\fBxchgw\fR	\fIr16,ax\fR
90 +r	\fBxchgw\fR	\fIax,r16\fR
90 +r	\fBxchgl\fR	\fIr32,eax\fR
90 +r	\fBxchgl\fR	\fIr32\fR
90 +r	\fBxchgl\fR	\fIeax,r32\fR
86 /r	\fBxchgb\fR	\fIrm8,r8\fR
87 /r	\fBxchgw\fR	\fIrm16,r16\fR
87 /r	\fBxchgl\fR	\fIrm32,r32\fR
86 /r	\fBxchgb\fR	\fIr8,rm8\fR
87 /r	\fBxchgw\fR	\fIr16,rm16\fR
87 /r	\fBxchgl\fR	\fIr32,rm32\fR
.sp \n(pDu
d7	\fBxlat\fR		Table lookup translation
d7	\fBxlatb\fR		Table lookup translation
.sp \n(pDu
	\fBxor\fR		Logical exclusive OR
83 /6	\fBxorl\fR	\fIimm8s,rm32\fR
83 /6	\fBxorw\fR	\fIimm8s,rm16\fR
34	\fBxorb\fR	\fIimm8,al\fR
35	\fBxorw\fR	\fIimm16,ax\fR
35	\fBxorl\fR	\fIimm32,eax\fR
35	\fBxorl\fR	\fIimm32\fR
80 /6	\fBxorb\fR	\fIimm8,rm8\fR
81 /6	\fBxorw\fR	\fIimm16,rm16\fR
81 /6	\fBxorl\fR	\fIimm32,rm32\fR
32 /r	\fBxorb\fR	\fIrm8,r8\fR
33 /r	\fBxorw\fR	\fIrm16,r16\fR
33 /r	\fBxorl\fR	\fIrm32,r32\fR
30 /r	\fBxorb\fR	\fIr8,rm8\fR
31 /r	\fBxorw\fR	\fIr16,rm16\fR
31 /r	\fBxorl\fR	\fIr32,rm32\fR
