head     2.3;
branch   ;
access   ;
symbols  ;
locks    bin:2.3;
comment  @ * @;


2.3
date     93.08.09.13.39.27;  author bin;  state Exp;
branches ;
next     2.2;

2.2
date     93.07.20.11.15.31;  author bin;  state Exp;
branches ;
next     2.1;

2.1
date     93.07.07.10.34.10;  author root;  state Exp;
branches ;
next     ;


desc
@@


2.3
log
@Kernel 82 changes
@
text
@/*
 * ker/i386/ndp.c
 *
 * All ndp-related functions, except for assembler routines
 *
 * Revised: Mon Aug  2 02:44:03 1993 CDT
 */

/*
 * ----------------------------------------------------------------------
 * Includes.
 */

#include <common/_gregset.h>

#include <sys/coherent.h>
#include <sys/errno.h>
#include <sys/ndp.h>
#include <sys/seg.h>

/*
 * ----------------------------------------------------------------------
 * Definitions.
 *	Constants.
 *	Macros with argument lists.
 *	Typedefs.
 *	Enums.
 */

/*
 * ----------------------------------------------------------------------
 * Functions.
 *	Import Functions.
 *	Export Functions.
 *	Local Functions.
 */
void	emFinit();
void	emtrap();
void	fptrap();
void	ndpConRest();
void	ndpDetach();
void	ndpEmTraps();
void	ndpEndProc();
void	ndpIrq();
void	ndpMine();
void	ndpNewOwner();
void	ndpNewProc();
char *	ndpTypeName();
int	rdEmTrapped();
int	rdNdpSaved();
int	rdNdpSavedU();
int	rdNdpUser();
void	senseNdp();
void	wrEmTrapped();
void	wrNdpSaved();
void	wrNdpSavedU();
void	wrNdpUser();

/*
 * ----------------------------------------------------------------------
 * Global Data.
 *	Import Variables.
 *	Export Variables.
 *	Local Variables.
 */

/*
 * ndp control word is 16 bits:
 * 0000 RC:2 PC:2 01 PM:1 UM:1 OM:1 ZM:1 DM:1 IM:1
 * RC - rounding control
 * PC - precision control
 * PM - precision mask
 * UM - underflow mask
 * OM - overflow mask
 * ZM - zero divide mask
 * DM - denormal operand mask
 * IM - invalid operation mask
 * for masks, 1 masks the exception
 *
 * iBCS2 page 3-46 specifies the following:
 *   0000 : 00 10 : 0 1 1 1 : 0 0 1 0 = 0x0272
 */

/* Configurable ndp-related variables. */
extern short	ndpCW;
extern short	ndpDump;
extern short	ndpType;
extern int	ndpEmSig;

/* Patchable emulator-related function pointers. */
extern int	(*ndpEmFn)();
extern int	(*ndpKfsave)();
extern int	(*ndpKfrstor)();

static int	kerEm = 1;	/* RAM copy of CR0 EM bit */
static int	ndpUseg;	/* system global address of U segment */
static PROC *	ndpOwner;	/* process whose stuff is now in ndp */

/*
 * ----------------------------------------------------------------------
 * Code.
 */

/*
 * Called from trap handler the first time a process executes an ndp
 * instruction.
 */
void
ndpNewOwner ()
{
	UPROC *		up;

	/* disable further emulator traps for this process */
	wrNdpUser (1);
	ndpEmTraps (0);

	/* save old ndp status, if any process was using it */
	if (ndpOwner) {
		int work = workAlloc ();
		ptable1_v [work] = sysmem.u.pbase [btocrd (ndpUseg)] | SEG_RW;
		up = (UPROC *) (ctob(work) + U_OFFSET);
		ndpSave (& up->u_ndpCon);
		wrNdpSavedU (1, up);
		workFree (work);
	}

	/* Make current process NDP owner */
	ndpMine ();

	/* give process a clean ndp */
	ndpInit (ndpCW);
}

/*
 * NDP initialization for a new process.
 * Called at exec time.
 * Sets defaults, before it is known whether the process uses NDP or not.
 */
void
ndpNewProc()
{
	/* default for a process is to trap on NDP instructions */
	ndpEmTraps (1);
	wrNdpUser (0);
	wrNdpSaved (0);
	wrEmTrapped (0);
}

/*
 * Restore some ndp info when doing a regular conrest().
 * Called just after conrest - u area has just been restored.
 */
void
ndpConRest()
{
	UPROC *		up;

	/* make CR0 EM bit match what this process needs */
	ndpEmTraps (rdNdpUser () ? 0 : 1);

	/*
	 * If current process uses ndp, may need to fix ndp state
	 *
	 * By the nature of NDP save op's, if the NDP owner's NDP state
	 * is saved, then it's not in the NDP.
	 *
	 * So, we have to be careful (1) not to save twice, and (2) to
	 * restore, even if we are NDP owner, if NDP state is saved.
	 */

	if (rdNdpUser ()) {
		if (ndpOwner != SELF) {
			if (ndpOwner) {		/* save old ndp state */
				int work = workAlloc ();
				ptable1_v [work] =
				  sysmem.u.pbase [btocrd (ndpUseg)] | SEG_RW;
				up = (UPROC *) (ctob(work) + U_OFFSET);
				if (! rdNdpSavedU (up)) {
					ndpSave (& up->u_ndpCon);
					wrNdpSavedU (1, up);
				}
				workFree (work);
			}

			/* Make current process NDP owner and reload ndp state */
			ndpMine ();
			ndpRestore (& u.u_ndpCon);
			wrNdpSaved (0);
		} else if (rdNdpSaved()) {
			ndpRestore (& u.u_ndpCon);
			wrNdpSaved (0);
		}
	}
}

/*
 * When a process exits, it relinquishes the ndp.
 */
void
ndpEndProc()
{
	if (SELF == ndpOwner)
		ndpDetach();
}

/*
 * ----------------------------------------------------------------------
 * Trap handlers.
 */

/*
 * fptrap()
 *
 * Entered when NDP generates a CPU error.
 * err is either SIFP or 0x0D40
 */

void
fptrap (regset)
gregset_t	regset;
{
	unsigned short	sw;		/* ndp status word */
	struct _fpstate * fsp = & u.u_ndpCon;

	/* NIGEL: removed set of u.u_regl here */
	/*
	 * Send user a signal.
	 */

	ndpSave (fsp);
	/* Clear exception flag in NDP to prevent runaway trap. */
	sw = fsp->status = fsp->sw;
	fsp->sw &= 0x7f00;
	wrNdpSaved (1);
	if (ndpDump) {
		curr_register_dump (& regset);
		printf ("\nfcs=%x  fip=%x  fos=%x  foo=%x\n",
			fsp->cssel & 0xffff, fsp->ipoff,
			fsp->datasel & 0xffff, fsp->dataoff);
		printf("User Floating Point Trap: ");
		if (sw & 1)
			printf("Invalid Operation");
		else if (sw & 2)
			printf("Denormalized Operand");
		else if (sw & 4)
			printf("Divide by Zero");
		else if (sw & 8)
			printf("Overflow");
		else if (sw & 0x10)
			printf("Underflow");
		else if (sw & 0x20)
			printf("Precision");
		else
			printf("???");
	}
	sendsig (SIGFPE, SELF);
}

/*
 * emtrap()
 *
 * Entered when NDP opcode is executed and EM bit of CR0 is 1.
 * err is SIXNP (Device Not Available Fault)
 */
void
emtrap (regset)
gregset_t	regset;
{
	switch (ndpType) {
	case NDP_TYPE_287:
	case NDP_TYPE_387:
	case NDP_TYPE_486:
		ndpNewOwner ();
		break;

	default:
		if (ndpDump) {
			curr_register_dump (& regset);
			printf ("emulation trap\n");
		}
		if (! rdEmTrapped ()) {
			wrEmTrapped (1);
			emFinit (& u.u_ndpCon);
		}
		if (ndpEmFn) {
			int looker = 1;

			/*
			 * No emulator lookahead if ptraced or
			 * single step process.
			 */
			if ((SELF->p_flags & PFTRAC) != 0 ||
			    (regset._i386._eflags & MFTTB) != 0)
				looker = 0;
			(* ndpEmFn) (& regset, & u.u_ndpCon, looker);
		} else
			sendsig(ndpEmSig, SELF);
	}
}

/*
 * IRQ 13 handler.  Not used with 486.
 */
void
ndpIrq()
{
	struct _fpstate * fsp = &u.u_ndpCon;
	unsigned short sw;

	outb(NDP_PORT, 0);
	/*
	 * Send user a signal.
	 */
	ndpSave(fsp);
	/* Clear exception flag in NDP to prevent runaway trap. */
	sw = fsp->status = fsp->sw;
	fsp->sw &= 0x7f00;
	wrNdpSaved(1);
	if (ndpDump) {
		printf("\nfcs=%x  fip=%x  fos=%x  foo=%x\n",
		  fsp->cssel&0xffff, fsp->ipoff,
		  fsp->datasel&0xffff, fsp->dataoff);
		printf("User 387 Trap: ");
		if (sw & 1)
			printf("Invalid Operation");
		else if (sw & 2)
			printf("Denormalized Operand");
		else if (sw & 4)
			printf("Divide by Zero");
		else if (sw & 8)
			printf("Overflow");
		else if (sw & 0x10)
			printf("Underflow");
		else if (sw & 0x20)
			printf("Precision");
		else
			printf("???");
	}
	sendsig(SIGFPE, SELF);
}

/*
 * ----------------------------------------------------------------------
 * Routines concerned with whether current process has used the ndp.
 */
int
rdNdpUser()
{
	return (u.u_ndpFlags & NF_NDP_USER) ? 1 : 0;
}

void
wrNdpUser(n)
int n;
{
	if (n)
		u.u_ndpFlags |= NF_NDP_USER;
	else
		u.u_ndpFlags &= ~NF_NDP_USER;
}

/*
 * Since saving NDP state is destructive, we need to keep track
 * of where the current NDP state is - u area, or NDP?
 */
int
rdNdpSaved()
{
	return (u.u_ndpFlags & NF_NDP_SAVED) ? 1 : 0;
}

int
rdNdpSavedU(up)
UPROC * up;
{
	return (up->u_ndpFlags & NF_NDP_SAVED) ? 1 : 0;
}

void
wrNdpSaved(n)
int n;
{
	if (n)
		u.u_ndpFlags |= NF_NDP_SAVED;
	else
		u.u_ndpFlags &= ~NF_NDP_SAVED;
}

void
wrNdpSavedU(n, up)
int n;
UPROC * up;
{
	if (n)
		up->u_ndpFlags |= NF_NDP_SAVED;
	else
		up->u_ndpFlags &= ~NF_NDP_SAVED;
}

/*
 * Enable (1) or disable (0) emulator traps.
 */
void
ndpEmTraps(n)
int n;
{
	if (kerEm != n) {
		kerEm = n;
		setEm (n);
	}
}

/*
 * Make ndp owned by no one.
 */
void
ndpDetach()
{
	ndpOwner = 0;
	ndpUseg = 0;
}

/*
 * Make ndp owned by the current process.
 */
void
ndpMine()
{
	SR *		srp = & u.u_segl [SIUSERP];
	SEG *		sp = srp->sr_segp;

	ndpOwner = SELF;
	ndpUseg = MAPIO (sp->s_vmem, U_OFFSET);
}

/*
 * ----------------------------------------------------------------------
 * Code concerned with identifying coprocessor type, and taking specialized
 * action depending on the type.
 */

/*
 * Using usual algorithms, determine existence and type of NDP.
 * If interrupt vector needs to be set for FP exception, do it.
 *
 * If 2's bit of int11 is on, NDP is present.
 */
void
senseNdp()
{
	if (ndpType == NDP_TYPE_AUTO) {
		ndpEmTraps (0);		/* Will need to do some FP code. */
		ndpType = ndpSense ();	/* Rely on assembler tricks now. */
		ndpEmTraps (1);
	}
	if (ndpType == NDP_TYPE_387 || ndpType == NDP_TYPE_287)
		setivec (NDP_IRQ, ndpIrq);
}

/*
 * Called from main().
 * Return name string for the type of coprocessor detected.
 */
char *
ndpTypeName()
{
	char * ret = "**ERROR: Bad ndp type**";

	switch(ndpType) {
	case NDP_TYPE_NONE:
		ret = "No NDP.  ";
		break;
	case NDP_TYPE_287:
		ret = "NDP=287.  ";
		break;
	case NDP_TYPE_387:
		ret = "NDP=387.  ";
		break;
	case NDP_TYPE_486:
		ret = "NDP=486.  ";
		break;
	}
	return ret;
}

/*
 * ----------------------------------------------------------------------
 * Little routines for tracking emulator state.
 */

int
rdEmTrapped()
{
	return (u.u_ndpFlags & NF_EM_TRAPPED) ? 1 : 0;
}

void
wrEmTrapped(n)
int n;
{
	if (n)
		u.u_ndpFlags |= NF_EM_TRAPPED;
	else
		u.u_ndpFlags &= ~NF_EM_TRAPPED;
}

/*
 * Provide the emulator with a fresh context.
 */
void
emFinit(fpsp)
struct _fpemstate * fpsp;
{
	register int r;

	memset(fpsp, '\0', sizeof(struct _fpemstate));	/* mostly zeroes */
	fpsp->cw = ndpCW;
	for(r = 0; r < 8; r++)
		fpsp->regs[r].tag = 7;		/* Empty */
}

/*
 * ----------------------------------------------------------------------
 * Functions to interface with the emulator.
 */
get_fs_byte(cp)
char *cp;
{
	char getubd();

	return getubd(cp);
}

get_fs_word(sp)
short *sp;
{
	short getusd();

	return getusd(sp);
}

get_fs_long(lp)
long *lp;
{
	long getuwd();

	return getuwd(lp);
}

void
put_fs_byte(data, cp)
char *cp;
char data;
{
	putubd(cp, data);
}

void
put_fs_word(data, sp)
short *sp;
short data;
{
	putusd(sp, data);
}

void
put_fs_long(data, lp)
long *lp;
long data;
{
	putuwd(lp, data);
}

/*
 * Return zero if out of bounds for write.
 */
int
verify_area(cp, len)
int * cp;
int len;
{
	int ret = useracc(cp, len, 1);

	if (!ret) {
#if 0
		printf("Bad Em write, base=%x, len=%x, r.a.=%x",
			cp, len, *(int *)((&cp) - 1));
#endif
		sendsig(SIGSEGV, SELF);
	}
	return ret;
}

/*
 * print kernel message.
 */
printk(s)
char *s;
{
	puts(s);
}

emSendsig()
{
	sendsig(SIGFPE, SELF);
}
@


2.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * File:	ndp.c
d4 1
a4 1
 * Purpose:	all ndp-related functions, except for assembler routines
d6 1
a6 7
 * $Log:	ndp.c,v $
 * Revision 1.2  93/04/14  10:27:57  root
 * r75
 * 
 * Revision 1.1  92/11/09  17:09:23  root
 * Just before adding vio segs.
 * 
d18 1
a28 4
/* bit positions in u.u_ndpFlags */
#define NF_NDP_USER	1	/* this process has used the ndp */
#define NF_NDP_SAVED	2	/* ndp status is saved in u area */
#define NF_EM_TRAPPED	4	/* no ndp, em trap has occurred */
a29 9
/* supported coprocessor types - will autosense if initially unpatched */
#define NDP_TYPE_UNPATCHED	0
#define NDP_TYPE_NONE		1
#define NDP_TYPE_287		2
#define NDP_TYPE_387		3
#define NDP_TYPE_486		4

#define NDP_IRQ		13	/* 387 uses Irq for unmasked exceptions */
#define NDP_PORT	0xF0	/* 387 uses this port to clear exception */
d84 5
a88 5
/* Patchable ndp-related variables. */
short	ndpCW = 0x0272;	/* NDP Control Word at start of each NDP process. */
short	ndpDump = 0;	/* Patch to 1 for NDP register dump on FP exceptions. */
short	ndpType = NDP_TYPE_UNPATCHED;	/* Patch overrides NDP type sensing. */
int	ndpEmSig = SIGFPE;	/* signal sent on receiving emulator traps */
d91 3
a93 3
int	(*ndpEmFn)() = 0;
int	(*ndpKfsave)() = 0;
int	(*ndpKfrstor)() = 0;
d451 1
a451 1
	if (ndpType == NDP_TYPE_UNPATCHED) {
@


2.1
log
@Last Pre-STREAMS kernel
@
text
@d19 3
d23 1
a23 1
#include <errno.h>
d127 1
a127 1
ndpNewOwner()
d132 2
a133 2
	wrNdpUser(1);
	ndpEmTraps(0);
d137 6
a142 7
		int work = workAlloc();
		ptable1_v[work] = sysmem.u.pbase[btocrd(ndpUseg)] | SEG_RW;
		mmuupd();
		up = (UPROC *)(ctob(work) + U_OFFSET);
		ndpSave(&up->u_ndpCon);
		wrNdpSavedU(1, up);
		workFree(work);
d146 1
a146 1
	ndpMine();
d149 1
a149 1
	ndpInit(ndpCW);
d161 4
a164 4
	ndpEmTraps(1);
	wrNdpUser(0);
	wrNdpSaved(0);
	wrEmTrapped(0);
d177 1
a177 1
	ndpEmTraps(rdNdpUser() ? 0 : 1);
d188 2
a189 1
	if (rdNdpUser()) {
d192 7
a198 8
				int work = workAlloc();
				ptable1_v[work] =
				  sysmem.u.pbase[btocrd(ndpUseg)] | SEG_RW;
				mmuupd();
				up = (UPROC *)(ctob(work) + U_OFFSET);
				if (!rdNdpSavedU(up)) {
					ndpSave(&up->u_ndpCon);
					wrNdpSavedU(1, up);
d200 1
a200 1
				workFree(work);
d204 3
a206 3
			ndpMine();
			ndpRestore(&u.u_ndpCon);
			wrNdpSaved(0);
d208 2
a209 2
			ndpRestore(&u.u_ndpCon);
			wrNdpSaved(0);
a234 7
#define RDUMP() { \
  printf("\neax=%x  ebx=%x  ecx=%x  edx=%x\n", eax, ebx, ecx, edx); \
  printf("esi=%x  edi=%x  ebp=%x  esp=%x\n", esi, edi, ebp, esp); \
  printf("cs=%x  ds=%x  es=%x  ss=%x  fs=%x  gs=%x\n", \
    cs&0xffff, ds&0xffff, es&0xffff, ss&0xffff, fs&0xffff, gs&0xffff); \
  printf("err #%d eip=%x  uesp=%x  cmd=%s\n", err, eip, uesp, u.u_comm); \
  printf("efl=%x  ", efl); }
d237 2
a238 3
fptrap(gs, fs, es, ds, edi, esi, ebp, esp, ebx, edx, ecx, eax, trapno, err,
  eip, cs, efl, uesp, ss)
char *eip;
d241 1
a241 1
	struct _fpstate * fsp = &u.u_ndpCon;
d243 1
a243 3
	if (err == SIFP)
		u.u_regl = &gs;	/* hook in register set for consave/conrest */

d247 2
a248 1
	ndpSave(fsp);
d252 1
a252 1
	wrNdpSaved(1);
d254 4
a257 4
		RDUMP();
		printf("\nfcs=%x  fip=%x  fos=%x  foo=%x\n",
		  fsp->cssel&0xffff, fsp->ipoff,
		  fsp->datasel&0xffff, fsp->dataoff);
d274 1
a274 1
	sendsig(SIGFPE, SELF);
d284 2
a285 3
emtrap(gs, fs, es, ds, edi, esi, ebp, esp, ebx, edx, ecx, eax, trapno, err,
  eip, cs, efl, uesp, ss)
char *eip;
d291 1
a291 1
		ndpNewOwner();
d293 1
d296 2
a297 1
			RDUMP();
d299 3
a301 3
		if (!rdEmTrapped()) {
			wrEmTrapped(1);
			emFinit(&u.u_ndpCon);
d310 2
a311 1
			if ((SELF->p_flags & PFTRAC) || (u.u_regl[EFL] & MFTTB))
d313 1
a313 1
			(*ndpEmFn)(&gs, &u.u_ndpCon, looker);
d427 1
a427 1
		setEm(n);
d447 1
a447 1
	SR *		srp = &(u.u_segl[SIUSERP]);
d451 1
a451 1
	ndpUseg = MAPIO(sp->s_vmem, U_OFFSET);
d470 3
a472 3
		ndpEmTraps(0);		/* Will need to do some FP code. */
		ndpType = ndpSense();	/* Rely on assembler tricks now. */
		ndpEmTraps(1);
d474 2
a475 3
	if (ndpType == NDP_TYPE_387 || ndpType == NDP_TYPE_287) {
		setivec(NDP_IRQ, ndpIrq);
	}
@
