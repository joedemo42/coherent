head     1.14;
branch   ;
access   ;
symbols  ;
locks    bin:1.14; strict;
comment  @ * @;


1.14
date     93.06.14.13.42.44;  author bin;  state Exp;
branches ;
next     1.13;

1.13
date     93.03.02.08.27.42;  author bin;  state Exp;
branches ;
next     1.12;

1.12
date     93.01.18.16.25.13;  author bin;  state Exp;
branches ;
next     1.11;

1.11
date     92.12.18.14.20.42;  author bin;  state Exp;
branches ;
next     1.10;

1.10
date     92.11.23.09.40.54;  author bin;  state Exp;
branches ;
next     1.9;

1.9
date     92.11.13.11.06.37;  author bin;  state Exp;
branches ;
next     1.8;

1.8
date     92.11.02.13.12.16;  author bin;  state Exp;
branches ;
next     1.7;

1.7
date     92.10.26.07.24.36;  author bin;  state Exp;
branches ;
next     1.6;

1.6
date     92.10.22.14.18.34;  author bin;  state Exp;
branches ;
next     1.5;

1.5
date     92.10.12.10.03.53;  author bin;  state Exp;
branches ;
next     1.4;

1.4
date     92.08.28.08.59.48;  author bin;  state Exp;
branches ;
next     1.3;

1.3
date     92.08.20.12.51.59;  author bin;  state Exp;
branches ;
next     1.2;

1.2
date     92.08.04.12.44.12;  author bin;  state Exp;
branches ;
next     1.1;

1.1
date     92.07.17.15.22.33;  author bin;  state Exp;
branches ;
next     ;


desc
@@


1.14
log
@Hal: kernel 78 update
@
text
@/*
 * MMU dependent code for Coherent 386
 *
 * Copyright (c) Ciaran O'Donnell, Bievres (FRANCE), 1991
 */

#include <sys/coherent.h>
#include <sys/clist.h>
#include <errno.h>
#include <sys/inode.h>
#include <sys/seg.h>
#include <signal.h>
#include <sys/buf.h>
#include <sys/alloc.h>
#include <l.out.h>
#include <ieeefp.h>

/* These defines belong somewhere else:  */
#define LOMEM	0x15	/* CMOS address of size in K of memory below 1MB.  */
#define EXTMEM	0x17	/* CMOS address of size in K of memory above 1MB.  */
#define ONE_K	1024
#define ONE_MEG	1048576
#define USE_NDATA	1

/*
 * DMA will not work to memory above 16M, so limit the amount of memory
 * above 1M to 15M.  A much cleverer scheme should be implemented.
 */
int HACK_LIMIT = (15*ONE_MEG);

/*
 * For 0 < i < 64, buddysize[i] is log(base 2) of nearest power of two
 * which is greater than or equal to i.
 */
char	buddysize[64] = {
	-1, 0, 1, 2, 2, 3, 3, 3,
	3, 4, 4, 4, 4, 4, 4, 4,
	4, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5,
	5, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6 };

#define	min(a, b)	((a) < (b) ? (a) : (b))

/*
 * Functions.
 *	Import.
 *	Export.
 *	Local.
 */
void		areacheck();
void		areafree();
void		areainit();
BLOCKLIST *	arealloc();
int		areasize();
cseg_t *	c_alloc();
cseg_t *	c_extend(); 
void		c_free();
int		c_grow();
int		countsize();
void		doload();
char *		getPhysMem();
void		i8086();
void		idtinit();
void		init_phy_seg();
void		mchinit();
void		msigend();
void		msigstart();
void		physMemInit();
SR		*loaded();
unsigned int	read16_cmos();
void		segload();
void		sunload();
void		unload();
void		valloc();

#define		zero_fill(from, len)	memset(from, 0, len)

/*
 * "load" a handle "hp"  to a segment into the space tree for a process
 */
void
doload(srp)
register SR	*srp;
{
	register int	n;
	register	cseg_t *pp;
	register int	base1, flags;
	register int	akey;

	pp = srp->sr_segp->s_vmem;
	flags = srp->sr_segp->s_flags;
	base1 = btocrd(srp->sr_base);
	n = btoc(srp->sr_size);

	/*
	 * we load all pages
	 */
	 /* a shm segment ref may be Read-Write or Read-Only */
	if (srp->sr_flag & SRFRODT)
		akey = SEG_RO;
	else {
		switch (flags&(SFSYST|SFTEXT)) {
		case SFTEXT:	akey = SEG_RO;  break;
		case SFSYST:	akey = SEG_SRW; break;
		default:	akey = SEG_RW;  break;
		}
	}

	do
		ptable1_v[base1++] = (*pp++ & ~SEG_NPL) | akey;
	while (--n);
	mmuupd();
}

/*
 * unload a handle key "key" to a segment from the MMU hardware
 */
void
unload(srp)
register SR *srp;
{
	register int	n, base1;

	base1 = btocrd(srp->sr_base);
	
	n = btoc(srp->sr_size);
	do {
		ptable1_v[base1++] = SEG_ILL;
	} while (--n);
	mmuupd();
}

/*
 * Allocate 'clicks_wanted' clicks of core space.
 * Returns physical segment descriptor if success, else NULL.
 * The physical segment descriptor is a table of page table entries
 * suitable for insertion into a page table.
 */
cseg_t *
c_alloc(clicks_wanted)
unsigned	clicks_wanted;
{
	unsigned	pno;
	cseg_t *pp;
	register cseg_t *qp;

	/* Do we have enough free physical clicks for this request?  */
	if (clicks_wanted > allocno())
		goto no_c_alloc;

	/* Allocate some space for the table to return.  */
	if ((pp = (cseg_t *)arealloc(clicks_wanted)) == 0)
		goto no_c_alloc;
	qp = pp;

	/* fill in entries in the requested table */
	do {
		pno = *--sysmem.pfree;
		if (!pvalid(pno))
			panic("c_alloc");
		*qp++ = (clickseg(pno) & ~SEG_BITS) | SEG_PRE;
	} while (--clicks_wanted);
	return pp;

no_c_alloc:
	return 0;
}

/*
 * Given an array "pp" containing "numClicks" click descriptors,
 *   if "pp" is the click list for a user segment currently loaded
 *     invalidate click entries for "pp" in the current page table
 *   return each click in "pp" to the sysmem pool, if it came from there.
 *   return the array "pp" to the buddy pool.
 */
void
c_free(pp, numClicks)
cseg_t	*pp;
unsigned	numClicks;
{
	unsigned	pno;
	register cseg_t *qp;
	register int	sz;
	SR		*srp;

	if (srp = loaded(pp)) {
		unload(srp);
		srp->sr_segp = 0;
	}
	sz = numClicks;
	if (&sysmem.pfree[sz] > sysmem.efree)
		panic("c_free - nalloc");
	qp = pp;
	do {
		if ((*qp & SEG_NPL) == 0) {
			pno = segclick(*qp);
			if (!pvalid(pno))
				panic("c_free");
			*sysmem.pfree++ = pno;
		} else {
			T_HAL(0x40000, printf("c_free NPL %x ", *qp));
		}
		qp++;
	} while (--sz);
	areafree((BLOCKLIST *)pp, numClicks);
}

/*
 * Given a user virtual address, a physical address, and a byte
 * count, map the specified virtual address into the user data
 * page table for the current process.
 *
 * This is meant to be called from the console ioctl, KDMAPDISP.
 * The user virtual address must be click aligned.
 * The range of physical addresses must lie outside installed RAM
 * or within the "PHYS_MEM" pool.
 *
 * Return 1 on success, else 0.
 */
int
mapPhysUser(virtAddr, physAddr, numBytes)
{
	int ret = 0;
	SR * srp = u.u_segl + SIPDATA;
	SEG * sp = srp->sr_segp;
	cseg_t * pp = sp->s_vmem, * qp;
	int pno, clickOffset, numClicks, i;

	/* Check alignment. */
	if ((virtAddr & (NBPC-1)) || (physAddr & (NBPC-1))) {
		T_HAL(0x40000, printf("mPU: failed alignment "));
		goto mPUdone;
	}

	/* Check validity of range of virtual addresses. */
	if (virtAddr < srp->sr_base ||
	  (virtAddr + numBytes) >= (srp->sr_base + srp->sr_size)) {
		T_HAL(0x40000, printf("mPU: bad vaddr "));
		goto mPUdone;
	}

	/* Check validity of range of physical addresses. */
	/* if not in PHYS_MEM pool... */
	if (!physValid(physAddr, numBytes)) {

		/* get installed RAM physical addresses */
		unsigned int physLow = ctob((read16_cmos(LOMEM) + 3) >> 2);
		unsigned int physHigh = ctob((read16_cmos(EXTMEM) + 3) >> 2)
		  + ONE_MEG;

		T_HAL(0x40000, printf("physLow=%x physHigh=%x ",
		  physLow, physHigh));

		/* Fail if physical range overlaps installed base RAM. */
		if (physAddr < physLow) {
			T_HAL(0x40000, printf("mPU: overlap base RAM "));
			goto mPUdone;
		}

		/* Fail if physical range overlaps installed extended RAM. */
		if (physAddr < physHigh && (physAddr + numBytes) >= ONE_MEG) {
			T_HAL(0x40000, printf("mPU: overlap extended RAM "));
			goto mPUdone;
		}
	}

	/*
	 * For each click in user data segment which is to be remapped
	 *   if current click was taken from sysmem pool
	 *     return current click to sysmem pool
	 *   write new physical address into current click entry
	 *   mark current click as not coming from sysmem pool
	 *   map current click into page table
	 */
	clickOffset = btocrd(virtAddr - srp->sr_base);
	numClicks = numBytes >> BPCSHIFT;
	for (qp = pp + clickOffset, i = 0; i < numClicks; i++, qp++) {
		if ((*qp & SEG_NPL) == 0) {
			pno = segclick(*qp);
			if (!pvalid(pno)) {
				T_HAL(0x40000, printf("mPU: bad release "));
			} else {
				*sysmem.pfree++ = pno;
				T_HAL(0x40000,
				  printf("mPU: freeing virtual click %x ",
				  virtAddr + ctob(i)));
			}
		} else {
			T_HAL(0x40000,
			  printf("mPU: rewriting virtual NPL click %x ",
			  virtAddr + ctob(i)));
		}
		*qp = (physAddr + ctob(i)) | (SEG_RW | SEG_NPL);
		ptable1_v[btocrd(virtAddr) + i] = *qp;
	}
	mmuupd();
	ret = 1;

mPUdone:
	return ret;
}

/*
 * Add a click to a segment.
 * Enlarge buddy table for segment, if needed.
 *
 * Arguments:
 *	pp points to segment reference table (segp->s_vmem, e.g.)
 *	osz is old segment size, in clicks
 *
 * Return pointer to enlarged segment reference table, or NULL if failed.
 */
cseg_t *
c_extend(pp, osz) 
register cseg_t *pp;
int osz;
{
	register	cseg_t *pp1;
	register unsigned	pno;
	register int	i;
	SR		*srp;

	/* Fail if no more free clicks available. */
	if (sysmem.pfree < &sysmem.tfree[1])
		goto no_c_extend;

	/* Don't grow segment beyond hardware segment size (4 megabytes). */
	if (osz >= (NBPS/NBPC))
		goto no_c_extend;

	if (srp = loaded(pp)) {
		unload(srp);
		srp->sr_segp = 0;
	}

	/*
	 * If the old size was a power of 2, it has used up an entire
	 * buddy area, so we will need to allocate more space.
	 */
	if (IS_POW2(osz)) {
		if ((pp1 = (cseg_t*) arealloc(osz+1))==0)
			goto no_c_extend;
		for (i=0; i < osz; i++)
			pp1[i] = pp[i];
		areafree(pp, osz);
		pp = pp1;
	}

	for (i=osz; --i >= 0;)
		pp[i+1] = pp[i];

	pno = *--sysmem.pfree;
	if (!pvalid(pno))
		panic("c_extend");
	pp[0] = clickseg(pno) | SEG_RW;
	return pp;

no_c_extend:
	return 0;
}

/*
 * Given segment size in bytes, estimate total space needed
 * to keep track of the segment (I think - hws).
 *
 * return value is num_bytes plus some overhead...
 */
int
countsize(num_bytes)
int num_bytes;
{
	int ret;

	if (num_bytes <= NBPC/sizeof(long))
		ret = num_bytes+1;
	else
		ret = num_bytes
		  + ((num_bytes + NBPC/sizeof(long) - 1) >> BPC1SHIFT) + 1;
	return ret;
}

/*
 * buddy allocation 
 */

/*
 * Deallocate a segment descriptor area.
 * "sp" is not really a BLOCKLIST*, rather a cseg_t *.
 * "numClicks" is the number of clicks referenced in the area.
 */
void
areafree(sp, numClicks)
BLOCKLIST *sp;
int numClicks;
{
	register int	n;	/* adresse du buddy, taille du reste */
	register int	ix, nx;
	register	BLOCKLIST *buddy;

	areacheck(2, sp);

	/*
	 * Pointer "sp" points to an element in the sysmem table of
	 * free clicks.
	 * Integer "ix" is the index of "sp" into that table.
	 * Will use "ix" to index into one or more buddy tables.
	 */
	ix = sp - sysmem.u.budtab;
	n = areasize(numClicks);
	do {
		/* "nx" is index of buddy element to the one at "ix". */
		nx = BUDDY(ix, n);
		if (sysmem.budfree[nx>>WSHIFT] & 1<<(nx&(WCOUNT-1))) {
			/* coalesce two buddies */
			buddy = sysmem.u.budtab + nx; 
			if (buddy->kval != n)
				break;
			sysmem.budfree[nx>>WSHIFT] &= ~ (1<<(nx & (WCOUNT-1)));
			DELETE2(buddy);
			if (nx < ix) 
				ix = nx;
		} else
			break;
	} while (++n < NBUDDY);
	sysmem.budfree[ix>>WSHIFT] |= 1 << (ix & (WCOUNT-1));
	buddy = sysmem.u.budtab + ix;
	INSERT2(BLOCKLIST, buddy, &sysmem.bfree[n]);
	buddy->kval = n;
	areacheck(3, buddy);
}

/*
 * arealloc()
 *
 * Given size in "clicks" of a segment to manage,
 * return pointer to an array of enough descriptors.
 * If not enough free descriptors available, return 0.
 */
BLOCKLIST *
arealloc(clicks)
register int clicks;
{
	register	BLOCKLIST *sp;
	register	BLOCKLIST *p, *q;
	register int	size;
	BLOCKLIST	*rsp;
	register int	nx;

	areacheck(0, 0);
	size = areasize(clicks);
	/*
	 * 1. Find little end, bloc p, free >= size
	 */
	for (q = p = sysmem.bfree + size;p->forw == p; size++, p++)
		if (p >= sysmem.bfree + NBUDDY - 1) {
			return(0);	/* y en a pas */
		}

	rsp = p->forw;
	DELETE2(rsp);
	nx = rsp - sysmem.u.budtab;
	sysmem.budfree[nx>>WSHIFT] &= ~(1 << (nx & (WCOUNT-1)));
	size = 1<<size;
	sp = rsp + size; /* buddy address */
	while (p-- != q) {
		/*
		 * 2.1 The block is too big, uncouple & free buddy
		 */
		sp -= (size >>= 1);
		nx = sp - sysmem.u.budtab;
		sysmem.budfree[nx>>WSHIFT] |= 1 << (nx & (WCOUNT-1));
		INSERT2(BLOCKLIST, sp, p);
		sp->kval = p - sysmem.bfree;
	}
	areacheck(1, rsp);
	return rsp;
}

void
areainit(n)
{
	extern char __end[];
	register int i;

	for (i=0; i < (1<<(NBUDDY-WSHIFT)); i++)
		sysmem.budfree[i] = 0;
	for (i=0; i<NBUDDY; i++)
		INIT2(&sysmem.bfree[i]);
	sysmem.u.budtab = (BLOCKLIST *)__end;
	n /= sizeof(BLOCKLIST);
	if (n > (1 << NBUDDY))
		panic("areainit");
	for (i=0; i<n; i++)
		areafree(&sysmem.u.budtab[i], sizeof(BLOCKLIST)/sizeof(long));
}

/*
 * areasize()
 *
 * Do a log(base 2) calculation on n.
 * If n is zero, return -1.
 *
 * Else, consider the nearest power of two which is greater than or
 * equal to n
 *	p/2 < n <= p
 * Then set p = 4 * (2**x).  Note BLKSZ is 2.
 * Return max(x,0).
 *
 * If n is too large (more than 3F00), we will go beyond the limits of
 * table buddysize[].
 *
 * In practice, n is the total number of clicks needed in a segment,
 * and the return value will be used to access a buddy system list.
 */
int
areasize(n)
register unsigned int	n;
{
	register int m;
#ifdef FROTZ
	int ret, oldn = n;
#endif

	if (n > 0x3F00)
		panic("areasize");

	n = (n + (1 << BLKSZ) - 1) >> BLKSZ;
	m = n & 0x3F;
#ifdef FROTZ
	if ((n >>= 6) == 0)
		ret = buddysize[m];
	else {
		int index;

		index = n;
		if (m)
			index++;
		ret = buddysize[index] + 6;
	}
	return ret;
#else
	if ((n >>= 6) == 0)
		return buddysize[m];
	return buddysize[n + ((m!=0)?1:0)] + 6;
#endif
}

#define	MAXBUDDY	2048
#define	CHECK(p) ((p>=&sysmem.bfree[0] && p<&sysmem.bfree[NBUDDY]) || \
		(p>=sysmem.u.budtab && p<&sysmem.u.budtab[1<<NBUDDY]))
void
areacheck(flag, sp)
register	BLOCKLIST *sp;
{
	register	BLOCKLIST *next, *start;
	register int i, nx;

	if (sp) {
		if (&sysmem.u.budtab[sp-sysmem.u.budtab] != sp)
		  printf("*check* %d %x %x\n", flag, sp, sysmem.u.budtab);
	}
		
	for (i=0; i<NBUDDY; i++) {
		start = next = &sysmem.bfree[i];
		do {
			next = next->forw;
			if (!CHECK(next))
				printf("next = %x (%d)\n", next, flag);
			if (next->back != start)
				printf("%x->forw->back != %x\n", next, start);
			if (next != &sysmem.bfree[i]) {
				if (next->kval != i)
					printf("bad kval %x, %d (%d)\n",
						next, next->kval, flag);
				nx = next - sysmem.u.budtab;
				if ((sysmem.budfree[nx>>WSHIFT] & (1 << (nx & (WCOUNT-1)))) == 0)
					printf("in bfree but not budfree %x (%d)\n", next, flag);
			}
			start = next;
		} while (next != &sysmem.bfree[i]);
	}
}

MAKESR(physMem, _physMem);
int	PHYS_MEM = 0;		/* Number of bytes of contiguous RAM needed */

/*
 * A block of contiguous physical memory has been allocated for special
 * i/o devices.
 * Problem: clicks of physical memory are in reverse order in the
 * page table.
 * This routine reverses the page table entries for the pages
 * involved.  It relies *heavily* on all pages having virtual addresses
 * in the FFCx xxxx segment.
 *
 * If all goes well, assign physAvailStart to the virtual address of
 * the beginning of the region, and physAvailBytes to the number of bytes
 * in the region.  Otherwise, leave physAvailStart and physAvailBytes at 0.
 *
 * As memory is allocated, physAvailStart advances to point to the next
 * available byte of contiguous memory, physAvailBytes is decremented,
 * and physPoolStart remains set to the virtual address of the start of
 * the contiguous pool.
 */
static int	physPoolStart;	/* start of contiguous memory area */
static int	physAvailStart;	/* next free byte in contiguous memory area */
static int	physAvailBytes;	/* number of bytes in contiguous memory area */

/*
 * Check whether a range of physical addresses lies within the
 * pool of contiguous physical memory.
 */
int
physValid(base, numBytes)
unsigned int base, numBytes;
{
	int vpool;
	int ret = 0;

	if (PHYS_MEM) {
		vpool = vtop(physPoolStart);
		T_HAL(0x40000, printf("PHYS_MEM phys addrs %x to %x  ",
		  vpool, vpool + PHYS_MEM));
		if (base >= vpool && (base + numBytes) <= (vpool + PHYS_MEM))
			ret = 1;
	} else {
		T_HAL(0x40000, printf("No PHYS_MEM "));
	}

	T_HAL(0x40000, printf("physValid(%x, %x) = %d ", base, numBytes, ret));
	return ret;
}

void
physMemInit()
{
	int m, vaddr;
	int err = 0, num_clicks = btoc(PHYS_MEM);
	int prevPaddr, paddr;

	/*
	 * Going half way into page table for physMem
	 *   If entry and its complementary entry aren't both in top segment
	 *     Error exit (no phys mem will be available).
	 *   Get page table entries and swap them.
	 */
	for (m = 0; m < num_clicks/2; m++) {
		int m2 = num_clicks - 1 - m;	/* complementary index */

		/* compute virtual addresses */
		int lo_addr = physMem.sr_base + ctob(m);
		int hi_addr = physMem.sr_base + ctob(m2);

		/* compute indices into page table (ptable1_v) */
		int lo_p1ix = btocrd(lo_addr);
		int hi_p1ix = btocrd(hi_addr);

		/* fetch physical addresses from page table */
		int lo_paddr = ptable1_v[lo_p1ix];
		int hi_paddr = ptable1_v[hi_p1ix];

		/* abort if either address is not in top segment */
		if (btosrd(lo_addr) != 0x3FF) {
			err = 1;
			break;
		}
		if (btosrd(hi_addr) != 0x3FF) {
			err = 1;
			break;
		}

		/* exchange page table entries */
		ptable1_v[lo_p1ix] = hi_paddr;
		ptable1_v[hi_p1ix] = lo_paddr;
	}

	/*
	 * Final sanity check.
	 * In case someone gets creative with startup code, check
	 * again here that the memory is actually contiguous.
	 */
	prevPaddr = vtop(physMem.sr_base);
	for (m = 0; m < num_clicks - 1; m++) {
		paddr = vtop(physMem.sr_base + ctob(m + 1));
		if (paddr - prevPaddr != NBPC) {
			err = 1;
			break;
		}
		prevPaddr = paddr;
	}

	if (!err) {
		physPoolStart = physAvailStart = physMem.sr_base;
		physAvailBytes = PHYS_MEM;
	}
}

/*
 * Return virtual address of block of contiguous physical memory.
 * If request cannot be granted, return 0.
 *
 * Expect physMem resource to be granted during load routine of device
 * drivers.  Once allocated, memory is not returned to the physMem pool.
 */
char *
getPhysMem(numBytes)
unsigned int numBytes;
{
	char * ret = NULL;

	if (numBytes <= physAvailBytes) {
		ret = (char *)physAvailStart;
		physAvailStart += numBytes;
		physAvailBytes -= numBytes;
	} else
		printf("getPhysMem failed - %d additional bytes "
		  "PHYS_MEM needed\n", physAvailBytes - numBytes);
	return ret;
}

/*
 * Return virtual address of aligned block of contiguous physical memory.
 * Mainly for devices using the stupid Intel DMA hardware without
 *   scatter/gather.
 * If request cannot be granted, return 0.
 *
 * Argument "align" says what physical boundary we need alignment on.
 * It must be a power of 2.
 * For 4k alignment, align = 4k, etc.
 * Sorry, but will throw away memory to get to the next acceptable address.
 *
 * Once allocated, memory is not returned to the physMem pool.
 */
char *
getDmaMem(numBytes, align)
unsigned int numBytes;
unsigned int align;
{
	char * ret = NULL;
	int wastedBytes, neededBytes;

	if (align == 0) {
		printf("getDmaMem(0) (?)\n");
		goto getDmaMemDone;
	}

	if (!IS_POW2(align)) {
		printf("getDmaMem(%x) (?)\n", align);
		goto getDmaMemDone;
	}

	/*
	 * Waste RAM from bottom of pool up to physical
	 * address with desired alignment.
	 */
	wastedBytes = align - (vtop(physAvailStart) % align);
	neededBytes = numBytes + wastedBytes;

	if (neededBytes <= physAvailBytes) {
		ret = (char *)physAvailStart + wastedBytes;
		physAvailStart += neededBytes;
		physAvailBytes -= neededBytes;
	} else
		printf("getDmaMem failed - %d additional bytes "
		  "PHYS_MEM needed\n", physAvailBytes - neededBytes);

getDmaMemDone:
	return ret;
}
/***************/

#undef	ptable1_v

/*
 * pageDir is the physical address of the click in use for the page
 * directory, offset by ctob(SBASE - PBASE)
 */
#define	pageDir		((long *)(&stext[ctob(-1)]))

int total_clicks;	/* How many clicks did we start with?  */

void
mchinit()
{
	extern char __end[], __end_data[], stext[], __end_text[], sdata[];
	extern int RAM0, RAMSIZE;

	int lo;		/* Number of bytes of physical memory below 640K.  */
	int hi;		/* Number of bytes of physical memory above 1M.  */
	register char *pe; 
	register int zero = 0;
	register int	i;
	register	long *ptable1_v;
	register unsigned short	base;
	int	sysseg, codeseg, stackseg, ramseg, ptable1;
	int	ptoff;	/* An offset into pageDir[]  */
#if USE_NDATA
	int	dataseg[NDATA];
#else
	int	dataseg;
#endif
	int	nalloc;
	extern char	digtab[];
	static	SEG	uinit;
	int	budArenaBytes;	/* number of bytes in buddy pool */
	int	kerBytes;	/* number of bytes in kernel text and data */

	/*
	 * 1.
	 *   a. Relocate the data on a page boundary (4K bytes) the
	 *      bootstrap relocates it on a paragraph boundary (16 bytes)
	 *
	 *   b. Verify that the data has been relocated correctly 
	 */
	pe = __end_data;					/* 1.a */
	i = (((unsigned)__end_text+15) & ~15) - (unsigned)sdata;
	do {
		pe--;
		pe[0] = pe[i];
	} while (pe != sdata);					/* 1.b */

	/*
	 * Can now access the .data segment from C.
	 * If not, next loop will hang the kernel.
	 */
	CHIRP('A');
	while (digtab[0]!='0');
	CHIRP('*');

	/* Zero the bss. */
	pe = __end_data;
	do
		*pe++ = zero;
	while (pe != __end);

	/*
	 * Zero the level 0 page directory, which occupies the click
	 * of virtual space immediately below kernel text.
	 */
	pe = (char *) pageDir;
	do
		*pe++ = zero;
	while (pe != stext);

	CHIRP('2');

	/*
	 * 3. Calculate total system memory.
	 *    Count the space used by the system and the page
	 *    descriptors, the interrupt stack, and the refresh work area
	 *
	 * a. initialize allocation area and adjust system size
	 *    to take allocation area and free page area into account
	 */

	/*
	 * btoc(__end) - SBASE is the number of clicks in kernel text
	 * plus data, rounded up.
	 * PBASE is the starting physical click number of the kernel.
	 *
	 * Set sysmem.lo to the physical click address just past the kernel.
	 */
	DV(__end);

	kerBytes = __end - ((SBASE - PBASE)<<BPCSHIFT);
	DV(kerBytes);

	sysmem.lo = btoc(kerBytes);
	DV(sysmem.lo);

	/*
	 * lo is the size in bytes of memory between the end of the kernel
	 *	and the end of memory below 640K.
	 * hi is the size in bytes of memory over 1 Megabyte (Extended memory).
	 *
	 * Round the sizes from the CMOS down to the next click.  This
	 * compensates for systems where the CMOS reports sizes that are
	 * not multiples of 4K.
	 */
	DV(read16_cmos(LOMEM));
	lo = ctob(read16_cmos(LOMEM) >> 2) - ctob(sysmem.lo);
	DV(lo);

	DV(read16_cmos(EXTMEM));
	hi = ctob(read16_cmos(EXTMEM) >> 2);
	DV(hi);

	/*
	 * Sometimes, we die horribly if there is too much memory.
	 * Artificially limit hi to HACK_LIMIT.
	 */
	if (hi > HACK_LIMIT)
		hi = HACK_LIMIT;

	/* clear base memory above the kernel */
	CHIRP('z');
	zero_fill(ctob(sysmem.lo+SBASE-PBASE), lo);
	CHIRP('Z');

	/* clear extended memory */
	zero_fill(ONE_MEG+ctob(SBASE-PBASE), hi);
	CHIRP('Y');
	
	/* Record total memory for later use.  */
	total_mem = ctob(sysmem.lo) + lo + hi;
	DV(total_mem);

	/*
	 * sysmem.pfree and relatives will keep track of a pool of 4k pages
	 * assigned to processes, hereinafter known as the sysmem pool.
	 * How many clicks can go into this pool?  nalloc.
	 * Allow NBPC for the click itself, a short for the sysmem pointer,
	 * and SPLASH*sizeof(long) for buddy system overhead.
	 */
	nalloc = (lo+hi) / (sizeof(short) + SPLASH*sizeof(long) + NBPC);
	DV(nalloc);

	/*
	 * ASSERT:
	 * For the moment we want only to assure that the
	 * BUDDY arena and the stack of free pages will fit below
	 * 640K.
	 */
	budArenaBytes = SPLASH*nalloc*sizeof(long);
	DV(budArenaBytes);

#define SIZEOF_FREE_PAGES ((btoc(hi) + btoc(lo))* sizeof(short))
	T_PIGGY(0x800, {
		if (budArenaBytes + SIZEOF_FREE_PAGES >= lo) {
			panic("Too much memory");
		}
	});

	/*
	 * Initialize the buddy system arena.  This memory is used
	 * for the compressed page tables.
	 */
	areainit(budArenaBytes);

	/*
	 * Initialize the stack of free pages.
	 * __end is the virtual address just past kernel data
	 * Point sysmem.tfree to the lowest virtual address just above
	 * the buddy pool, and initialize sysmem.pfree there.
	 */
	sysmem.tfree = sysmem.pfree = 
	  (unsigned short *)(__end + budArenaBytes);
	DV(sysmem.tfree);

	/* sysmem.hi is the physical click number just past high RAM */
	sysmem.hi = btoc(hi+ONE_MEG);
	DV(sysmem.hi);

	/* base is the physical click number just past base RAM */
	base = sysmem.lo + (lo>>BPCSHIFT);
	DV(base);

	/*
	 * Adjust sysmem.lo to be the physical click number just above
	 * not just the kernel, but above sysmem overhead as well.
	 */
	sysmem.lo = btoc(kerBytes + budArenaBytes + nalloc*sizeof(short));
	DV(sysmem.lo);

	/*
	 * sysmem.vaddre is the virtual address of the next click after the
	 * kernel.
	 */
	sysmem.vaddre = ctob(sysmem.lo+SBASE-PBASE);
	DV(sysmem.vaddre);

	/* include in system area pages for arena, free area */

	CHIRP('3');

	/*
	 * 4.
	 *  Free the memory from [end, 640) kilobytes
	 *  Free the memory from [1024, 16*1024) kilobytes
	 *
	 *  We are building a stack of free pages bounded below
	 *  by sysmem.tfree and above by sysmem.efree.  sysmem.pfree
	 *  is the top of the stack.  The stack grows upwards.
	 */
	total_clicks = 0;

	/*
	 * Initialize the sysmem table (phase 1 - base RAM).
	 * Put base RAM above the kernel and sysmem overhead area into
	 * sysmem pool.
	 */
	while (base > sysmem.lo) {
		*sysmem.pfree++ = --base;
		++total_clicks;
	}

	/*
	 * Initialize the sysmem table (phase 2 - extended RAM).
	 * Put all extended RAM into the sysmem pool.
	 */
	base = btoc(ONE_MEG);
	while (base < sysmem.hi && total_clicks < nalloc) {
		*sysmem.pfree++ = base++;
		++total_clicks;
	}
	DV(total_clicks);

	/*
	 * Roundoff error may have made nalloc smaller than necessary.
	 */
	while(base < sysmem.hi) {
		if (sysmem.pfree + 1 >= sysmem.vaddre)
			break;
		*sysmem.pfree++ = base++;
		++total_clicks;
		nalloc++;
	}
	DV(total_clicks);
	DV(nalloc);

	/*
	 * sysmem.efree points just past the last pointer in the sysmem
	 * table.
	 */
	sysmem.efree = sysmem.pfree;
	DV(sysmem.efree);
	DV(allocno());

	T_PIGGY(0x800, {
		/*
		 * ASSERT:  The stack of free pages should end within a click
		 * of the lowest available memory.
		 */
		if ((cseg_t *)ctob(sysmem.lo+SBASE-PBASE) < sysmem.efree) {
			panic("sysmem.lo is too low");
		}

		if (sysmem.efree < (cseg_t *)ctob(sysmem.lo+SBASE-PBASE - 1)){
			panic("sysmem.efree is too low");
		}

		/*
		 * ASSERT:  There should be nalloc total_clicks.
		 */
		if (nalloc != total_clicks) {
			panic("nalloc != total_clicks ");
		}
	});

	CHIRP('4');

	/*
	 * 5. allocate page entries and initialize level 0 ^'s
	 * a. [ 00000000 .. 003FFFFF)		user code segment
	 * b. [ 00400000 .. 007FFFFF)		user data & bss
	 * c. [ 7FC00000 .. 7FFFFFFF)		user stack
	 *c.i.[ 80000000 .. 80FFFFFF)		ram disk
	 * d. [ FF800000 .. FFBFFFFF)		pointers to level 1 page table
	 * e. [ FFC00000 .. FFFFFFFF)		system process addresses
	 */
	codeseg = clickseg(*--sysmem.pfree);		/* 5.a */
	pageDir[0x000] = codeseg  | DIR_RW; 

#if USE_NDATA
	for (i = 0; i < NDATA; i++) {
		dataseg[i] = clickseg(*--sysmem.pfree);	/* 5.b */
		pageDir[0x001+i] = dataseg[i] | DIR_RW;
	}
#else
	dataseg = clickseg(*--sysmem.pfree);		/* 5.b */
	pageDir[0x001] = dataseg | DIR_RW;
#endif

	stackseg = clickseg(*--sysmem.pfree);		/* 5.c */
	pageDir[0x1FF] = stackseg  | DIR_RW; 

	/*
	 * ptable1 is a handle for the click containing page table
	 * entries for the page table.
	 *
	 * allocate a click for ptable1
	 * Then point at it from the page directory.
	 */
	ptable1 = clickseg(*--sysmem.pfree);		/* 5.d */
	pageDir[0x3FE] = ptable1 | DIR_RW; 

	sysseg = clickseg(*--sysmem.pfree);		/* 5.e */
	pageDir[0x3FF] = sysseg  | DIR_RW;

	CHIRP('5');

	/*
	 * 6. initialize  level 2 ^'s to [5.d]
	 */

	ptable1_v  = (long *)(ptable1 + ctob(SBASE-PBASE));
	DV(pageDir);
	DV(ptable1_v);
	ptable1_v[0x000] = codeseg | SEG_SRW;
#if USE_NDATA
	for (i = 0; i < NDATA; i++)
		ptable1_v[0x001+i] = dataseg[i] | SEG_SRW;
#else
	ptable1_v[0x001] = dataseg | SEG_SRW;
#endif
	ptable1_v[0x1FF] = stackseg| SEG_SRW;

	/*
	 * This ram disk stuff should go away once the scheme
	 * for allocating pieces of virtual memory space is in place.
	 */
	for (ptoff = btosrd(RAM0) & 0x3ff;
	  ptoff < (btosrd(RAM0 + 2 * RAMSIZE) & 0x3ff); ++ptoff) {
		ramseg =  clickseg(*--sysmem.pfree);		/* 5.c.i */
		pageDir[ptoff] = ramseg  | DIR_RW; 
		ptable1_v[ptoff] = ramseg | SEG_SRW;
	}

	ptable1_v[0x3FF] = sysseg  | SEG_SRW;

	CHIRP('6');

	/*
	 * 7.
	 * b. map kernel code and data
	 * 	map ^ to:
	 * c. 	level 0 page table
	 * d. 	level 1 page table
	 * e. 	I/O segments (video RAM, ...) 
	 */ 

	ptable1_v  = (long *)(sysseg + ctob(SBASE-PBASE));	/* 7.b */
	DV(ptable1_v);
	for (i = PBASE; i <sysmem.lo; i++)
		ptable1_v[i-PBASE] = clickseg(i) | SEG_SRW;

	ptable1_v[0x3FE] = clickseg(PTABLE0_P) | SEG_SRW;	/* 7.c */
	ptable1_v[0x3FD] = ptable1 | SEG_SRW;			/* 7.d */

	init_phy_seg(ptable1_v, ROM-SBASE,   0x0000F0000);	/* 7.e. */
	init_phy_seg(ptable1_v, VIDEOa-SBASE,0x0000B0000);
	init_phy_seg(ptable1_v, VIDEOb-SBASE,0x0000B8000);

	CHIRP('7');

	/*
	 * 8. allocate and map U area
	 */

	uinit.s_flags = SFSYST|SFCORE;
	uinit.s_size = UPASIZE;
	uinit.s_vmem = c_alloc(btoc(UPASIZE));
	ptable1_v[0x3FF] = *uinit.s_vmem | SEG_SRW;
	procq.p_segp[SIUSERP] = &uinit;

	CHIRP('8');

	/*
	 * 9. make FFC00000 and 00002000 map to the same address
	 * to prevent the prefetch after the instruction turning on
	 * paging from causing a page fault
	 */
	ptable1_v  = (long *)(codeseg + ctob(SBASE-PBASE));
	DV(ptable1_v);
	ptable1_v[PBASE] = clickseg(PBASE) | SEG_SRW;

	CHIRP('9');

	/*
	 * 10. load page table base address into MMU
	 *	fix up the interrupt vectors
	 */
	mmuupdnR0();
	CHIRP('U');
	idtinit();
	CHIRP('I');
}

typedef struct
{
	unsigned short	off_lo;
	unsigned short	seg;
	unsigned short	flags;
	unsigned short	off_hi;
} IDT;

/*
 * ldtinit()
 *
 * Fix up descriptors which are hard to create properly at compile/link time.
 * Apply to idt and ldt.
 *
 * Swap 16-bit words at descriptor+2, descriptor+6.
 */
void
idtinit()
{
	extern IDT	idt[], idtend[];
	extern IDT	ldt[], ldtend[];
	extern IDT	gdtFixBegin[], gdtFixEnd[];

	register IDT *ip;
	register unsigned short tmp;

	for (ip = idt; ip < idtend; ip++) {
		tmp = ip->off_hi;
		ip->off_hi = ip->seg;
		ip->seg = tmp;
	}

	for (ip = ldt; ip < ldtend; ip++) {
		tmp = ip->off_hi;
		ip->off_hi = ip->seg;
		ip->seg = tmp;
	}

	for (ip = gdtFixBegin; ip < gdtFixEnd; ip++) {
		tmp = ip->off_hi;
		ip->off_hi = ip->seg;
		ip->seg = tmp;
	}
}

void
init_phy_seg(ptable1_v, addr, base)
long	*ptable1_v;
{
	register int i;

	for (i=0; i<btoc(0x10000); i++) {
		ptable1_v[addr+i] = base | SEG_SRW; 
		base += NBPC;
	}
}

/*
 * Load up segmentation registers.
 */
SR	ugmtab[NUSEG];

void
segload()
{
	register int i;
	register	SR *start;

	/*
	 * 1. unprogram the currently active UGM user segments
	 *    reset ugmtab
	 */
	for (start = &ugmtab[1]; start < &ugmtab[NUSEG]; start++) {
		if (start->sr_segp)
			unload(start);
		start->sr_segp = 0;
	}

	/*
	 * 2. Load each segment in the p->p_region list into the MMU
	 *    Remember values in ugmtab.
	 */
	start = &ugmtab[1];
	for (i = 1; i < NUSEG; i++) {
		if (u.u_segl[i].sr_segp) {
			*start = u.u_segl[i];
			switch (i) {
			case SIPDATA:
				if (u.u_segl[SISTACK].sr_base)
					start->sr_size = min(start->sr_size,
					  (long)u.u_segl[SISTACK].sr_base-
					  u.u_segl[SISTACK].sr_size);
				break;
			case SISTACK:
				start->sr_base -= start->sr_size;
				break;
			}

			start->sr_segp = 0;
			if (SELF->p_segp[i]) {
				start->sr_segp = SELF->p_segp[i];
				doload(start);
			}
			start++;
		}
	}

	/* 3.  Update shm segment information. */
	shmLoad();
}

SR *
loaded(pp)
register cseg_t *pp;
{
	register SR	*start;

	for (start = ugmtab; start < ugmtab + NUSEG; start++) {
		if (start->sr_segp && start->sr_segp->s_vmem == pp) {
			return start;
		}
	}
	return 0;
}

MAKESR(r0stk, _r0stk);
extern int tss_sp0;

/*
 * General initialization
 */
void
i8086()
{
	unsigned	csize, isize, ssize, allsize;
	caddr_t	base;
	unsigned int	calc_mem, boost;

	/* This is the first C code executed after paging is turned on. */

	workPoolInit();

	/*
	 * Allocate contiguous physical memory if PHYS_MEM is patched
	 * to a nonzero value.
	 */
	if (PHYS_MEM) {
		physMem.sr_size = (PHYS_MEM+NBPC-1)&~(NBPC-1);
		valloc(&physMem);
		physMemInit();
	}

	/*
	 * Allocate a click for ring 0 stack.
	 */
	r0stk.sr_size = NBPC;
	valloc(&r0stk);
	tss_sp0 = r0stk.sr_base + NBPC;

	/*
	 * calc_mem is used for autosizing buffer cache and kalloc pool.
	 * It is total_mem, limited below by 1 meg and above by 12 meg.
	 * The upper limit is a temporary move to allow booting on 16 Meg
	 * systems.
	 *
	 * "boost" is used in autosizing buffer cache and kalloc pool.
	 * It is the number of megabytes of calc_mem above 1 meg, i.e.,
	 * a number between 0 and 11.
	 */
	if (total_mem < ONE_MEG)
		calc_mem = ONE_MEG;
	else if (total_mem > 12 * ONE_MEG)
		calc_mem = 12 * ONE_MEG;
	else
		calc_mem = total_mem;

	boost = (calc_mem - ONE_MEG) / ONE_MEG;

	/*
	 * If the number of cache buffers was not explicitly set (i.e., !0)
	 * then calculate the number of buffers using the simple heuristic:
	 *     128 minimum + 400 per MB of available RAM (i.e., after 1MB)
	 */
	if (NBUF == 0)
		NBUF = 128 + (400 * boost);

	/*
	 * If the amount of kalloc() space was not explicitly set (i.e., !0)
	 * then calculate using the simple heuristic:
	 *     64k minimum + 32k per MB of available RAM (i.e., after 1MB)
	 */
	if (ALLSIZE == 0)
		ALLSIZE = 65536 + (32768 * boost);

	blockp.sr_size = NBUF*BSIZE;
	valloc(&blockp);

	allocp.sr_size= allsize = NBUF*sizeof(BUF) + ALLSIZE;
#if USE_SLOT
	allocp.sr_size += ssize = NSLOT * (sizeof(int) + slotsz);
#else
	ssize = 0;
#endif
	allocp.sr_size += isize = NINODE* sizeof(INODE);
	allocp.sr_size += csize = NCLIST* sizeof(CLIST);
	valloc(&allocp);
	base = allocp.sr_base;
	allkp = setarena(base, allsize);
	base += allsize;
#if USE_SLOT
	slotp = (int *)base;
	base += ssize;
#endif
	inodep = (INODE*) base;
	base += isize;
	clistp = (paddr_t)base;
}

/*
 * Allocate srp->sr_size bytes of physical memory, and map it into
 * virtual memory space.  At the end, the struct at srp will describe
 * the new segment.
 */
void
valloc(srp)
SR	*srp;
{
	register int npage;

	/*
	 * If we've run out of virtual memory space, panic().
	 *
	 * A more graceful solution is needed, but valloc() does
	 * not provide a return value.
	 */
	if (sysmem.vaddre + srp->sr_size > MAX_VADDR) {
		panic("valloc: out of virtual memory space");
	}

	npage = btoc(srp->sr_size);

	srp->sr_base = sysmem.vaddre;
	srp->sr_segp->s_size = srp->sr_size;
	srp->sr_segp->s_vmem = c_alloc(npage);
	srp->sr_segp->s_flags = SFSYST|SFCORE;
	doload(srp);

	sysmem.vaddre += ctob(npage);
}

/*
 * See if the given process may fit in core.
 */
int
testcore(pp)
register PROC *pp;
{
	return 1;
}

/*
 * Calculate segmentation for a
 * new program. If there is a stack segment
 * present merge it into the data segment and
 * relocate the argument list.
 * Make sure that the changes are reflected in the u.u_segl array
 * which sproto sets up.
 */
int
mproto()
{
	return 1;
}

int
accdata(base, count)
unsigned	base, count;
{
	SR *srp;

	srp = &u.u_segl[SIPDATA];
	return base>=srp->sr_base && base+count <= srp->sr_base+srp->sr_size;
}

int
accstack(base, count)
unsigned	base;
{
	SR *srp;

	srp = &u.u_segl[SISTACK];
	return base>=srp->sr_base-srp->sr_size && base+count<=srp->sr_base;
}

int
acctext(base, count)
unsigned	base;
{
	SR *srp;

	srp = &u.u_segl[SISTEXT];
	return base>=srp->sr_base && base+count <= srp->sr_base+srp->sr_size;
}

printhex(v, max)
unsigned long v;
{
	register int i;

	for (i = max-1; i>=0; --i) 
		putchar(digtab[(v >> (i*4)) & 0xF]);
}

/* Read a 16 byte number from the CMOS.  */
unsigned int
read16_cmos(addr)
unsigned int addr;
{
        unsigned char read_cmos();
	
	return((read_cmos(addr+1)<<8) + read_cmos(addr));
} /* read16_cmos() */

int
c_grow(sp, new_bytes)
SEG *sp;
int new_bytes;
{
	register int	i;
	register cseg_t *pp;
	int		new_clicks, pno, nsize, old_clicks;
	SR		*srp;

	T_PIGGY(0x8000000, printf("c_grow(sp: %x, new: %x)", sp, new_bytes););

	new_clicks = btoc(new_bytes);
	old_clicks = btoc(sp->s_size);

	if (new_clicks == old_clicks) {
		goto ok_c_grow;
	}

	if (new_clicks < old_clicks) {
		printf("%s:can't contract segment\n",u.u_comm);
		goto no_c_grow;
	}

	if (new_clicks - old_clicks > allocno()) {
		goto no_c_grow;
	}

	T_PIGGY(0x8000000, printf("nc: %x, oc: %x,",new_clicks,old_clicks););

	/*
	 * Allocate a new descriptor vector if necessary.
	 * pp is the element corresponding to the virtual address
	 * "0"(sr_base)
	 */
	pp = sp->s_vmem;
	nsize = areasize(new_clicks);
	if (nsize != areasize(old_clicks)
	  && !(pp = (cseg_t*)arealloc(new_clicks))) {
		T_PIGGY(0x8000000,
			 printf("Can not allocate new descriptor."););
		goto no_c_grow;
	}

	T_PIGGY(0x8000000, printf("new pp: %x", pp););

	if (0 != (srp = loaded(sp->s_vmem))) {
		T_PIGGY(0x8000000, printf("unloading srp: %x, ", srp););
		unload(srp);
		srp->sr_segp = 0;
	}

	/*
	 * Allocate new descriptors.
	 */
	T_PIGGY(0x8000000, printf("new desc: ["););
	for (i = old_clicks; i < new_clicks; i++) {
		pno = *--sysmem.pfree;
		pp[i] = clickseg(pno) | SEG_RW;
		T_PIGGY(0x8000000, printf("%x, ", pp[i]););
	}
	T_PIGGY(0x8000000, printf("]"););

	/*
	 * Copy unchanged descriptors and free old vector if necessary.
	 */
	if (pp != sp->s_vmem) {
		T_PIGGY(0x8000000, printf("old desc: ["););
		for (i = 0; i < old_clicks; i++) {
			pp[i] = sp->s_vmem[i];
			T_PIGGY(0x8000000, printf("%x, ", pp[i]););
		}
		T_PIGGY(0x8000000, printf("]"););
		areafree((BLOCKLIST*)sp->s_vmem, old_clicks);
	}

	sp->s_vmem = pp;

	/*
	 * clear the added clicks
	 *
	 * MAPIO macro - convert array of page descriptors, offset
	 *   into system global address.
	 */
	T_PIGGY(0x8000000, printf("dmaclear(%x, %x, 0)", 
				ctob(new_clicks - old_clicks),
				MAPIO(sp->s_vmem, ctob(old_clicks))
			   );
	); /* T_PIGGY() */

	dmaclear(ctob(new_clicks - old_clicks),
	  MAPIO(sp->s_vmem, ctob(old_clicks)), 0);

ok_c_grow:
	return 0;

no_c_grow:
	return -1;
}
@


1.13
log
@kernel 73: allow individual shm seg references to be RW/RO
@
text
@a24 3
#define DISP_VAR(v)	{ strchirp("  "#v"="); print32(v); }
#define DV(v)		T_PIGGY(0x400, DISP_VAR(v))

d306 10
d319 1
d326 1
d330 4
d718 30
d749 22
a1485 210
#if 0
/*
 * msigstart(signum, func)
 *
 * signum is 1-based signal number
 * func points to signal handler in user text,
 *   or func is magic value (SIG_DFL, etc.)
 *
 * This routine will set up the stack as shown before entering the user
 * signal handler:
 *
 *	ndp/emulator context (struct _fpstate or struct _fpemstate or absent)
 *	ndp/emulator flags
 *	fpstackframe:
 *		wsp (Weitek context pointer - always null, but part of BCS)
 *		fpsp (floating point context pointer, possibly null)
 *		CPU register set (SS+1 long registers)
 *		1-based signal number
 *	u.u_sigreturn (in place of user return address)
 */

/*
 * A special define for signal stack arithmetic:
 * Will copy at least u_sigreturn, _fpstackframe, and ndpFlags.
 */
#define SIG_AREA_BASE	(sizeof(struct _fpstackframe) + 2 * sizeof(long))

void
msigstart(signum, func)
{
	register int uesp;
	int sphi, splo;
	SEG * segp;
	cseg_t * pp;
	int sigArea;	/* number of bytes written to user's stack */
	int fpsp;

	--signum;	/* convert to zero-based signal number */
	if (SELF->p_dsig & (1<<signum))
		SELF->p_hsig |= 1 << signum;

	/*
	 * Will copy at least u_sigreturn, _fpstackframe, and ndpFlags.
	 * If using ndp, need room for an _fpstate.
	 * If emulating, need room for an _fpemstate.
	 */
	sigArea = SIG_AREA_BASE;
	if (rdNdpUser())
		sigArea += sizeof(struct _fpstate);
	else if (rdEmTrapped())
		sigArea += sizeof(struct _fpemstate);
	uesp = u.u_regl[UESP] - sigArea;

	/* Add a click to user stack if necessary. */
	segp = u.u_segl[SISTACK].sr_segp;
	sphi = (XMODE_286) ? ISP_286 : ISP_386;
	splo = sphi - segp->s_size;

	if (splo > uesp) {
		pp = c_extend(segp->s_vmem, btoc(segp->s_size));
		if (pp==0) {
			printf("Signal failed.  cmd=%s  c_extend(%x,%x)=0 ",
			  u.u_comm, segp->s_vmem, btoc(segp->s_size));
			return;
		}

		segp->s_vmem = pp;
		segp->s_size += NBPC;
		if (sproto(0)==0) {
			printf("Signal failed.  cmd=%s  sproto(0)=0 ",
			  u.u_comm);
			return;
		}

		segload();
	}

	/*
	 * Set the ndp/emulator context pointer fpsp.
	 * Fp context is immediately above SIG_AREA_BASE.
	 */
	if (rdNdpUser() || rdEmTrapped())
		fpsp = uesp + SIG_AREA_BASE;
	else
		fpsp = 0;

	/*
	 * Write fpsp and wsp (Weitek state pointer always null).
	 */
	putuwd(uesp + (SS+3) * sizeof(long), fpsp);
	putuwd(uesp + (SS+4) * sizeof(long), 0);

	kucopy(u.u_regl, uesp + 2*sizeof(long), (SS+1) * sizeof(long));
	putuwd(uesp+sizeof(long), signum+1);
	putuwd(uesp, u.u_sigreturn);
	u.u_regl[EFL] &= ~MFTTB;
	u.u_regl[EIP] = func;
	u.u_regl[UESP] = uesp;
	if (signum+1 != SIGTRAP)
		u.u_sfunc[signum] = SIG_DFL;

	/*
	 * We are about to enter a signal handling function for the process.
	 * If current process is using ndp
	 *   copy ndp state and related flags into signal handler stack
	 *   mark the process as not using ndp
	 *   arm EM traps in case signal handler uses ndp
	 * Else if process is using emulator
	 *   copy emulator state and flags into signal handler stack
	 *   mark the process as not using emulator
	 * Else
	 *   put ndp/emulator flags on stack
	 */
	if (rdNdpUser()) {
		/* if ndp state not saved yet for this process, save it now */
		if (!rdNdpSaved()) {
			ndpSave(&u.u_ndpCon);
			wrNdpSaved(1);
		}

		putuwd(uesp + (SS+5) * sizeof(long), u.u_ndpFlags);

		kucopy(&u.u_ndpCon, fpsp, sizeof(struct _fpstate));
		ndpDetach();

		wrNdpUser(0);
		wrNdpSaved(0);
		ndpEmTraps(1);
	} else if (rdEmTrapped()) {
		putuwd(uesp + (SS+5) * sizeof(long), u.u_ndpFlags);

		kucopy(&u.u_ndpCon, fpsp, sizeof(struct _fpemstate));

		wrEmTrapped(0);
	} else {
		putuwd(uesp + (SS+5) * sizeof(long), u.u_ndpFlags);
	}
}

void
msigend(gs, fs, es, ds, edi, esi, ebp, esp, ebx, edx, ecx, eax, trapno, err,
	eip, cs, efl, uesp, ss)
{
	register int signo;
	register PROC *pp = SELF;
	int savedNdpFlags;
	int sigNdpUser;

	u.u_regl = &gs;

	/*
	 * BOGUS - assumes nothing clobbers user stack.
	 * There is a small probability that the u_sigreturn code,
	 * which is
	 *	add	$4,%esp
	 *	lcall	$0xf,$0
	 * might get a signal hit between the first and second instructions.
	 * This will clobber the value being fetched to signo.
	 */
	signo = getuwd(uesp-sizeof(long)) - 1; 

	savedNdpFlags = getuwd(uesp + (SS+3) * sizeof(long));

	sigNdpUser = rdNdpUser();
	u.u_ndpFlags = savedNdpFlags;

	/*
	 * We are about to leave a signal handling function for this process.
	 * If signal function for this process was using ndp
	 * And main process was *not* using ndp
	 *   Detach signal function from ndp
	 *   Restore current EM to its pre-signal value.
	 * If main process *was* using ndp
	 *   restore its ndp state and make it ndp owner again.
	 * If main process was using emulator
	 *   restore emulator state.
	 */
	if (sigNdpUser && !rdNdpUser()) {
		ndpDetach();
		ndpEmTraps(1);
	}

	if (rdNdpUser()) {
		ndpEmTraps(0);
		ukcopy(uesp + (SS+4)*sizeof(long), &u.u_ndpCon,
		  sizeof(struct _fpstate));
		ndpRestore(&u.u_ndpCon);
		wrNdpSaved(0);
		ndpMine();
	} else if (rdEmTrapped()) {
		ukcopy(uesp + (SS+4)*sizeof(long), &u.u_ndpCon,
		  sizeof(struct _fpemstate));
	}

	/* Restore process state to pre-signal values. */
	ukcopy(uesp, u.u_regl, (SS+1) * sizeof(long));

	/*
	 * if the signal has been sigset
	 * simulate a sigrelse(signal)
	 */
	if (pp->p_hsig & 1<<signo) {
		pp->p_hsig &= ~(1 << signo);
		if (nondsig()) {
			actvsig();
		}
	}
}
#endif

@


1.12
log
@hal: kernel 72
@
text
@d104 9
a112 4
	switch (flags&(SFSYST|SFTEXT)) {
	case SFTEXT:	akey = SEG_RO;  break;
	case SFSYST:	akey = SEG_SRW; break;
	default:	akey = SEG_RW;  break;
d1207 2
a1208 2
						u.u_segl[SISTACK].sr_base-
						   u.u_segl[SISTACK].sr_size);
d1252 1
a1252 1
	vaddr_t	base;
@


1.11
log
@hal: kernel 71: added shm support
@
text
@d148 1
a148 1
	/* Do we have enough free phsycial clicks for this request?  */
d295 1
a295 1
		ptable1_v[btocrd(physAddr) + i] = *qp | SEG_RW;
d719 2
d1045 2
a1046 1
	for (ptoff = 0x200; ptoff < 0x204; ++ptoff) {
d1416 1
d1423 12
d1436 7
d1458 3
a1460 10
	 * Make room on user stack for a struct _fpstackframe.
	 * And a fake return address (u_sigreturn).
	 * And current EM.
	 * Call this user area "fpf".
	 * Weitek state pointer fpf.wsp = NULL.
	 * Copy register set into fpf.regs[].
	 * Copy 1-based signal number into fpf.signo.
	 * Copy u.u_sigreturn into user stack just below fpf.
	 * Copy current Em just above fpf.
	 * Maybe copy ndp state above current EM.
d1462 1
a1462 6

	/*
	 * Will copy at least an _fpstackframe, u_sigreturn, and currentEM.
	 * If process is using ndp, will also copy an _fpstate.
	 */
	sigArea = sizeof(struct _fpstackframe) + 2 * sizeof(long);
d1465 2
d1493 6
a1498 2
	if (rdNdpUser())
		fpsp = uesp + (SS+6)*sizeof(long);
d1501 4
d1507 1
d1520 1
d1523 5
d1538 1
a1538 2
		kucopy(&u.u_ndpCon, uesp + (SS+6)*sizeof(long),
		  sizeof(u.u_ndpCon));
d1544 6
d1581 1
d1590 2
d1601 1
a1601 1
		  sizeof(u.u_ndpCon));
d1605 3
d1624 1
@


1.10
log
@hal: add DV() macro for debugging: fix startup arithmetic bug
@
text
@d25 3
d703 1
a705 2
#undef	ptable0_v
#define	ptable0_v	((long *)(&stext[ctob(-1)]))
d707 6
d727 1
a727 1
	int	ptoff;	/* An offset into ptable0_v[]  */
d771 1
a771 1
	pe = (char *) ptable0_v;
a777 3
#define DISP_VAR(v)	{ strchirp("  "#v"="); print32(v); }
#define DV(v)		T_PIGGY(0x400, DISP_VAR(v))

d993 1
a993 1
	ptable0_v[0x000] = codeseg  | DIR_RW; 
d998 1
a998 1
		ptable0_v[0x001+i] = dataseg[i] | DIR_RW;
d1002 1
a1002 1
	ptable0_v[0x001] = dataseg | DIR_RW;
d1006 1
a1006 1
	ptable0_v[0x1FF] = stackseg  | DIR_RW; 
d1008 7
d1016 1
a1016 1
	ptable0_v[0x3FE] = ptable1 | DIR_RW; 
d1019 1
a1019 1
	ptable0_v[0x3FF] = sysseg  | DIR_RW;
d1028 2
d1045 1
a1045 1
		ptable0_v[ptoff] = ramseg  | DIR_RW; 
d1063 1
d1094 1
d1215 3
d1247 4
@


1.9
log
@hal:kernel68: added window server support
@
text
@d331 1
a331 1
	for (i=osz; --i >= 0; )
d725 1
a725 1
	int	nalloc, diff;
d728 2
d738 1
a738 1
	pe = __end_data;						/* 1.a */
d753 1
a753 4
	/*
	 * 2. Zero the bss
	 *    Zero the level 0 page directory
	 */ 
d759 4
d770 3
d779 1
a779 1
	 *	to take allocation area and free page area into account
a780 1
	sysmem.lo = btoc((unsigned)__end) - SBASE + PBASE;
d783 15
d806 1
d808 3
d812 1
a813 11
	T_PIGGY( 0x400, {
		strchirp(" cmos lo: ");
		print16(read16_cmos(LOMEM));
		strchirp(" cmos hi: ");
		print16(read16_cmos(EXTMEM));
		strchirp(" lo: ");
		print32(lo);
		strchirp(" hi: ");
		print32(hi);
	} );

d821 1
d825 2
d832 1
d834 7
d842 2
d850 6
a855 5
#define SIZEOF_BUDDY ( (unsigned)SPLASH*nalloc*sizeof(long) )
#define SIZEOF_FREE_PAGES ( ( btoc(hi) + btoc(lo) )* sizeof(short) )
	T_PIGGY( 0x800, {
		if ( SIZEOF_BUDDY + SIZEOF_FREE_PAGES >= lo ) {
			strchirp("Too much memory");
d858 1
a858 1
	} );
a859 1

d864 1
a864 1
	areainit(SPLASH*nalloc*sizeof(long));
d868 3
d873 2
a874 1
		(unsigned short *)(__end + SPLASH*nalloc*sizeof(long));
d876 5
a880 1
	sysmem.hi = btoc(hi+1024*1024);
d882 13
a894 2
	diff = ((lo + hi) >> BPCSHIFT) - nalloc;
	sysmem.lo += diff;	
d896 2
d912 6
d923 6
a928 2
	base = btoc(1024*1024);
	while (base < sysmem.hi) {
d932 1
d934 17
d952 2
d955 1
a955 12
	T_PIGGY( 0x400, {
		strchirp("  sysmem.efree: ");
		print32(sysmem.efree);
		strchirp("  nalloc: ");
		print32(nalloc);
		strchirp("  total_clicks: ");
		print32(total_clicks);
		strchirp("  allocno(): ");
		print32(allocno());
	} );

	T_PIGGY( 0x800, {
d960 1
a960 5
		if ( (cseg_t *)ctob(sysmem.lo+SBASE-PBASE) < sysmem.efree ) {
			strchirp("sysmem.lo is too low: ");
			print32(ctob(sysmem.lo+SBASE-PBASE));
			strchirp("  sysmem.efree: ");
			print32(sysmem.efree);
d964 1
a964 5
		if ( sysmem.efree < (cseg_t *)ctob(sysmem.lo+SBASE-PBASE - 1)){
			strchirp("sysmem.efree is too low: ");
			print32(sysmem.efree);
			strchirp("  sysmem.lo-1: ");
			print32(ctob(sysmem.lo+SBASE-PBASE - 1));
d971 1
a971 5
		if ( nalloc != total_clicks ) {
			strchirp("nalloc != total_clicks: ");
			print32(nalloc);
			strchirp(" != ");
			print32(total_clicks);
d974 1
a974 1
	} );
d976 1
a976 9
	/*
	 * We may want to be able to stop at this point so we can see
	 * anything that has just been printed.
	 */
	T_PIGGY( 0x80, {
		for (;;) {
			/* DO NOTHING FOREVER */
		}
	} );
a977 2
	CHIRP('4');

d980 6
a985 6
	 * a. [ 00000000 .. 003FFFFF )		user code segment
	 * b. [ 00400000 .. 007FFFFF )		user data & bss
	 * c. [ 7FC00000 .. 7FFFFFFF )		user stack
	 *c.i.[ 80000000 .. 80FFFFFF )		ram disk
	 * d. [ FF800000 .. FFBFFFFF )		pointers to level 1 page table
	 * e. [ FFC00000 .. FFFFFFFF )		system process addresses
d1229 2
a1230 1
	 * Allocate a click for ring 0 stack.
d1563 1
a1563 1
printhex( v, max)
d1592 1
a1592 1
	T_PIGGY( 0x8000000, printf("c_grow(sp: %x, new: %x)", sp, new_bytes); );
d1610 1
a1610 1
	T_PIGGY( 0x8000000, printf("nc: %x, oc: %x,",new_clicks,old_clicks); );
d1621 2
a1622 2
		T_PIGGY( 0x8000000,
			 printf("Can not allocate new descriptor."); );
d1626 1
a1626 1
	T_PIGGY( 0x8000000, printf("new pp: %x", pp); );
d1629 1
a1629 1
		T_PIGGY( 0x8000000, printf("unloading srp: %x, ", srp); );
d1637 1
a1637 1
	T_PIGGY( 0x8000000, printf("new desc: ["); );
d1641 1
a1641 1
		T_PIGGY( 0x8000000, printf("%x, ", pp[i]); );
d1643 1
a1643 1
	T_PIGGY( 0x8000000, printf("]"); );
d1649 1
a1649 1
		T_PIGGY( 0x8000000, printf("old desc: ["); );
d1652 1
a1652 1
			T_PIGGY( 0x8000000, printf("%x, ", pp[i]); );
d1654 1
a1654 1
		T_PIGGY( 0x8000000, printf("]"); );
d1666 1
a1666 1
	T_PIGGY( 0x8000000, printf("dmaclear(%x, %x, 0)", 
d1669 1
a1669 1
			    );
@


1.8
log
@kernel 67 upd by hal for fpu suppt.
@
text
@a23 1
#define SUNLOAD		0
d108 1
a108 1
		ptable1_v[base1++] = *pp++ | akey;
a112 1

d168 5
a172 2
 * free core space
 * sz - allocated size
d175 1
a175 1
c_free(pp, size)
d177 1
a177 1
unsigned	size;
a183 3
#if SUNLOAD
	sunload(pp);
#else
d188 1
a188 2
#endif
	sz = size;
d193 9
a201 4
		pno = segclick(*qp++);
		if (!pvalid(pno))
			panic("c_free");
		*sysmem.pfree++ = pno;
d203 1
a203 1
	areafree((BLOCKLIST *)pp, size);
d206 95
a312 3
#if SUNLOAD
	sunload(pp);
#else
a316 1
#endif
d369 3
a371 1
 * allocate a segment descriptor area;
d374 1
a374 1
areafree(sp, sz)
d376 1
a376 1
int sz;
d383 7
d391 1
a391 1
	n = areasize(sz);
d393 1
d396 1
d581 5
d587 2
a588 1
static int	physAvailStart;	/* virtual address of contiguous memory area */
d591 25
d675 1
a675 1
		physAvailStart = physMem.sr_base;
a1155 1
#if !SUNLOAD
a1168 1
#endif
a1169 1
/*XXX*/
a1581 3
#if SUNLOAD
	sunload(sp->s_vmem);
#else
a1586 1
#endif
a1634 16

#if SUNLOAD
void
sunload(pp)
register	cseg_t *pp;
{
	register	SR	*start;

	for (start = ugmtab; start < &ugmtab[NUSEG]; start++) {
		if (start->sr_segp && start->sr_segp->s_vmem==pp) {
			unload(start);
			start->sr_segp = 0;
		}
	}
}
#endif
@


1.7
log
@Hal: kernel 67: added code for i387 suppt and ndp sensing
@
text
@d1291 2
@


1.6
log
@kernel 66: floating point context switching, exceptions and signal handlers.
@
text
@a1304 5
		/*
		 * Other OS's couldn't get "sw" right the first time.
		 * We did, so we just copy it to "status".
		 */
		u.u_ndpCon.status = u.u_ndpCon.sw;
@


1.5
log
@hal: kernel 64: add PHYS_MEM and getPhysMem() for NCM and others
(allocate blocks of contiguous physical memory)
@
text
@a7 1
#include <sys/reg.h>
a10 1
#include <sys/proc.h>
a12 1
#include <sys/uproc.h>
d1212 7
d1220 1
a1220 1
msigstart(n, f)
d1223 5
d1229 56
a1284 5
	--n;
	if (SELF->p_dsig & (1<<n))
		SELF->p_hsig |= 1 << n;
	uesp = u.u_regl[UESP] - sizeof(struct _fpstackframe);
	putuwd(uesp + (SS+3) * sizeof(long), 0);
d1286 1
a1286 1
	putuwd(uesp+sizeof(long), n+1);
d1289 1
a1289 1
	u.u_regl[EIP] = f;
d1291 31
d1330 2
d1334 10
d1345 29
d1375 1
a1382 1
			T_PIGGY( 0x100, printf("actvsig(mmu)"); );
@


1.4
log
@update by hal for kernel 61
@
text
@d68 1
d75 1
d465 104
d636 2
a637 2
	 * 3. Calculate total system memory in taking
	 *    into account the space used by the system and the page
d681 1
a681 1
	/* Record the total memory for later use.  */
d910 1
a910 1
	mmuupd();
d937 2
d942 1
a942 1
	for (ip = idt; ip <idtend; ip++) {
d948 1
a948 1
	for (ip = ldt; ip <ldtend; ip++) {
d953 6
d1057 9
a1079 1
#ifndef FOO
a1087 1
#endif
@


1.3
log
@hal: ring1, replaced zero_fill() with memset() (Steve's idea)
@
text
@a1134 58
int	evin, evout;
extern	trapcode;
EVENT	evtab[NEV];

EVENT *
evtrap()
{
	EVENT *evp;

	evp = &evtab[evin++ & (NEV-1)];
	evp->pid = SELF->p_pid;
	kkcopy(u.u_regl, evp->r, sizeof(evp->r));
	evp->err = 0;
	evp->res = 0;
	return evp;
}

evput(n)
{
	int	id;
	register EVENT *evp;
	if (evout < evin-n) 
		evout = evin-n;
	while (evout<evin) {
		evp = &evtab[evout++ & (NEV-1)];
		evprint(evp);
		if (evout==evin) { /* last one */			
			id = evp->r[ERR];
			if (id==14)
				printf("    cr2 = %x, ", regcr2());
			if (0x7B00 & (1<<id)) /* 8, 10, 11-14 */
				printf("code = %x\n", trapcode&0xFFFF);
/*			evdump(NBPS + (evp->r[EIP]&~0xFF));		*/
			evtrace(evp);
		}
	}
}

#define	NWDLINE	8

evdump(where)
unsigned	where;
{
	register int save;
	unsigned	i, j;

	save = setspace(SEG_386_KD);
	for (i = where; i<where+256; i+= NWDLINE*sizeof(long)) {
		printhex(i, 5);
		for (j = 0; j<NWDLINE*sizeof(long); j += sizeof(long)) {
			putchar(' ');
			printhex(getuwd(i + j), 8);
		}
		putchar('\n');
	}
	setspace(save);
}

a1143 109
evprint(evp)
register EVENT *evp;
{
	int	id;
	register int	i;

	id = evp->r[ERR];
	printf("%d:%x: ", evp->pid, id);
	printf("<isb>p %x %x %x <abcd>x %x %x %x %x ",
		evp->r[EIP], evp->r[UESP], evp->r[EBP],
		evp->r[EAX], evp->r[EBX], evp->r[ECX], evp->r[EDX]);
	if (id==SISYS || id==SIOSYS) {
		printf("%x(", evp->func);
		for (i=1; i<=evp->a[0]; i++)
			printf("%x ", evp->a[i]);
		printf(") = ");
		if (evp->err)
			printf("[%d]", evp->err);
		else
			printf("%x", evp->res);
	}
	putchar('\n');
}

evtrace(evp)
EVENT *evp;
{
	register int	save;

	printf("trace: ");
	save = setspace(SEG_386_KD);

	switch (evp->r[CS]&0xFFFF) {
	case SEG_286_UII+R_USR:
	case SEG_286_UI+R_USR:
		evtrace16(evp->r[EBP], 0, ISP_286);
		break;
	case SEG_386_KI:
	case SEG_386_II:
		evtrace32(evp->r[EBP], &u, (char *)&u + UPASIZE - 1);
		break;
	case SEG_386_UI+R_USR:
		evtrace32(evp->r[EBP], ISP_386 - stob(1), ISP_386);
		break;
	default:
		printf("evp->r[CS] = %x\n", evp->r[CS]);
		panic("evtrace");
	}
	printf("\n");
	setspace(save);
}

#define	MAXCALL	4

typedef struct frame32
{	
	int		prev;
	int		ra;
	int		a[1];
} FRAME32;

evtrace32(fp, fmin, fmax)
FRAME32	*fp, *fmin, *fmax;
{
	register int i, where;

	printf("evtrace32: %x %x %x\n", fp, fmin, fmax);
	for (i = 0; fp>fmin && fp<fmax && i<MAXCALL; i++) {
		where = getuwd(&fp->ra);
		if (getubd(where - 5*sizeof(char)) == 0xe8) /*call*/
			where += getuwd(where-sizeof(long));
		else
			putchar('*');
		printf("%x(", where);
		printf("%x %x)", getuwd(&fp->a[0]), getuwd(&fp->a[1]));
		fp = (FRAME32*) getuwd(&fp->prev);
	}
}

typedef struct frame16
{	
	unsigned short prev;
	unsigned short si, di; 	
	unsigned short ra;
	unsigned short a[1];
} FRAME16;

evtrace16(fp, fmin, fmax)
FRAME16 *fp, *fmin, *fmax;
{
	register int i, where;


	printf("evtrace16: %x %x %x\n", fp, fmin, fmax);
	for (i = 0; fp>fmin && fp<fmax && i<MAXCALL; i++) {
		where = (unsigned short) getuwd(&fp->ra);
		if (getubd(where+NBPS-3*sizeof(char)) == 0xe8) /*call*/
			where = (unsigned short) (where + 
				getuwd(where+NBPS-sizeof(short)));
		else
			putchar('*');
		printf("%x(", where);
		printf("%x %x)",
			(unsigned short) getuwd(&fp->a[0]),
			(unsigned short) getuwd(&fp->a[1]));
		fp = (FRAME16*) (unsigned short) getuwd(&fp->prev);
	}
}

@


1.2
log
@kernel 59: vaddr() checks MAX_VADDR; rounds CMOS RAM down to
click boundary... CHIRPS, _CHIRPS
@
text
@a79 1
void		zero_fill();
d81 2
a93 1
	
a102 1

a114 1
	
d129 1
a129 1
		ptable1_v[base1++] =  SEG_ILL;
d713 1
a713 1
	dataseg = clickseg(*--sysmem.pfree);	/* 5.b */
a794 1

a803 1

d818 8
d829 1
a829 1
	extern IDT	idt[], bdt[], idtend[], bdtend[];
d832 1
d834 11
a844 6
	for (ip = idt; ip <idtend; ip++)
		ip->seg = SEG_386_KI;
	for (ip = bdt; ip <bdtend; ip++)
		ip->seg = SEG_386_KI;
	for (ip = ldt; ip <ldtend; ip++)
		ip->seg = SEG_386_KI;
d899 1
a899 3
			/*
			 * Historical note - "pipe bug" fixed here.
			 */
d926 4
d931 1
a931 1
 * General initialisation
a932 1

d941 7
d952 4
d1000 1
a1000 1
	slotp  = (int *)  base;
a1310 16
/*
 * Fill a 4-byte-aligned region of memory with zeros.
 *
 * Arguments are the starting address and the size in bytes of the region
 * to be cleared.
 */
void
zero_fill(from, len)
register long *from;
register int len;
{
	len /= sizeof(long);
        while (len-->0)
                *from++ = 0;
}

a1320 5
/*
 * Sleazy tunable to see how much extra we need to make dash work.
 */
unsigned C_INCR = 0;

d1332 2
a1333 5
	/*
	 * The C_INCR is added to find out how much extra memory is needed
	 * to make dash work.
	 */
	new_clicks = btoc(new_bytes + C_INCR);
d1407 1
a1407 1
	 *   into system absolute address.
@


1.1
log
@Initial revision
@
text
@d29 5
a33 1
int HACK_LIMIT = (16*ONE_MEG);
d228 5
a232 1
	if (!(osz & (osz-1))) {
d469 2
d481 1
a481 1
	register int	base;
d511 1
a511 1
	chirp('A');
d513 1
a513 1
	chirp('B');
d528 3
d545 4
d550 2
a551 2
	lo = (read16_cmos(LOMEM) * ONE_K) - ctob(sysmem.lo);
	hi = read16_cmos(EXTMEM) * ONE_K;
d553 13
a565 3
#ifndef SUPRESS_UGLY_HACK
	/*** UGLY HACK ****** UGLY HACK ****** UGLY HACK ***
	 * For some reason, we die horribly if there is too much memory.
a569 2
	/*** END UGLY HACK ***/
#endif /* SUPRESS_UGLY_HACK */
d571 1
d573 1
d575 1
d581 20
d602 4
d614 4
a617 1
		/* include in system area pages for arena, free area */
d622 4
d627 2
a628 1
	while (base > sysmem.lo)
d630 2
d634 1
a634 1
	while (base < sysmem.hi)
d636 2
d641 44
d686 12
d728 2
d755 3
d777 3
d781 1
a781 1
	 * 9. allocate and map U area
d790 2
d800 3
d809 1
d811 1
d997 10
d1289 10
a1298 4
/* Fill a region of memory with zeros.  */
void zero_fill(from, len)
char *from;
int len;
d1300 3
a1302 4
        while (len-->0) {
                *from = 0;
                from++;
        }
d1306 2
a1307 1
unsigned int read16_cmos(addr)
@
